import util from 'util';
import fs from 'fs';
import path from 'path';
import async from 'async';
import rimraf from 'rimraf';
import mkdirp from 'mkdirp';
import sanitizeFilename from 'sanitize-filename';
import moment from 'moment';
import randomatic from 'randomatic';
import lodash from 'lodash';
import boolean$1 from 'boolean';
import events from 'events';
import debug$l from 'debug';
import vm2 from 'vm2';
import isClass from 'is-class';
import crypto from 'crypto';
import globby from 'globby';
import promiseRetry from 'promise-retry';
import promise from 'promise.allsettled';
import uuid from 'uuid';
import jsonpath from 'jsonpath';
import isJson$1 from 'is-json';
import esprima from 'esprima';
import markdownIt from 'markdown-it';
import xlsx from 'xlsx';
import sync from 'csv-parse/lib/sync';
import yaml from 'yaml';
import child_process from 'child_process';
import socket from 'socket.io-client';
import bottleneck from 'bottleneck';
import request from 'request';
import mustache from 'mustache';
import mimeTypes from 'mime-types';
import ioredis from 'ioredis';
import express from 'express';
import bodyParser from 'body-parser';

var name = "botium-core";
var version$1 = "1.11.15";
var description = "The Selenium for Chatbots";
var main = "index.js";
var module = "dist/botium-es.js";
var engines = {
	node: ">=10.0.0"
};
var scripts = {
	postinstall: "node ./report.js",
	build: "npm run eslint && nyc npm test && nyc check-coverage --lines 50 --functions 50 --branches 35 && rollup -c",
	eslint: "eslint \"./src/**/*.js\" \"./test/**/*.js\"",
	"eslint-fix": "eslint --fix \"./src/**/*.js\" \"./test/**/*.js\"",
	newpatch: "npm version patch",
	agent: "node ./src/grid/agent/agent.js",
	"agent-jsdoc": "swagger-jsdoc -d ./src/grid/agent/swaggerDef.json -o ./src/grid/agent/swagger.json ./src/grid/agent/routes.js",
	link: "npm link botium-connector-dialogflow botium-connector-webdriverio botium-connector-directline3 botium-connector-watson botium-connector-alexa-smapi botium-connector-echo",
	test: "cross-env NODE_PATH=\"./test/plugins/plugindir/fromfolder:./test/plugins/plugindir/fromfile:./test/security/resources\" mocha \"./test/**/*.spec.js\"",
	"coverage:report": "nyc report --reporter=lcov npm test",
	"license-checker": "license-checker > LICENSES-3RDPARTY.txt",
	"update-dependencies": "npm-check-updates --reject globby -u --timeout 120000"
};
var repository = {
	type: "git",
	url: "git+https://github.com/codeforequity-at/botium-core.git"
};
var author = "Florian Treml";
var license = "MIT";
var bugs = {
	url: "https://github.com/codeforequity-at/botium-core/issues"
};
var homepage = "https://www.botium.ai";
var dependencies = {
	"@babel/runtime": "^7.16.0",
	async: "^3.2.2",
	"body-parser": "^1.19.0",
	boolean: "^3.1.4",
	bottleneck: "^2.19.5",
	"csv-parse": "^4.16.3",
	debug: "^4.3.2",
	esprima: "^4.0.1",
	express: "^4.17.1",
	globby: "11.0.4",
	ioredis: "^4.28.0",
	"is-class": "^0.0.9",
	"is-json": "^2.0.1",
	jsonpath: "^1.1.1",
	lodash: "^4.17.21",
	"markdown-it": "^12.2.0",
	"mime-types": "^2.1.33",
	mkdirp: "^1.0.4",
	moment: "^2.29.1",
	mustache: "^4.2.0",
	"promise-retry": "^2.0.1",
	"promise.allsettled": "^1.0.5",
	randomatic: "^3.1.1",
	request: "^2.88.2",
	rimraf: "^3.0.2",
	"sanitize-filename": "^1.6.3",
	slugify: "^1.6.1",
	"socket.io": "^4.3.1",
	"socket.io-client": "^4.3.2",
	"socketio-auth": "^0.1.1",
	"swagger-jsdoc": "^6.1.0",
	"swagger-ui-express": "^4.1.6",
	uuid: "^8.3.2",
	vm2: "^3.9.5",
	"write-yaml": "^1.0.0",
	xlsx: "^0.17.3",
	xregexp: "^5.1.0",
	yaml: "^1.10.2"
};
var devDependencies = {
	"@babel/core": "^7.16.0",
	"@babel/node": "^7.16.0",
	"@babel/plugin-transform-runtime": "^7.16.0",
	"@babel/preset-env": "^7.16.0",
	chai: "^4.3.4",
	"chai-as-promised": "^7.1.1",
	"cross-env": "^7.0.3",
	eslint: "^8.1.0",
	"eslint-config-standard": "^16.0.3",
	"eslint-plugin-import": "^2.25.2",
	"eslint-plugin-node": "^11.1.0",
	"eslint-plugin-promise": "^5.1.1",
	"eslint-plugin-standard": "^4.1.0",
	"license-checker": "^25.0.1",
	"license-compatibility-checker": "^0.3.5",
	mocha: "^9.1.3",
	nock: "^13.1.4",
	"npm-check-updates": "^12.0.0",
	nyc: "^15.1.0",
	rollup: "^2.59.0",
	"rollup-plugin-babel": "^4.4.0",
	"rollup-plugin-commonjs": "^10.1.0",
	"rollup-plugin-json": "^4.0.0",
	"rollup-plugin-node-resolve": "^5.2.0"
};
var _package = {
	name: name,
	version: version$1,
	description: description,
	main: main,
	module: module,
	engines: engines,
	scripts: scripts,
	repository: repository,
	author: author,
	license: license,
	bugs: bugs,
	homepage: homepage,
	dependencies: dependencies,
	devDependencies: devDependencies
};

var _package$1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  name: name,
  version: version$1,
  description: description,
  main: main,
  module: module,
  engines: engines,
  scripts: scripts,
  repository: repository,
  author: author,
  license: license,
  bugs: bugs,
  homepage: homepage,
  dependencies: dependencies,
  devDependencies: devDependencies,
  'default': _package
});

var Capabilities = {
  PROJECTNAME: 'PROJECTNAME',
  TESTSESSIONNAME: 'TESTSESSIONNAME',
  TESTCASENAME: 'TESTCASENAME',
  TEMPDIR: 'TEMPDIR',
  CLEANUPTEMPDIR: 'CLEANUPTEMPDIR',
  WAITFORBOTTIMEOUT: 'WAITFORBOTTIMEOUT',
  CONTAINERMODE: 'CONTAINERMODE',
  PLUGINMODULEPATH: 'PLUGINMODULEPATH',
  // falsy or ms/keystroke
  SIMULATE_WRITING_SPEED: 'SIMULATE_WRITING_SPEED',
  BOTIUMGRIDURL: 'BOTIUMGRIDURL',
  BOTIUMAPITOKEN: 'BOTIUMAPITOKEN',
  BOTIUMGRIDSLOT: 'BOTIUMGRIDSLOT',
  // Simple Reset Bot Settings
  SIMPLEREST_PING_URL: 'SIMPLEREST_PING_URL',
  SIMPLEREST_PING_VERB: 'SIMPLEREST_PING_VERB',
  SIMPLEREST_PING_BODY: 'SIMPLEREST_PING_BODY',
  SIMPLEREST_PING_BODY_RAW: 'SIMPLEREST_PING_BODY_RAW',
  SIMPLEREST_PING_HEADERS: 'SIMPLEREST_PING_HEADERS',
  SIMPLEREST_PING_REQUEST_HOOK: 'SIMPLEREST_PING_REQUEST_HOOK',
  SIMPLEREST_PING_RETRIES: 'SIMPLEREST_PING_RETRIES',
  SIMPLEREST_PING_TIMEOUT: 'SIMPLEREST_PING_TIMEOUT',
  SIMPLEREST_PING_UPDATE_CONTEXT: 'SIMPLEREST_PING_UPDATE_CONTEXT',
  SIMPLEREST_PING_PROCESS_RESPONSE: 'SIMPLEREST_PING_PROCESS_RESPONSE',
  SIMPLEREST_START_URL: 'SIMPLEREST_START_URL',
  SIMPLEREST_START_VERB: 'SIMPLEREST_START_VERB',
  SIMPLEREST_START_BODY: 'SIMPLEREST_START_BODY',
  SIMPLEREST_START_BODY_RAW: 'SIMPLEREST_START_BODY_RAW',
  SIMPLEREST_START_HEADERS: 'SIMPLEREST_START_HEADERS',
  SIMPLEREST_START_REQUEST_HOOK: 'SIMPLEREST_START_REQUEST_HOOK',
  SIMPLEREST_START_RETRIES: 'SIMPLEREST_START_RETRIES',
  SIMPLEREST_START_TIMEOUT: 'SIMPLEREST_START_TIMEOUT',
  SIMPLEREST_START_UPDATE_CONTEXT: 'SIMPLEREST_START_UPDATE_CONTEXT',
  SIMPLEREST_START_PROCESS_RESPONSE: 'SIMPLEREST_START_PROCESS_RESPONSE',
  SIMPLEREST_STOP_URL: 'SIMPLEREST_STOP_URL',
  SIMPLEREST_STOP_VERB: 'SIMPLEREST_STOP_VERB',
  SIMPLEREST_STOP_BODY: 'SIMPLEREST_STOP_BODY',
  SIMPLEREST_STOP_BODY_RAW: 'SIMPLEREST_STOP_BODY_RAW',
  SIMPLEREST_STOP_HEADERS: 'SIMPLEREST_STOP_HEADERS',
  SIMPLEREST_STOP_REQUEST_HOOK: 'SIMPLEREST_STOP_REQUEST_HOOK',
  SIMPLEREST_STOP_RETRIES: 'SIMPLEREST_STOP_RETRIES',
  SIMPLEREST_STOP_TIMEOUT: 'SIMPLEREST_STOP_TIMEOUT',
  SIMPLEREST_INIT_CONTEXT: 'SIMPLEREST_INIT_CONTEXT',
  SIMPLEREST_INIT_TEXT: 'SIMPLEREST_INIT_TEXT',
  SIMPLEREST_INIT_PROCESS_RESPONSE: 'SIMPLEREST_INIT_PROCESS_RESPONSE',
  SIMPLEREST_PROXY_URL: 'SIMPLEREST_PROXY_URL',
  SIMPLEREST_STRICT_SSL: 'SIMPLEREST_STRICT_SSL',
  SIMPLEREST_URL: 'SIMPLEREST_URL',
  SIMPLEREST_EXTRA_OPTIONS: 'SIMPLEREST_EXTRA_OPTIONS',
  SIMPLEREST_IGNORE_EMPTY: 'SIMPLEREST_IGNORE_EMPTY',
  SIMPLEREST_TIMEOUT: 'SIMPLEREST_TIMEOUT',
  SIMPLEREST_METHOD: 'SIMPLEREST_METHOD',
  SIMPLEREST_VERB: 'SIMPLEREST_VERB',
  SIMPLEREST_HEADERS_TEMPLATE: 'SIMPLEREST_HEADERS_TEMPLATE',
  SIMPLEREST_BODY_TEMPLATE: 'SIMPLEREST_BODY_TEMPLATE',
  SIMPLEREST_BODY_RAW: 'SIMPLEREST_BODY_RAW',
  SIMPLEREST_START_HOOK: 'SIMPLEREST_START_HOOK',
  SIMPLEREST_STOP_HOOK: 'SIMPLEREST_STOP_HOOK',
  SIMPLEREST_REQUEST_HOOK: 'SIMPLEREST_REQUEST_HOOK',
  SIMPLEREST_PARSER_HOOK: 'SIMPLEREST_PARSER_HOOK',
  SIMPLEREST_POLL_URL: 'SIMPLEREST_POLL_URL',
  SIMPLEREST_POLL_VERB: 'SIMPLEREST_POLL_VERB',
  SIMPLEREST_POLL_BODY: 'SIMPLEREST_POLL_BODY',
  SIMPLEREST_POLL_BODY_RAW: 'SIMPLEREST_POLL_BODY_RAW',
  SIMPLEREST_POLL_HEADERS: 'SIMPLEREST_POLL_HEADERS',
  SIMPLEREST_POLL_REQUEST_HOOK: 'SIMPLEREST_POLL_REQUEST_HOOK',
  SIMPLEREST_POLL_INTERVAL: 'SIMPLEREST_POLL_INTERVAL',
  SIMPLEREST_POLL_TIMEOUT: 'SIMPLEREST_PING_TIMEOUT',
  SIMPLEREST_POLL_UPDATE_CONTEXT: 'SIMPLEREST_POLL_UPDATE_CONTEXT',
  SIMPLEREST_BODY_JSONPATH: 'SIMPLEREST_BODY_JSONPATH',
  SIMPLEREST_RESPONSE_JSONPATH: 'SIMPLEREST_RESPONSE_JSONPATH',
  SIMPLEREST_RESPONSE_HOOK: 'SIMPLEREST_RESPONSE_HOOK',
  SIMPLEREST_MEDIA_JSONPATH: 'SIMPLEREST_MEDIA_JSONPATH',
  SIMPLEREST_BUTTONS_JSONPATH: 'SIMPLEREST_BUTTONS_JSONPATH',
  SIMPLEREST_CONTEXT_JSONPATH: 'SIMPLEREST_CONTEXT_JSONPATH',
  SIMPLEREST_CONTEXT_MERGE_OR_REPLACE: 'SIMPLEREST_CONTEXT_MERGE_OR_REPLACE',
  SIMPLEREST_CONVERSATION_ID_TEMPLATE: 'SIMPLEREST_CONVERSATION_ID_TEMPLATE',
  SIMPLEREST_STEP_ID_TEMPLATE: 'SIMPLEREST_STEP_ID_TEMPLATE',
  SIMPLEREST_INBOUND_REDISURL: 'SIMPLEREST_INBOUND_REDISURL',
  SIMPLEREST_INBOUND_ENDPOINT: 'SIMPLEREST_INBOUND_ENDPOINT',
  SIMPLEREST_INBOUND_PORT: 'SIMPLEREST_INBOUND_PORT',
  SIMPLEREST_INBOUND_SELECTOR_JSONPATH: 'SIMPLEREST_INBOUND_SELECTOR_JSONPATH',
  SIMPLEREST_INBOUND_SELECTOR_VALUE: 'SIMPLEREST_INBOUND_SELECTOR_VALUE',
  SIMPLEREST_INBOUND_UPDATE_CONTEXT: 'SIMPLEREST_INBOUND_UPDATE_CONTEXT',
  SIMPLEREST_REDIS_TOPIC: 'SIMPLEREST_REDIS_TOPIC',
  SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH: 'SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH',
  SIMPLEREST_INBOUND_DEBOUNCE_TIMEOUT: 'SIMPLEREST_INBOUND_DEBOUNCE_TIMEOUT',
  // Script Compiler
  SCRIPTING_TXT_EOL: 'SCRIPTING_TXT_EOL',
  // ROW_PER_MESSAGE or QUESTION_ANSWER
  SCRIPTING_XLSX_MODE: 'SCRIPTING_XLSX_MODE',
  SCRIPTING_XLSX_EOL_WRITE: 'SCRIPTING_XLSX_EOL_WRITE',
  SCRIPTING_XLSX_STARTROW: 'SCRIPTING_XLSX_STARTROW',
  SCRIPTING_XLSX_STARTCOL: 'SCRIPTING_XLSX_STARTCOL',
  SCRIPTING_XLSX_HASNAMECOL: 'SCRIPTING_XLSX_HASNAMECOL',
  SCRIPTING_XLSX_HASHEADERS: 'SCRIPTING_XLSX_HASHEADERS',
  SCRIPTING_XLSX_SHEETNAMES: 'SCRIPTING_XLSX_SHEETNAMES',
  SCRIPTING_XLSX_SHEETNAMES_PCONVOS: 'SCRIPTING_XLSX_SHEETNAMES_PCONVOS',
  SCRIPTING_XLSX_SHEETNAMES_UTTERANCES: 'SCRIPTING_XLSX_SHEETNAMES_UTTERANCES',
  SCRIPTING_XLSX_SHEETNAMES_SCRIPTING_MEMORY: 'SCRIPTING_XLSX_SHEETNAMES_SCRIPTING_MEMORY',
  SCRIPTING_CSV_DELIMITER: 'SCRIPTING_CSV_DELIMITER',
  SCRIPTING_CSV_SKIP_HEADER: 'SCRIPTING_CSV_SKIP_HEADER',
  SCRIPTING_CSV_QUOTE: 'SCRIPTING_CSV_QUOTE',
  SCRIPTING_CSV_ESCAPE: 'SCRIPTING_CSV_ESCAPE',
  SCRIPTING_CSV_MULTIROW_COLUMN_CONVERSATION_ID: 'SCRIPTING_CSV_MULTIROW_COLUMN_CONVERSATION_ID',
  SCRIPTING_CSV_MULTIROW_COLUMN_SENDER: 'SCRIPTING_CSV_MULTIROW_COLUMN_SENDER',
  SCRIPTING_CSV_MULTIROW_COLUMN_TEXT: 'SCRIPTING_CSV_MULTIROW_COLUMN_TEXT',
  SCRIPTING_CSV_QA_COLUMN_QUESTION: 'SCRIPTING_CSV_QA_COLUMN_QUESTION',
  SCRIPTING_CSV_QA_COLUMN_ANSWER: 'SCRIPTING_CSV_QA_COLUMN_ANSWER',
  SCRIPTING_NORMALIZE_TEXT: 'SCRIPTING_NORMALIZE_TEXT',
  SCRIPTING_ENABLE_MEMORY: 'SCRIPTING_ENABLE_MEMORY',
  SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS: 'SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS',
  SCRIPTING_FORCE_BOT_CONSUMED: 'SCRIPTING_FORCE_BOT_CONSUMED',
  // regexp, regexpIgnoreCase, wildcard, wildcardIgnoreCase, wildcardExact, wildcardExactIgnoreCase, include, includeIgnoreCase, equals, equalsIgnoreCase
  SCRIPTING_MATCHING_MODE: 'SCRIPTING_MATCHING_MODE',
  // all, first, random
  SCRIPTING_UTTEXPANSION_MODE: 'SCRIPTING_UTTEXPANSION_MODE',
  SCRIPTING_UTTEXPANSION_RANDOM_COUNT: 'SCRIPTING_UTTEXPANSION_RANDOM_COUNT',
  SCRIPTING_UTTEXPANSION_INCOMPREHENSION: 'SCRIPTING_UTTEXPANSION_INCOMPREHENSION',
  SCRIPTING_UTTEXPANSION_USENAMEASINTENT: 'SCRIPTING_UTTEXPANSION_USENAMEASINTENT',
  // justLineTag, utterance
  SCRIPTING_UTTEXPANSION_NAMING_MODE: 'SCRIPTING_UTTEXPANSION_NAMING_MODE',
  SCRIPTING_UTTEXPANSION_NAMING_UTTERANCE_MAX: 'SCRIPTING_UTTEXPANSION_NAMING_UTTERANCE_MAX',
  // Del original convo or not
  SCRIPTING_MEMORYEXPANSION_KEEP_ORIG: 'SCRIPTING_MEMORYEXPANSION_KEEP_ORIG',
  // word, non_whitespace, joker
  SCRIPTING_MEMORY_MATCHING_MODE: 'SCRIPTING_MEMORY_MATCHING_MODE',
  // Botium Lifecycle Hooks
  CUSTOMHOOK_ONBUILD: 'CUSTOMHOOK_ONBUILD',
  CUSTOMHOOK_ONSTART: 'CUSTOMHOOK_ONSTART',
  CUSTOMHOOK_ONUSERSAYS: 'CUSTOMHOOK_ONUSERSAYS',
  CUSTOMHOOK_ONBOTRESPONSE: 'CUSTOMHOOK_ONBOTRESPONSE',
  CUSTOMHOOK_ONSTOP: 'CUSTOMHOOK_ONSTOP',
  CUSTOMHOOK_ONCLEAN: 'CUSTOMHOOK_ONCLEAN',
  // Extension components
  ASSERTERS: 'ASSERTERS',
  LOGIC_HOOKS: 'LOGIC_HOOKS',
  USER_INPUTS: 'USER_INPUTS',
  // API Calls Rate Limiting
  RATELIMIT_USERSAYS_MAXCONCURRENT: 'RATELIMIT_USERSAYS_MAXCONCURRENT',
  RATELIMIT_USERSAYS_MINTIME: 'RATELIMIT_USERSAYS_MINTIME',
  SECURITY_ALLOW_UNSAFE: 'SECURITY_ALLOW_UNSAFE',
  PRECOMPILERS: 'PRECOMPILERS'
};
Capabilities.PROJECTNAME;
Capabilities.TESTSESSIONNAME;
Capabilities.TESTCASENAME;
Capabilities.TEMPDIR;
Capabilities.CLEANUPTEMPDIR;
Capabilities.WAITFORBOTTIMEOUT;
Capabilities.CONTAINERMODE;
Capabilities.PLUGINMODULEPATH;
Capabilities.SIMULATE_WRITING_SPEED;
Capabilities.BOTIUMGRIDURL;
Capabilities.BOTIUMAPITOKEN;
Capabilities.BOTIUMGRIDSLOT;
Capabilities.SIMPLEREST_PING_URL;
Capabilities.SIMPLEREST_PING_VERB;
Capabilities.SIMPLEREST_PING_BODY;
Capabilities.SIMPLEREST_PING_BODY_RAW;
Capabilities.SIMPLEREST_PING_HEADERS;
Capabilities.SIMPLEREST_PING_REQUEST_HOOK;
Capabilities.SIMPLEREST_PING_RETRIES;
Capabilities.SIMPLEREST_PING_TIMEOUT;
Capabilities.SIMPLEREST_PING_UPDATE_CONTEXT;
Capabilities.SIMPLEREST_PING_PROCESS_RESPONSE;
Capabilities.SIMPLEREST_START_URL;
Capabilities.SIMPLEREST_START_VERB;
Capabilities.SIMPLEREST_START_BODY;
Capabilities.SIMPLEREST_START_BODY_RAW;
Capabilities.SIMPLEREST_START_HEADERS;
Capabilities.SIMPLEREST_START_REQUEST_HOOK;
Capabilities.SIMPLEREST_START_RETRIES;
Capabilities.SIMPLEREST_START_TIMEOUT;
Capabilities.SIMPLEREST_START_UPDATE_CONTEXT;
Capabilities.SIMPLEREST_START_PROCESS_RESPONSE;
Capabilities.SIMPLEREST_STOP_URL;
Capabilities.SIMPLEREST_STOP_VERB;
Capabilities.SIMPLEREST_STOP_BODY;
Capabilities.SIMPLEREST_STOP_BODY_RAW;
Capabilities.SIMPLEREST_STOP_HEADERS;
Capabilities.SIMPLEREST_STOP_REQUEST_HOOK;
Capabilities.SIMPLEREST_STOP_RETRIES;
Capabilities.SIMPLEREST_STOP_TIMEOUT;
Capabilities.SIMPLEREST_INIT_CONTEXT;
Capabilities.SIMPLEREST_INIT_TEXT;
Capabilities.SIMPLEREST_INIT_PROCESS_RESPONSE;
Capabilities.SIMPLEREST_PROXY_URL;
Capabilities.SIMPLEREST_STRICT_SSL;
Capabilities.SIMPLEREST_URL;
Capabilities.SIMPLEREST_EXTRA_OPTIONS;
Capabilities.SIMPLEREST_IGNORE_EMPTY;
Capabilities.SIMPLEREST_TIMEOUT;
Capabilities.SIMPLEREST_METHOD;
Capabilities.SIMPLEREST_VERB;
Capabilities.SIMPLEREST_HEADERS_TEMPLATE;
Capabilities.SIMPLEREST_BODY_TEMPLATE;
Capabilities.SIMPLEREST_BODY_RAW;
Capabilities.SIMPLEREST_START_HOOK;
Capabilities.SIMPLEREST_STOP_HOOK;
Capabilities.SIMPLEREST_REQUEST_HOOK;
Capabilities.SIMPLEREST_PARSER_HOOK;
Capabilities.SIMPLEREST_POLL_URL;
Capabilities.SIMPLEREST_POLL_VERB;
Capabilities.SIMPLEREST_POLL_BODY;
Capabilities.SIMPLEREST_POLL_BODY_RAW;
Capabilities.SIMPLEREST_POLL_HEADERS;
Capabilities.SIMPLEREST_POLL_REQUEST_HOOK;
Capabilities.SIMPLEREST_POLL_INTERVAL;
Capabilities.SIMPLEREST_POLL_TIMEOUT;
Capabilities.SIMPLEREST_POLL_UPDATE_CONTEXT;
Capabilities.SIMPLEREST_BODY_JSONPATH;
Capabilities.SIMPLEREST_RESPONSE_JSONPATH;
Capabilities.SIMPLEREST_RESPONSE_HOOK;
Capabilities.SIMPLEREST_MEDIA_JSONPATH;
Capabilities.SIMPLEREST_BUTTONS_JSONPATH;
Capabilities.SIMPLEREST_CONTEXT_JSONPATH;
Capabilities.SIMPLEREST_CONTEXT_MERGE_OR_REPLACE;
Capabilities.SIMPLEREST_CONVERSATION_ID_TEMPLATE;
Capabilities.SIMPLEREST_STEP_ID_TEMPLATE;
Capabilities.SIMPLEREST_INBOUND_REDISURL;
Capabilities.SIMPLEREST_INBOUND_ENDPOINT;
Capabilities.SIMPLEREST_INBOUND_PORT;
Capabilities.SIMPLEREST_INBOUND_SELECTOR_JSONPATH;
Capabilities.SIMPLEREST_INBOUND_SELECTOR_VALUE;
Capabilities.SIMPLEREST_INBOUND_UPDATE_CONTEXT;
Capabilities.SIMPLEREST_REDIS_TOPIC;
Capabilities.SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH;
Capabilities.SIMPLEREST_INBOUND_DEBOUNCE_TIMEOUT;
Capabilities.SCRIPTING_TXT_EOL;
Capabilities.SCRIPTING_XLSX_MODE;
Capabilities.SCRIPTING_XLSX_EOL_WRITE;
Capabilities.SCRIPTING_XLSX_STARTROW;
Capabilities.SCRIPTING_XLSX_STARTCOL;
Capabilities.SCRIPTING_XLSX_HASNAMECOL;
Capabilities.SCRIPTING_XLSX_HASHEADERS;
Capabilities.SCRIPTING_XLSX_SHEETNAMES;
Capabilities.SCRIPTING_XLSX_SHEETNAMES_PCONVOS;
Capabilities.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES;
Capabilities.SCRIPTING_XLSX_SHEETNAMES_SCRIPTING_MEMORY;
Capabilities.SCRIPTING_CSV_DELIMITER;
Capabilities.SCRIPTING_CSV_SKIP_HEADER;
Capabilities.SCRIPTING_CSV_QUOTE;
Capabilities.SCRIPTING_CSV_ESCAPE;
Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_CONVERSATION_ID;
Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_SENDER;
Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_TEXT;
Capabilities.SCRIPTING_CSV_QA_COLUMN_QUESTION;
Capabilities.SCRIPTING_CSV_QA_COLUMN_ANSWER;
Capabilities.SCRIPTING_NORMALIZE_TEXT;
Capabilities.SCRIPTING_ENABLE_MEMORY;
Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS;
Capabilities.SCRIPTING_FORCE_BOT_CONSUMED;
Capabilities.SCRIPTING_MATCHING_MODE;
Capabilities.SCRIPTING_UTTEXPANSION_MODE;
Capabilities.SCRIPTING_UTTEXPANSION_RANDOM_COUNT;
Capabilities.SCRIPTING_UTTEXPANSION_INCOMPREHENSION;
Capabilities.SCRIPTING_UTTEXPANSION_USENAMEASINTENT;
Capabilities.SCRIPTING_UTTEXPANSION_NAMING_MODE;
Capabilities.SCRIPTING_UTTEXPANSION_NAMING_UTTERANCE_MAX;
Capabilities.SCRIPTING_MEMORYEXPANSION_KEEP_ORIG;
Capabilities.SCRIPTING_MEMORY_MATCHING_MODE;
Capabilities.CUSTOMHOOK_ONBUILD;
Capabilities.CUSTOMHOOK_ONSTART;
Capabilities.CUSTOMHOOK_ONUSERSAYS;
Capabilities.CUSTOMHOOK_ONBOTRESPONSE;
Capabilities.CUSTOMHOOK_ONSTOP;
Capabilities.CUSTOMHOOK_ONCLEAN;
Capabilities.ASSERTERS;
Capabilities.LOGIC_HOOKS;
Capabilities.USER_INPUTS;
Capabilities.RATELIMIT_USERSAYS_MAXCONCURRENT;
Capabilities.RATELIMIT_USERSAYS_MINTIME;
Capabilities.SECURITY_ALLOW_UNSAFE;
Capabilities.PRECOMPILERS;

var Source = {
  LOCALPATH: 'LOCALPATH',
  GITPATH: 'GITPATH',
  GITURL: 'GITURL',
  GITBRANCH: 'GITBRANCH',
  GITDIR: 'GITDIR',
  GITPREPARECMD: 'GITPREPARECMD'
};
Source.LOCALPATH;
Source.GITPATH;
Source.GITURL;
Source.GITBRANCH;
Source.GITDIR;
Source.GITPREPARECMD;

var Defaults$1 = {
  Capabilities: {
    [Capabilities.PROJECTNAME]: 'Botium Project',
    [Capabilities.TESTSESSIONNAME]: 'Botium Test Session',
    [Capabilities.TESTCASENAME]: 'Botium Test Case',
    [Capabilities.TEMPDIR]: 'botiumwork',
    [Capabilities.CLEANUPTEMPDIR]: true,
    [Capabilities.WAITFORBOTTIMEOUT]: 10000,
    [Capabilities.SIMULATE_WRITING_SPEED]: false,
    [Capabilities.SIMPLEREST_PING_RETRIES]: 6,
    [Capabilities.SIMPLEREST_PING_TIMEOUT]: 10000,
    [Capabilities.SIMPLEREST_PING_VERB]: 'GET',
    [Capabilities.SIMPLEREST_PING_UPDATE_CONTEXT]: true,
    [Capabilities.SIMPLEREST_PING_PROCESS_RESPONSE]: false,
    [Capabilities.SIMPLEREST_INIT_PROCESS_RESPONSE]: false,
    [Capabilities.SIMPLEREST_STOP_RETRIES]: 6,
    [Capabilities.SIMPLEREST_STOP_TIMEOUT]: 10000,
    [Capabilities.SIMPLEREST_STOP_VERB]: 'GET',
    [Capabilities.SIMPLEREST_START_RETRIES]: 6,
    [Capabilities.SIMPLEREST_START_TIMEOUT]: 10000,
    [Capabilities.SIMPLEREST_START_UPDATE_CONTEXT]: true,
    [Capabilities.SIMPLEREST_START_PROCESS_RESPONSE]: true,
    [Capabilities.SIMPLEREST_START_VERB]: 'GET',
    [Capabilities.SIMPLEREST_POLL_VERB]: 'GET',
    [Capabilities.SIMPLEREST_POLL_INTERVAL]: 1000,
    [Capabilities.SIMPLEREST_POLL_TIMEOUT]: 10000,
    [Capabilities.SIMPLEREST_POLL_UPDATE_CONTEXT]: true,
    [Capabilities.SIMPLEREST_METHOD]: 'GET',
    [Capabilities.SIMPLEREST_IGNORE_EMPTY]: true,
    [Capabilities.SIMPLEREST_TIMEOUT]: 10000,
    [Capabilities.SIMPLEREST_EXTRA_OPTIONS]: {},
    [Capabilities.SIMPLEREST_STRICT_SSL]: true,
    [Capabilities.SIMPLEREST_INBOUND_UPDATE_CONTEXT]: true,
    [Capabilities.SIMPLEREST_CONTEXT_MERGE_OR_REPLACE]: 'MERGE',
    [Capabilities.SCRIPTING_TXT_EOL]: '\n',
    [Capabilities.SCRIPTING_XLSX_EOL_WRITE]: '\r\n',
    [Capabilities.SCRIPTING_XLSX_HASHEADERS]: true,
    [Capabilities.SCRIPTING_CSV_SKIP_HEADER]: true,
    [Capabilities.SCRIPTING_CSV_QUOTE]: '"',
    [Capabilities.SCRIPTING_CSV_ESCAPE]: '"',
    [Capabilities.SCRIPTING_NORMALIZE_TEXT]: true,
    [Capabilities.SCRIPTING_ENABLE_MEMORY]: false,
    [Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS]: false,
    [Capabilities.SCRIPTING_MATCHING_MODE]: 'wildcardIgnoreCase',
    [Capabilities.SCRIPTING_UTTEXPANSION_MODE]: 'all',
    [Capabilities.SCRIPTING_UTTEXPANSION_RANDOM_COUNT]: 1,
    [Capabilities.SCRIPTING_UTTEXPANSION_NAMING_MODE]: 'justLineTag',
    [Capabilities.SCRIPTING_UTTEXPANSION_NAMING_UTTERANCE_MAX]: '16',
    [Capabilities.SCRIPTING_MEMORYEXPANSION_KEEP_ORIG]: false,
    [Capabilities.SCRIPTING_FORCE_BOT_CONSUMED]: false,
    [Capabilities.ASSERTERS]: [],
    [Capabilities.LOGIC_HOOKS]: [],
    [Capabilities.USER_INPUTS]: [],
    [Capabilities.SECURITY_ALLOW_UNSAFE]: true
  },
  Sources: {
    [Source.LOCALPATH]: '.',
    [Source.GITPATH]: 'git',
    [Source.GITBRANCH]: 'master',
    [Source.GITDIR]: '.'
  },
  Envs: {
    IS_BOTIUM_CONTAINER: true
  }
};
Defaults$1.Capabilities;
Defaults$1.Sources;
Defaults$1.Envs;

var Fluent_1 = class Fluent {
  constructor(driver) {
    this.driver = driver;
    this.compiler = null;
    this.container = null;
    this.currentChannel = null;
    this.tasks = [];
    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        this.driver.Build().then(container => {
          this.container = container;
          resolve();
        }).catch(err => {
          reject(err);
        });
      });
    });
  }

  Exec() {
    return new Promise((resolve, reject) => {
      async.eachSeries(this.tasks, (task, cb) => {
        try {
          const taskResult = task();

          if (taskResult && taskResult.then) {
            taskResult.then(() => cb()).catch(cb);
          } else {
            cb();
          }
        } catch (err) {
          cb(err);
        }
      }, err => {
        if (err) return reject(err);
        resolve();
      });
    });
  }

  Start() {
    this.tasks.push(() => {
      return this.container.Start();
    });
    return this;
  }

  SwitchChannel(channel) {
    this.tasks.push(() => {
      this.currentChannel = channel;
      return Promise.resolve();
    });
    return this;
  }

  ReadScripts(convoDir, globFilter) {
    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        if (this.compiler == null) {
          try {
            this.compiler = this.driver.BuildCompiler();
          } catch (err) {
            return reject(err);
          }
        }

        try {
          this.compiler.ReadScriptsFromDirectory(convoDir, globFilter);
          resolve();
        } catch (err) {
          reject(err);
        }
      });
    });
    return this;
  }

  Compile(scriptBuffer, scriptFormat, scriptType) {
    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        if (this.compiler == null) {
          try {
            this.compiler = this.driver.BuildCompiler();
          } catch (err) {
            return reject(err);
          }
        }

        try {
          this.compiler.Compile(scriptBuffer, scriptFormat, scriptType);
          resolve();
        } catch (err) {
          reject(err);
        }
      });
    });
    return this;
  }

  RunScripts(assertCb, failCb) {
    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        if (assertCb) {
          this.compiler.scriptingEvents.assertBotResponse = assertCb.bind(this.compiler);
        }

        if (failCb) {
          this.compiler.scriptingEvents.fail = failCb.bind(this.compiler);
        }

        this.compiler.ExpandConvos();
        async.eachSeries(this.compiler.convos, (convo, convoDone) => {
          this.container.Start().then(() => convo.Run(this.container)).then(() => this.container.Stop()).then(() => convoDone()).catch(convoDone);
        }, err => {
          if (err) return reject(err);else resolve();
        });
      });
    });
    return this;
  }

  UserSaysText(msg) {
    this.tasks.push(() => {
      if (lodash.isFunction(msg)) {
        msg = msg();
      }

      if (this.currentChannel) {
        return this.container.UserSays({
          messageText: msg,
          channel: this.currentChannel
        });
      } else {
        return this.container.UserSaysText(msg);
      }
    });
    return this;
  }

  UserSays(msg) {
    this.tasks.push(() => {
      if (lodash.isFunction(msg)) {
        msg = msg();
      }

      if (this.currentChannel && !msg.channel) {
        msg = Object.assign({}, msg);
        msg.channel = this.currentChannel;
      }

      return this.container.UserSays(msg);
    });
    return this;
  }

  WaitBotSays(channel = null, timeoutMillis = null, callback = null) {
    if (!callback) {
      if (timeoutMillis && lodash.isFunction(timeoutMillis)) {
        callback = timeoutMillis;
        timeoutMillis = null;
      } else if (!timeoutMillis && channel && lodash.isFunction(channel)) {
        callback = channel;
        timeoutMillis = null;
        channel = null;
      }
    }

    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        if (this.currentChannel && !channel) {
          channel = this.currentChannel;
        }

        this.container.WaitBotSays(channel, timeoutMillis).then(botMsg => {
          if (callback) callback(botMsg);
          resolve();
        }).catch(err => {
          reject(err);
        });
      });
    });
    return this;
  }

  WaitBotSaysText(channel = null, timeoutMillis = null, callback = null) {
    if (!callback) {
      if (timeoutMillis && lodash.isFunction(timeoutMillis)) {
        callback = timeoutMillis;
        timeoutMillis = null;
      } else if (!timeoutMillis && channel && lodash.isFunction(channel)) {
        callback = channel;
        timeoutMillis = null;
        channel = null;
      }
    }

    this.tasks.push(() => {
      return new Promise((resolve, reject) => {
        if (this.currentChannel && !channel) {
          channel = this.currentChannel;
        }

        this.container.WaitBotSaysText(channel, timeoutMillis).then(text => {
          if (callback) callback(text);
          resolve();
        }).catch(err => {
          reject(err);
        });
      });
    });
    return this;
  }

  Restart() {
    this.tasks.push(() => {
      return this.container.Restart();
    });
    return this;
  }

  Stop() {
    this.tasks.push(() => {
      return this.container.Stop();
    });
    return this;
  }

  Clean() {
    this.tasks.push(() => {
      return this.container.Clean();
    });
    return this;
  }

  Call(customFunction) {
    this.tasks.push(() => {
      return customFunction(this) || Promise.resolve();
    });
    return this;
  }

};

var Events = {
  // Botium Events
  CONTAINER_BUILDING: 'CONTAINER_BUILDING',
  CONTAINER_BUILT: 'CONTAINER_BUILT',
  CONTAINER_BUILD_ERROR: 'CONTAINER_BUILD_ERROR',
  CONTAINER_STARTING: 'CONTAINER_STARTING',
  CONTAINER_STARTED: 'CONTAINER_STARTED',
  CONTAINER_START_ERROR: 'CONTAINER_START_ERROR',
  CONTAINER_STOPPING: 'CONTAINER_STOPPING',
  CONTAINER_STOPPED: 'CONTAINER_STOPPED',
  CONTAINER_STOP_ERROR: 'CONTAINER_STOP_ERROR',
  CONTAINER_CLEANING: 'CONTAINER_CLEANING',
  CONTAINER_CLEANED: 'CONTAINER_CLEANED',
  CONTAINER_CLEAN_ERROR: 'CONTAINER_CLEAN_ERROR',
  BOT_CONNECTED: 'BOT_CONNECTED',
  // Chatbot Events
  MESSAGE_SENTTOBOT: 'MESSAGE_SENTTOBOT',
  MESSAGE_SENDTOBOT_ERROR: 'MESSAGE_SENDTOBOT_ERROR',
  MESSAGE_RECEIVEDFROMBOT: 'MESSAGE_RECEIVEDFROMBOT',
  MESSAGE_RECEIVEFROMBOT_ERROR: 'MESSAGE_RECEIVEFROMBOT_ERROR',
  MESSAGE_ATTACHMENT: 'MESSAGE_ATTACHMENT',
  MESSAGE_TRANSCRIPT: 'MESSAGE_TRANSCRIPT',
  // Botium Agent Events
  TOOMUCHWORKERS_ERROR: 'TOOMUCHWORKERS_ERROR'
};
Events.CONTAINER_BUILDING;
Events.CONTAINER_BUILT;
Events.CONTAINER_BUILD_ERROR;
Events.CONTAINER_STARTING;
Events.CONTAINER_STARTED;
Events.CONTAINER_START_ERROR;
Events.CONTAINER_STOPPING;
Events.CONTAINER_STOPPED;
Events.CONTAINER_STOP_ERROR;
Events.CONTAINER_CLEANING;
Events.CONTAINER_CLEANED;
Events.CONTAINER_CLEAN_ERROR;
Events.BOT_CONNECTED;
Events.MESSAGE_SENTTOBOT;
Events.MESSAGE_SENDTOBOT_ERROR;
Events.MESSAGE_RECEIVEDFROMBOT;
Events.MESSAGE_RECEIVEFROMBOT_ERROR;
Events.MESSAGE_ATTACHMENT;
Events.MESSAGE_TRANSCRIPT;
Events.TOOMUCHWORKERS_ERROR;

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

function getCjsExportFromNamespace (n) {
	return n && n['default'] || n;
}

const BotiumError$6 = class BotiumError extends Error {
  /**
   *
   * @param message
   * @param context A JSON with struct
   * {
   *   type: 'some free text to identity the exception type',
   *   source: 'source of the event',
   *   ...
   */
  constructor(message, context, supressChildCheck) {
    super(message.message || message);

    if (!supressChildCheck && _getChildErrorsFromContext(context)) {
      throw Error('Create BotiumError with child errors using the fromList() method!');
    } // Saving class name in the property of our custom error as a shortcut.


    this.name = this.constructor.name; // Capturing stack trace, excluding constructor call from it.

    Error.captureStackTrace(this, this.constructor);
    this.context = context || {};
    this.context.message = message.message || message;
  }

  prettify(includeJson) {
    const lines = [];

    if (this.context) {
      const errArr = lodash.isArray(this.context) ? this.context : [this.context];
      errArr.forEach(errDetail => {
        lines.push('########################################');

        if (errDetail.type === 'asserter') {
          const segments = [];
          segments.push(`ASSERTION FAILED in ${errDetail.source}${errDetail.subtype ? ` (${errDetail.subtype})` : ''}`);
          errDetail.cause && errDetail.cause.expected && !errDetail.cause.not && segments.push(` - Expected: ${JSON.stringify(errDetail.cause.expected)} `);
          errDetail.cause && errDetail.cause.expected && errDetail.cause.not && segments.push(` - NOT Expected: ${JSON.stringify(errDetail.cause.expected)} `);
          errDetail.cause && errDetail.cause.actual && segments.push(` - Actual: ${JSON.stringify(errDetail.cause.actual)}`);
          errDetail.cause && !errDetail.cause.actual && segments.push(' - Actual: empty');
          lines.push(segments.join(''));
          errDetail.input && errDetail.input.messageText && lines.push(`INPUT: ${errDetail.input.messageText}`);
        } else if (errDetail.message) {
          lines.push(`${errDetail.message}`);
        }

        if (errDetail.transcript && errDetail.transcript.length > 0) {
          lines.push('------------ TRANSCRIPT ----------------------------');
          errDetail.transcript.forEach(transcriptStep => {
            if (transcriptStep.actual) {
              lines.push(transcriptStep.actual.prettify());
            }
          });
        }

        if (includeJson) {
          lines.push('------------ JSON CONTENT ----------------------------');

          try {
            const jsonOutput = JSON.stringify(errDetail);
            lines.push(jsonOutput);
          } catch (jsonErr) {
            lines.push(`JSON Output not possible: ${jsonErr.message}`);
          }
        }
      });
    }

    if (lines.length > 0) {
      return lines.join('\r\n');
    } else {
      return null;
    }
  }

};

const _getChildErrorsFromContext = context => {
  if (context && context.errors && lodash.isArray(context.errors)) {
    return context.errors;
  }

  return false;
};

const botiumErrorFromErr$2 = (message, err) => {
  if (err instanceof BotiumError$6) {
    return new BotiumError$6(message, err.context, true);
  } else {
    return new BotiumError$6(message, {
      err
    }, true);
  }
};

const botiumErrorFromList$2 = (errors, {
  type = 'list',
  source = 'BotiumError',
  flat = true
}) => {
  const message = errors.map(err => err.message || err.toString()).join(',\n');
  let children = [];

  for (const error of errors) {
    if (error instanceof BotiumError$6) {
      const childErrors = flat && _getChildErrorsFromContext(error.context);

      if (childErrors && childErrors.length) {
        children = children.concat(childErrors);
      } else if (error.context) {
        children.push(error.context);
      }
    } else {
      children.push(error);
    }
  }

  const result = new BotiumError$6(message, {
    errors: children,
    type,
    source
  }, true);
  return result;
};

var BotiumError_1 = {
  BotiumError: BotiumError$6,
  botiumErrorFromErr: botiumErrorFromErr$2,
  botiumErrorFromList: botiumErrorFromList$2
};

const LOGIC_HOOK_INCLUDE$1 = 'INCLUDE';
var LogicHookConsts = {
  LOGIC_HOOK_INCLUDE: LOGIC_HOOK_INCLUDE$1,
  DEFAULT_ASSERTERS: [{
    name: 'BUTTONS',
    className: 'ButtonsAsserter'
  }, {
    name: 'BUTTONS_COUNT',
    className: 'ButtonsCountAsserter'
  }, {
    name: 'BUTTONS_COUNT_REC',
    className: 'ButtonsCountRecAsserter'
  }, {
    name: 'MEDIA',
    className: 'MediaAsserter'
  }, {
    name: 'MEDIA_COUNT',
    className: 'MediaCountAsserter'
  }, {
    name: 'MEDIA_COUNT_REC',
    className: 'MediaCountRecAsserter'
  }, {
    name: 'CARDS',
    className: 'CardsAsserter'
  }, {
    name: 'CARDS_COUNT',
    className: 'CardsCountAsserter'
  }, {
    name: 'CARDS_COUNT_REC',
    className: 'CardsCountRecAsserter'
  }, {
    name: 'PAUSE_ASSERTER',
    className: 'PauseAsserter'
  }, {
    name: 'JSON_PATH',
    className: 'JsonPathAsserter'
  }, {
    name: 'JSON_PATH_COUNT',
    className: 'JsonPathCountAsserter'
  }, {
    name: 'RESPONSE_LENGTH',
    className: 'ResponseLengthAsserter'
  }, {
    name: 'FORMS',
    className: 'FormsAsserter'
  }, {
    name: 'ENTITIES',
    className: 'EntitiesAsserter'
  }, {
    name: 'ENTITY_VALUES',
    className: 'EntityValuesAsserter'
  }, {
    name: 'ENTITY_CONTENT',
    className: 'EntityContentAsserter'
  }, {
    name: 'INTENT',
    className: 'IntentAsserter'
  }, {
    name: 'INTENT_UNIQUE',
    className: 'IntentUniqueAsserter'
  }, {
    name: 'INTENT_CONFIDENCE',
    className: 'IntentConfidenceAsserter'
  }, {
    name: 'TEXT_CONTAINS_ANY',
    className: 'TextContainsAnyAsserter'
  }, {
    name: 'TEXT_CONTAINS_ANY_IC',
    className: 'TextContainsAnyICAsserter'
  }, {
    name: 'TEXT_CONTAINS_ALL',
    className: 'TextContainsAllAsserter'
  }, {
    name: 'TEXT_CONTAINS_ALL_IC',
    className: 'TextContainsAllICAsserter'
  }, {
    name: 'TEXT_WILDCARD_ANY',
    className: 'TextWildcardAnyAsserter'
  }, {
    name: 'TEXT_WILDCARD_ANY_IC',
    className: 'TextWildcardAnyICAsserter'
  }, {
    name: 'TEXT_WILDCARD_ALL',
    className: 'TextWildcardAllAsserter'
  }, {
    name: 'TEXT_WILDCARD_ALL_IC',
    className: 'TextWildcardAllICAsserter'
  }, {
    name: 'TEXT_WILDCARDEXACT_ANY',
    className: 'TextWildcardExactAnyAsserter'
  }, {
    name: 'TEXT_WILDCARDEXACT_ANY_IC',
    className: 'TextWildcardExactAnyICAsserter'
  }, {
    name: 'TEXT_WILDCARDEXACT_ALL',
    className: 'TextWildcardExactAllAsserter'
  }, {
    name: 'TEXT_WILDCARDEXACT_ALL_IC',
    className: 'TextWildcardExactAllICAsserter'
  }, {
    name: 'TEXT_REGEXP_ANY',
    className: 'TextRegexpAnyAsserter'
  }, {
    name: 'TEXT_REGEXP_ANY_IC',
    className: 'TextRegexpAnyICAsserter'
  }, {
    name: 'TEXT_REGEXP_ALL',
    className: 'TextRegexpAllAsserter'
  }, {
    name: 'TEXT_REGEXP_ALL_IC',
    className: 'TextRegexpAllICAsserter'
  }, {
    name: 'TEXT_EQUALS',
    className: 'TextEqualsAnyAsserter'
  }, {
    name: 'TEXT_EQUALS_IC',
    className: 'TextEqualsAnyICAsserter'
  }, {
    name: 'TEXT',
    className: 'TextEqualsAnyAsserter'
  }, {
    name: 'TEXT_IC',
    className: 'TextEqualsAnyICAsserter'
  }, {
    name: 'BOT_CONSUMED',
    className: 'BotRepliesConsumedAsserter'
  }, {
    name: 'BOT_UNCONSUMED_COUNT',
    className: 'BotRepliesUnconsumedCountAsserter'
  }],
  DEFAULT_LOGIC_HOOKS: [{
    name: 'PAUSE',
    className: 'PauseLogicHook'
  }, {
    name: 'WAITFORBOT',
    className: 'WaitForBotLogicHook'
  }, {
    name: 'SET_SCRIPTING_MEMORY',
    className: 'SetScriptingMemoryLogicHook'
  }, {
    name: 'CLEAR_SCRIPTING_MEMORY',
    className: 'ClearScriptingMemoryLogicHook'
  }, {
    name: 'ASSIGN_SCRIPTING_MEMORY',
    className: 'AssignScriptingMemoryLogicHook'
  }, {
    name: 'UPDATE_CUSTOM',
    className: 'UpdateCustomLogicHook'
  }, {
    name: 'SKIP_BOT_UNCONSUMED',
    className: 'ClearQueueLogicHook'
  }, {
    name: LOGIC_HOOK_INCLUDE$1,
    className: 'IncludeLogicHook'
  }],
  DEFAULT_USER_INPUTS: [{
    name: 'BUTTON',
    className: 'ButtonInput'
  }, {
    name: 'MEDIA',
    className: 'MediaInput'
  }, {
    name: 'FORM',
    className: 'FormInput'
  }]
};
LogicHookConsts.LOGIC_HOOK_INCLUDE;
LogicHookConsts.DEFAULT_ASSERTERS;
LogicHookConsts.DEFAULT_LOGIC_HOOKS;
LogicHookConsts.DEFAULT_USER_INPUTS;

const {
  NodeVM: NodeVM$2
} = vm2;
const debug$k = debug$l('botium-core-asserterUtils');
const {
  BotiumError: BotiumError$5
} = BotiumError_1;
const {
  DEFAULT_ASSERTERS,
  DEFAULT_LOGIC_HOOKS,
  DEFAULT_USER_INPUTS
} = LogicHookConsts;
DEFAULT_ASSERTERS.forEach(asserter => {
  asserter.Class = commonjsRequire(`./asserter/${asserter.className}`);
});
DEFAULT_LOGIC_HOOKS.forEach(logicHook => {
  logicHook.Class = commonjsRequire(`./logichooks/${logicHook.className}`);
});
DEFAULT_USER_INPUTS.forEach(userInput => {
  userInput.Class = commonjsRequire(`./userinput/${userInput.className}`);
});
var LogicHookUtils_1 = class LogicHookUtils {
  constructor({
    buildScriptContext,
    caps
  }) {
    this.asserters = {};
    this.globalAsserters = [];
    this.logicHooks = {};
    this.globalLogicHooks = [];
    this.userInputs = {};
    this.buildScriptContext = buildScriptContext;
    this.caps = caps;

    this._setDefaultAsserters();

    this._setDefaultLogicHooks();

    this._setDefaultUserInputs();

    this._fetchAsserters();

    this._fetchLogicHooks();

    this._fetchUserInputs();
  }

  _setDefaultAsserters() {
    DEFAULT_ASSERTERS.forEach(asserter => {
      this.asserters[asserter.name] = new asserter.Class(this.buildScriptContext, this.caps);
    });
  }

  _setDefaultLogicHooks() {
    DEFAULT_LOGIC_HOOKS.forEach(lh => {
      this.logicHooks[lh.name] = new lh.Class(this.buildScriptContext, this.caps);
    });
  }

  _setDefaultUserInputs() {
    DEFAULT_USER_INPUTS.forEach(ui => {
      this.userInputs[ui.name] = new ui.Class(this.buildScriptContext, this.caps);
    });
  }

  _fetchAsserters() {
    this.caps[Capabilities.ASSERTERS].forEach(asserter => {
      if (this.asserters[asserter.ref]) {
        debug$k(`${asserter.ref} asserter already exists, overwriting.`);
      }

      this.asserters[asserter.ref] = this._loadClass(asserter, 'asserter');

      if (asserter.global) {
        this.globalAsserters.push(asserter.ref);
      }
    });
  }

  _fetchLogicHooks() {
    this.caps[Capabilities.LOGIC_HOOKS].forEach(logicHook => {
      if (this.logicHooks[logicHook.ref]) {
        debug$k(`${logicHook.ref} logic hook already exists, overwriting.`);
      }

      this.logicHooks[logicHook.ref] = this._loadClass(logicHook, 'logichook');

      if (logicHook.global) {
        this.globalLogicHooks.push(logicHook.ref);
      }
    });
  }

  _fetchUserInputs() {
    this.caps[Capabilities.USER_INPUTS].forEach(userInput => {
      if (this.userInputs[userInput.ref]) {
        debug$k(`${userInput.ref} userinput already exists, overwriting.`);
      }

      this.userInputs[userInput.ref] = this._loadClass(userInput, 'userinput');
    });
  }

  getGlobalAsserter() {
    return this.globalAsserters.map(name => this.asserters[name]);
  }

  getGlobalLogicHook() {
    return this.globalLogicHooks.map(name => this.logicHooks[name]);
  }

  _loadClass({
    src,
    ref,
    args
  }, hookType) {
    if (hookType !== 'asserter' && hookType !== 'logichook' && hookType !== 'userinput') {
      throw Error(`Unknown hookType ${hookType}`);
    } // 1 gives possibility to use default asserter as global asserter


    if (hookType === 'asserter') {
      const asserter = DEFAULT_ASSERTERS.find(asserter => src === asserter.className);

      if (asserter) {
        return new asserter.Class({
          ref,
          ...this.buildScriptContext
        }, this.caps, args);
      }
    }

    if (hookType === 'logichook') {
      const lh = DEFAULT_LOGIC_HOOKS.find(lh => src === lh.className);

      if (lh) {
        return new lh.Class({
          ref,
          ...this.buildScriptContext
        }, this.caps, args);
      }
    }

    if (hookType === 'userinput') {
      const ui = DEFAULT_USER_INPUTS.find(ui => src === ui.className);

      if (ui) {
        return new ui.Class({
          ref,
          ...this.buildScriptContext
        }, this.caps, args);
      }
    }

    const _checkUnsafe = () => {
      if (!this.caps[Capabilities.SECURITY_ALLOW_UNSAFE]) {
        throw new BotiumError$5('Security Error. Using unsafe component is not allowed', {
          type: 'security',
          subtype: 'allow unsafe',
          source: path.basename(__filename),
          cause: {
            src: !!src,
            ref,
            args,
            hookType
          }
        });
      }
    };

    if (!src) {
      const packageName = `botium-${hookType}-${ref}`;

      try {
        const CheckClass = commonjsRequire(packageName);

        if (isClass(CheckClass)) {
          return new CheckClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else if (lodash.isFunction(CheckClass)) {
          return CheckClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else if (isClass(CheckClass.PluginClass)) {
          return new CheckClass.PluginClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else {
          throw new Error(`${packageName} class or function or PluginClass field expected`);
        }
      } catch (err) {
        throw new Error(`Failed to fetch hook ${ref} ${hookType} from guessed package ${packageName} - ${err.message}`);
      }
    }

    if (isClass(src)) {
      try {
        const CheckClass = src;
        return new CheckClass({
          ref,
          ...this.buildScriptContext
        }, this.caps, args);
      } catch (err) {
        throw new Error(`Failed to load package ${ref} from provided class - ${err.message}`);
      }
    }

    if (lodash.isFunction(src)) {
      try {
        return src({
          ref,
          ...this.buildScriptContext
        }, this.caps, args);
      } catch (err) {
        throw new Error(`Failed to load package ${ref} from provided function - ${err.message}`);
      }
    }

    if (lodash.isObject(src) && !lodash.isString(src)) {
      try {
        const hookObject = Object.keys(src).reduce((result, key) => {
          result[key] = args => {
            const script = src[key];

            if (lodash.isFunction(script)) {
              return script(args);
            } else if (lodash.isString(script)) {
              try {
                const vm = new NodeVM$2({
                  eval: false,
                  require: false,
                  sandbox: args
                });
                return vm.run(script);
              } catch (err) {
                throw new Error(`${err.message || err}`);
              }
            } else {
              throw new Error(`Script "${key}" is not valid - only functions and javascript code accepted`);
            }
          };

          return result;
        }, {});
        return hookObject;
      } catch (err) {
        throw new Error(`Failed to load package ${ref} ${hookType} from provided src function - ${err.message}`);
      }
    }

    if (lodash.isString(src)) {
      const loadErr = [];
      const tryLoads = [{
        tryLoadPackageName: src,
        tryLoadAsserterByName: null
      }];

      if (src.indexOf('/') >= 0) {
        tryLoads.push({
          tryLoadPackageName: src.substr(0, src.lastIndexOf('/')),
          tryLoadAsserterByName: src.substr(src.lastIndexOf('/') + 1)
        });
      }

      const tryLoadFromSource = (tryRequire, tryAsserterName) => {
        let CheckClass = commonjsRequire();

        if (CheckClass.default) {
          CheckClass = CheckClass.default;
        }

        if (tryAsserterName) {
          if (hookType === 'asserter' && CheckClass.PluginAsserters && CheckClass.PluginAsserters[tryAsserterName]) {
            CheckClass = CheckClass.PluginAsserters[tryAsserterName];
          } else if (hookType === 'logichook' && CheckClass.PluginLogicHooks && CheckClass.PluginLogicHooks[tryAsserterName]) {
            CheckClass = CheckClass.PluginLogicHooks[tryAsserterName];
          } else {
            throw new Error(`Loaded ${tryRequire}, but ${tryAsserterName} ${hookType} not found.`);
          }
        }

        if (isClass(CheckClass)) {
          return new CheckClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else if (lodash.isFunction(CheckClass)) {
          return CheckClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else if (isClass(CheckClass.PluginClass)) {
          return new CheckClass.PluginClass({
            ref,
            ...this.buildScriptContext
          }, this.caps, args);
        } else {
          throw new Error(`${src} class or function expected`);
        }
      };

      for (const tryLoad of tryLoads) {
        const tryLoadFile = path.resolve(process.cwd(), tryLoad.tryLoadPackageName);

        if (fs.existsSync(tryLoadFile)) {
          _checkUnsafe();

          try {
            return tryLoadFromSource(tryLoadFile, tryLoad.tryLoadAsserterByName);
          } catch (err) {
            loadErr.push(`Failed to fetch ${ref} ${hookType} from ${src} - ${err.message} `);
          }
        }

        try {
          return tryLoadFromSource(tryLoad.tryLoadPackageName, tryLoad.tryLoadAsserterByName);
        } catch (err) {
          loadErr.push(`Failed to fetch ${ref} ${hookType} from ${src} - ${err.message} `);
        }
      }

      loadErr.forEach(debug$k);
    }

    throw new Error(`Failed to fetch ${ref} ${hookType}, no idea how to load ...`);
  }

};

var Constants = {
  SCRIPTING_FORMAT_XSLX: 'SCRIPTING_FORMAT_XSLX',
  SCRIPTING_FORMAT_TXT: 'SCRIPTING_FORMAT_TXT',
  SCRIPTING_FORMAT_YAML: 'SCRIPTING_FORMAT_YAML',
  SCRIPTING_FORMAT_JSON: 'SCRIPTING_FORMAT_JSON',
  SCRIPTING_FORMAT_CSV: 'SCRIPTING_FORMAT_CSV',
  SCRIPTING_FORMAT_MARKDOWN: 'SCRIPTING_FORMAT_MARKDOWN',
  SCRIPTING_TYPE_CONVO: 'SCRIPTING_TYPE_CONVO',
  SCRIPTING_TYPE_PCONVO: 'SCRIPTING_TYPE_PCONVO',
  SCRIPTING_TYPE_UTTERANCES: 'SCRIPTING_TYPE_UTTERANCES',
  SCRIPTING_TYPE_SCRIPTING_MEMORY: 'SCRIPTING_TYPE_SCRIPTING_MEMORY'
};
Constants.SCRIPTING_FORMAT_XSLX;
Constants.SCRIPTING_FORMAT_TXT;
Constants.SCRIPTING_FORMAT_YAML;
Constants.SCRIPTING_FORMAT_JSON;
Constants.SCRIPTING_FORMAT_CSV;
Constants.SCRIPTING_FORMAT_MARKDOWN;
Constants.SCRIPTING_TYPE_CONVO;
Constants.SCRIPTING_TYPE_PCONVO;
Constants.SCRIPTING_TYPE_UTTERANCES;
Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY;

var BotiumMockAttachment_1 = class BotiumMockAttachment {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.mimeType = fromJson.mimeType;
    this.base64 = fromJson.base64;
    this.href = fromJson.href;
  }

};

class BotiumMockMedia$1 {
  constructor(fromJson = {}) {
    this.mediaUri = fromJson.mediaUri;
    this.mimeType = fromJson.mimeType;
    this.altText = fromJson.altText;
    this.downloadUri = fromJson.downloadUri;
    this.buffer = fromJson.buffer;
  }

  prettify(indent = 0) {
    const sections = [];
    if (this.mediaUri) sections.push(lodash.truncate(this.mediaUri, {
      length: 200
    }));
    if (this.mimeType) sections.push(this.mimeType);
    if (this.altText) sections.push(this.altText);
    return `${' '.repeat(indent)}MEDIA(${sections.join(' | ')})`;
  }

}

class BotiumMockButton$1 {
  constructor(fromJson = {}) {
    this.text = fromJson.text;
    this.payload = fromJson.payload;
    this.imageUri = fromJson.imageUri;
  }

  prettify(indent = 0) {
    const sections = [];
    if (this.text) sections.push(this.text);
    if (this.payload) sections.push(lodash.isObject(this.payload) ? JSON.stringify(this.payload) : this.payload);
    if (this.imageUri) sections.push(lodash.truncate(this.imageUri, {
      length: 200
    }));
    return `${' '.repeat(indent)}BUTTON(${sections.join(' | ')})`;
  }

}

class BotiumMockCard$1 {
  constructor(fromJson = {}) {
    this.text = fromJson.text;
    this.subtext = fromJson.subtext;
    this.content = fromJson.content;
    this.sourceData = fromJson.sourceData;
    this.image = fromJson.image ? new BotiumMockMedia$1(fromJson.image) : null;
    this.buttons = fromJson.buttons ? fromJson.buttons.map(a => new BotiumMockButton$1(a)) : null;
    this.media = fromJson.media ? fromJson.media.map(a => new BotiumMockMedia$1(a)) : null;
    this.forms = fromJson.forms ? fromJson.forms.map(a => new BotiumMockForm$1(a)) : null;
    this.cards = fromJson.cards ? fromJson.cards.map(a => new BotiumMockCard$1(a)) : null;
    this.sourceData = fromJson.sourceData;
  }

  prettify(indent = 0) {
    return this._prettifyLines(this, indent).join('\n');
  }

  _prettifyLines(card, indent) {
    const prettifySafe = (entry, indent) => entry.prettify ? entry.prettify(2) : `${' '.repeat(indent)}<No botium object!>${JSON.stringify(entry)}`;

    const sections = [];
    if (card.text) sections.push(card.text);
    if (card.subtext) sections.push(card.subtext);
    const lines = [];
    if (card.image) lines.push(card.image.prettify(indent + 2));
    if (card.media) lines.push(...card.media.map(m => prettifySafe(m, indent + 2)));
    if (card.buttons) lines.push(...card.buttons.map(b => prettifySafe(b, indent + 2)));
    if (card.forms) lines.push(...card.forms.map(f => prettifySafe(f, indent + 2)));
    if (card.cards) lines.push(...card.cards.map(c => this._prettifyLines(c, indent + 2)));
    return [`${' '.repeat(indent)}CARD(${sections.join(' | ')})`, ...lines];
  }

}

class BotiumMockForm$1 {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.value = fromJson.value;
    this.label = fromJson.label;
    this.type = fromJson.type;
    this.options = fromJson.options ? fromJson.options.map(c => new BotiumMockChoice(c)) : null;
  }

  prettify(indent = 0) {
    const sections = [];
    if (this.name) sections.push(this.name);
    if (this.label) sections.push(this.label);
    if (this.value) sections.push(this.value);
    return `${' '.repeat(indent)}FORM(${sections.join(' | ')})`;
  }

}

class BotiumMockChoice {
  constructor(fromJson = {}) {
    this.title = fromJson.title;
    this.value = fromJson.value;
  }

}

var BotiumMockRichMessageTypes = {
  BotiumMockMedia: BotiumMockMedia$1,
  BotiumMockButton: BotiumMockButton$1,
  BotiumMockCard: BotiumMockCard$1,
  BotiumMockForm: BotiumMockForm$1
};
BotiumMockRichMessageTypes.BotiumMockMedia;
BotiumMockRichMessageTypes.BotiumMockButton;
BotiumMockRichMessageTypes.BotiumMockCard;
BotiumMockRichMessageTypes.BotiumMockForm;

class BotiumMockAsserter$1 {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = lodash.cloneDeep(fromJson.args);
  }

}

class BotiumMockUserInput$1 {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = lodash.cloneDeep(fromJson.args);
  }

}

class BotiumMockLogicHook$1 {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = lodash.cloneDeep(fromJson.args);
  }

}

var BotiumMockScripting = {
  BotiumMockAsserter: BotiumMockAsserter$1,
  BotiumMockUserInput: BotiumMockUserInput$1,
  BotiumMockLogicHook: BotiumMockLogicHook$1
};

const {
  BotiumMockMedia,
  BotiumMockButton,
  BotiumMockCard,
  BotiumMockForm
} = BotiumMockRichMessageTypes;
const {
  BotiumMockAsserter,
  BotiumMockUserInput,
  BotiumMockLogicHook
} = BotiumMockScripting;
var BotiumMockMessage_1 = class BotiumMockMessage {
  constructor(fromJson = {}) {
    this.sender = fromJson.sender;
    this.channel = fromJson.channel;
    this.not = fromJson.not;
    this.optional = fromJson.optional;
    this.messageText = fromJson.messageText;
    this.media = fromJson.media ? fromJson.media.map(a => new BotiumMockMedia(a)) : null;
    this.buttons = fromJson.buttons ? fromJson.buttons.map(a => new BotiumMockButton(a)) : null;
    this.cards = fromJson.cards ? fromJson.cards.map(a => new BotiumMockCard(a)) : null;
    this.forms = fromJson.forms ? fromJson.forms.map(a => new BotiumMockForm(a)) : null;
    this.nlp = fromJson.nlp;
    this.sourceData = fromJson.sourceData;
    this.sourceAction = fromJson.sourceAction;
    this.attachments = fromJson.attachments ? fromJson.attachments.map(a => new BotiumMockAttachment_1(a)) : null;
    this.asserters = fromJson.asserters ? fromJson.asserters.map(a => new BotiumMockAsserter(a)) : null;
    this.userInputs = fromJson.userInputs ? fromJson.userInputs.map(a => new BotiumMockUserInput(a)) : null;
    this.logicHooks = fromJson.logicHooks ? fromJson.logicHooks.map(a => new BotiumMockLogicHook(a)) : null;
  }

  prettify() {
    const prettifySafe = entry => entry.prettify ? entry.prettify(2) : `${' '.repeat(2)}<No botium object!>${JSON.stringify(entry)}`;

    const lines = [];
    if (this.messageText) lines.push(this.messageText);
    if (this.media && this.media.length > 0) lines.push(...this.media.map(m => prettifySafe(m)));
    if (this.buttons && this.buttons.length > 0) lines.push(...this.buttons.map(b => prettifySafe(b)));
    if (this.cards && this.cards.length > 0) lines.push(...this.cards.map(c => prettifySafe(c)));
    if (this.forms && this.forms.length > 0) lines.push(...this.forms.map(f => prettifySafe(f)));
    if (lines.length === 0) return `#${this.sender}:`;
    return [`#${this.sender}: ${lines[0]}`, ...lines.slice(1)].join('\n');
  }

};

const normalizeText$1 = (str, doCleanup) => {
  if (str && lodash.isArray(str)) {
    str = str.join(' ');
  } else if (str && !lodash.isString(str)) {
    if (str.toString) {
      str = str.toString();
    } else {
      str = `${str}`;
    }
  }

  if (str && doCleanup) {
    // remove html tags
    str = str.replace(/<p[^>]*>/g, ' ');
    str = str.replace(/<\/p>/g, ' ');
    str = str.replace(/<br[^>]*>/g, ' ');
    str = str.replace(/<[^>]*>/g, '');
    /* eslint-disable no-control-regex */
    // remove not printable characters

    str = str.replace(/[\x00-\x1F\x7F]/g, ' ');
    /* eslint-enable no-control-regex */
    // replace html entities

    str = str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#39;/g, '\'').replace(/&quot;/g, '"'); // replace two spaces with one

    str = str.replace(/\s+/g, ' ');
    str = str.split('\n').map(s => s.trim()).join('\n').trim();
  }

  return str;
};

const splitStringInNonEmptyLines$1 = str => str ? str.split('\n').map(s => s.trim()).filter(s => s.length > 0) : [];

const quoteRegexpString$2 = str => {
  return str.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
};

const removeBuffers$1 = obj => {
  const jsonString = JSON.stringify(obj, (key, value) => {
    if (lodash.isBuffer(value)) {
      return '(binary data)';
    } else if (value && value.type && value.type === 'Buffer') {
      return '(binary data)';
    } else if (key.toLowerCase() === 'base64') {
      return '(base64 data)';
    } else if (lodash.isString(value) && value.startsWith('data:')) {
      return '(base64 data url)';
    }

    return value;
  });
  return JSON.parse(jsonString);
};

const toString$3 = value => {
  if (lodash.isUndefined(value)) return undefined;
  if (lodash.isString(value)) return value;
  if (lodash.isNumber(value)) return value.toString();
  if (lodash.isArray(value)) return value.map(v => toString$3(v)).join(',');

  try {
    return JSON.stringify(value);
  } catch (err) {}

  if (value && value.toString) return value.toString();
  return '' + value;
};

const flatString = str => {
  return str ? str.split('\n').map(s => s.trim()).join(' ') : '';
};

const linesToConvoStep$5 = (lines, sender, context, eol, singleLineMode = false) => {
  if (!validateSender$1(sender)) throw new Error(`Failed to parse conversation. Section "${sender}" unknown.`);
  const convoStep = {
    asserters: [],
    logicHooks: [],
    userInputs: [],
    not: false,
    optional: false,
    sender
  };
  let textLinesRaw = [];
  const textLines = []; // local eslint accepts it without disable, but build on github does not
  // eslint-disable-next-line no-unused-vars

  let textLinesAccepted = true;

  for (const rawLine of lines) {
    if (lodash.isString(rawLine)) {
      let optional = false;
      let not = false;
      let logicLine = rawLine;

      if (logicLine.startsWith('?')) {
        if (!logicLine.startsWith('??')) {
          optional = true;
        }

        logicLine = logicLine.substr(1);
      }

      if (logicLine.startsWith('!')) {
        if (!logicLine.startsWith('!!')) {
          not = true;
        }

        logicLine = logicLine.substr(1);
      }

      const name = logicLine.split(' ')[0];

      if (sender !== 'me' && context.IsAsserterValid(name)) {
        const args = logicLine.length > name.length ? logicLine.substr(name.length + 1).split('|').map(a => a.trim()) : [];
        convoStep.asserters.push({
          name,
          args,
          not,
          optional
        });
      } else if (sender === 'me' && context.IsUserInputValid(name)) {
        const args = logicLine.length > name.length ? logicLine.substr(name.length + 1).split('|').map(a => a.trim()) : [];
        convoStep.userInputs.push({
          name,
          args
        });
        textLinesAccepted = false;
      } else if (context.IsLogicHookValid(name)) {
        const args = logicLine.length > name.length ? logicLine.substr(name.length + 1).split('|').map(a => a.trim()) : [];
        convoStep.logicHooks.push({
          name,
          args
        });
        textLinesAccepted = false;
      } else {
        if (sender === 'me') {
          if (!textLinesAccepted) {
            if (rawLine.trim().length) {
              throw new Error(`Failed to parse conversation. No text expected here: '${rawLine.trim()}' in convo:\n ${lines.join('\n')}`);
            }
          } else {
            textLinesRaw.push(rawLine);
          }
        } else {
          textLinesRaw.push(rawLine);
        }
      } // line is not textline if it is empty, and there is no line with data after it.


      if (textLinesRaw.length > 0) {
        if (rawLine.trim().length) {
          textLines.push(...textLinesRaw);
          textLinesRaw = [];
        }
      }
    } else if (lodash.isObject(rawLine)) {
      if (rawLine.asserter) {
        if (sender !== 'bot') throw new Error(`Failed to parse conversation. No asserter "${rawLine.asserter}" expected in section "${sender}"`);
        if (!context.IsAsserterValid(rawLine.asserter)) throw new Error(`Failed to parse conversation. No asserter "${rawLine.asserter}" registered for section "${sender}"`);
        convoStep.asserters.push({
          name: rawLine.asserter,
          args: (rawLine.args && lodash.isString(rawLine.args) ? [rawLine.args] : rawLine.args) || [],
          not: !!rawLine.not,
          optional: !!rawLine.optional
        });
      } else if (rawLine.logichook || rawLine.logicHook) {
        const logicHookName = rawLine.logichook || rawLine.logicHook;
        if (!context.IsLogicHookValid(logicHookName)) throw new Error(`Failed to parse conversation. No logichook "${logicHookName}" registered for section "${sender}"`);
        convoStep.logicHooks.push({
          name: logicHookName,
          args: (rawLine.args && lodash.isString(rawLine.args) ? [rawLine.args] : rawLine.args) || []
        });
      } else if (rawLine.userinput || rawLine.userInput) {
        const userInputName = rawLine.userinput || rawLine.userInput;
        if (sender !== 'me') throw new Error(`Failed to parse conversation. No userinput "${userInputName}" expected in section "${sender}"`);
        if (!context.IsUserInputValid(userInputName)) throw new Error(`Failed to parse conversation. No userinput "${userInputName}" registered for section "${sender}"`);
        convoStep.userInputs.push({
          name: userInputName,
          args: (rawLine.args && lodash.isString(rawLine.args) ? [rawLine.args] : rawLine.args) || []
        });
      } else {
        let name = Object.keys(rawLine)[0];
        const content = rawLine[name];
        let optional = false;
        let not = false;

        if (name.startsWith('?')) {
          optional = true;
          name = name.substr(1);
        } else if (name.startsWith('OPTIONAL_')) {
          optional = true;
          name = name.substr(9);
        }

        if (name.startsWith('!')) {
          not = true;
          name = name.substr(1);
        } else if (name.startsWith('NOT_')) {
          not = true;
          name = name.substr(4);
        }

        if (sender !== 'me' && context.IsAsserterValid(name)) {
          convoStep.asserters.push({
            name,
            args: (content && lodash.isString(content) ? [content] : content) || [],
            not,
            optional
          });
        } else if (sender === 'me' && context.IsUserInputValid(name)) {
          convoStep.userInputs.push({
            name,
            args: (content && lodash.isString(content) ? [content] : content) || []
          });
        } else if (context.IsLogicHookValid(name)) {
          convoStep.logicHooks.push({
            name,
            args: (content && lodash.isString(content) ? [content] : content) || []
          });
        } else {
          throw new Error(`Failed to parse conversation. Line not recognized '${JSON.stringify(rawLine)}'`);
        }
      }
    } else {
      throw new Error(`Failed to parse conversation. Line not recognized '${JSON.stringify(rawLine)}'`);
    }
  } // deal with just message convosteps


  if (textLinesRaw.length >= 1 && textLines.length === 0) {
    textLines.push(...textLinesRaw);
    textLinesRaw.pop();
  }

  if (textLines.length > 0) {
    if (textLines[0].startsWith('?')) {
      if (!textLines[0].startsWith('??')) {
        convoStep.optional = true;
      }

      textLines[0] = textLines[0].substr(1);
    }

    if (textLines[0].startsWith('!')) {
      if (!textLines[0].startsWith('!!')) {
        convoStep.not = true;
      }

      textLines[0] = textLines[0].substr(1);
    }

    const content = textLines.join(' ');

    if (isJson$1(content)) {
      convoStep.sourceData = JSON.parse(content);
    } else {
      /// csv has always just 1 line, and has no eol setting
      if (singleLineMode) {
        convoStep.messageText = textLines[0];
      } else {
        if (eol === null) {
          throw new Error('eol cant be null');
        }

        convoStep.messageText = textLines.join(eol).trim();
      }
    }
  } else {
    // no message is different from empty message
    convoStep.messageText = null;
  } // Check if all element in convo step is optional or not optional


  const optionalSet = new Set();

  if (convoStep.messageText) {
    optionalSet.add(convoStep.optional);
  }

  for (const asserter of convoStep.asserters) {
    optionalSet.add(asserter.optional);
  }

  if (optionalSet.size > 1) {
    throw new Error(`Failed to parse conversation. All element in convo step has to be optional or not optional: ${JSON.stringify(lines)}`);
  }

  return convoStep;
};

const convoStepToObject$1 = step => {
  const result = [];

  if (step.sender === 'me') {
    for (const form of (step.forms || []).filter(form => form.value)) {
      result.push({
        userinput: 'FORM',
        args: [form.name, form.value]
      });
    }

    if (step.buttons && step.buttons.length > 0) {
      const userinput = {
        userinput: 'BUTTON',
        args: []
      };

      if (step.buttons[0].payload) {
        userinput.args.push(step.buttons[0].payload);

        if (step.buttons[0].text) {
          userinput.args.push(step.buttons[0].text);
        }
      } else {
        userinput.args.push(step.buttons[0].text);
      }

      result.push(userinput);
    } else if (step.media && step.media.length > 0) {
      result.push({
        userinput: 'MEDIA',
        args: [step.media[0].mediaUri]
      });
    } else if (step.messageText) {
      result.push(step.messageText);
    }

    for (const logicHook of step.logicHooks || []) {
      result.push({
        logichook: logicHook.name,
        args: logicHook.args || []
      });
    }
  } else {
    if (step.messageText) {
      let messageTextPrefix = '';
      if (step.optional) messageTextPrefix += '?';
      if (step.not) messageTextPrefix += '!';
      result.push(messageTextPrefix + step.messageText);
    }

    if (step.buttons && step.buttons.length > 0) {
      result.push({
        asserter: 'BUTTONS',
        args: step.buttons.map(b => flatString(b.text))
      });
    }

    if (step.media && step.media.length > 0) {
      result.push({
        asserter: 'MEDIA',
        args: step.media.map(m => {
          return m.buffer && m.buffer.startsWith('data:') ? 'data:' : m.mediaUri;
        })
      });
    }

    if (step.cards && step.cards.length > 0) {
      step.cards.forEach(c => {
        let cardTexts = [];
        if (c.text) cardTexts = cardTexts.concat(lodash.isArray(c.text) ? c.text : [c.text]);
        if (c.subtext) cardTexts = cardTexts.concat(lodash.isArray(c.subtext) ? c.subtext : [c.subtext]);
        if (c.content) cardTexts = cardTexts.concat(lodash.isArray(c.content) ? c.content : [c.content]);

        if (cardTexts.length > 0) {
          result.push({
            asserter: 'CARDS',
            args: cardTexts.map(c => flatString(c))
          });
        }

        if (c.buttons && c.buttons.length > 0) {
          result.push({
            asserter: 'BUTTONS',
            args: c.buttons.map(b => b.text)
          });
        }

        if (c.image) {
          result.push({
            asserter: 'MEDIA',
            args: c.image.mediaUr,
            not: !!step.not
          });
        }
      });
    }

    for (const asserter of step.asserters || []) {
      result.push({
        asserter: asserter.name,
        args: asserter.args || [],
        optional: !!asserter.optional,
        not: !!asserter.not
      });
    }

    for (const logicHook of step.logicHooks || []) {
      result.push({
        logichook: logicHook.name,
        args: logicHook.args || []
      });
    }
  }

  return result;
};

const validSenders$3 = ['begin', 'include', 'me', 'bot', 'end'];

const validateSender$1 = sender => {
  if (validSenders$3.indexOf(sender) >= 0) return true;else return false;
};

const validateConvo$2 = convo => {
  const validationResult = {
    errors: []
  };

  for (let i = 0; i < convo.conversation.length; i++) {
    const step = convo.conversation[i];

    if (step.sender === 'bot') {
      // Check if all element in convo step is optional or not optional
      const optionalSet = new Set();

      if (step.messageText) {
        optionalSet.add(step.optional);
      }

      if (step.asserters) {
        for (const asserter of step.asserters) {
          optionalSet.add(asserter.optional);
        }
      }

      if (optionalSet.size > 1) {
        validationResult.errors.push(new Error(`Step ${i + 1}: Failed to decompile conversation. Mixed optional flag is not allowed inside one step.`));
      }

      if (optionalSet.size === 1 && optionalSet.has(true)) {
        const nextStep = convo.conversation[i + 1];

        if (!nextStep || nextStep.sender !== 'bot') {
          validationResult.errors.push(new Error(`Step ${i + 1}: Optional bot convo step has to be followed by a bot convo step.`));
        }
      }
    }

    if (!validateSender$1(step.sender)) {
      validationResult.errors.push(new Error(`Step ${i + 1}: Sender #${step.sender} is invalid.`));
    }
  }

  return validationResult;
};

const _decompileButton = b => {
  let buttonScript = '';

  if (b.payload) {
    buttonScript += lodash.isObject(b.payload) ? JSON.stringify(b.payload) : flatString(b.payload);

    if (b.text) {
      buttonScript += `|${flatString(b.text)}`;
    }
  } else {
    buttonScript += flatString(b.text);
  }

  return buttonScript;
};

const convoStepToLines$2 = step => {
  const lines = [];

  if (step.sender === 'me') {
    step.forms && step.forms.filter(form => form.value).forEach(form => {
      lines.push(`FORM ${form.name}|${form.value}`);
    });

    if (step.buttons && step.buttons.length > 0) {
      lines.push('BUTTON ' + _decompileButton(step.buttons[0]));
    } else if (step.media && step.media.length > 0) {
      lines.push('MEDIA ' + step.media[0].mediaUri);
    } else if (step.messageText) {
      lines.push(step.messageText);
    }

    step.userInputs && step.userInputs.forEach(userInput => {
      lines.push(userInput.name + (userInput.args ? ' ' + userInput.args.join('|') : ''));
    });
    step.logicHooks && step.logicHooks.forEach(logicHook => {
      lines.push(logicHook.name + (logicHook.args ? ' ' + logicHook.args.join('|') : ''));
    });
  } else {
    if (step.messageText) {
      lines.push((step.optional ? '?' : '') + (step.not ? '!' : '') + step.messageText);
    }

    if (step.buttons && step.buttons.length > 0) lines.push('BUTTONS ' + step.buttons.filter(b => b.text).map(b => flatString(b.text)).join('|'));
    if (step.media && step.media.length > 0) lines.push('MEDIA ' + step.media.filter(m => !m.buffer && m.mediaUri).map(m => m.mediaUri).join('|'));

    if (step.cards && step.cards.length > 0) {
      step.cards.forEach(c => {
        let cardTexts = [];
        if (c.text) cardTexts = cardTexts.concat(lodash.isArray(c.text) ? c.text : [c.text]);
        if (c.subtext) cardTexts = cardTexts.concat(lodash.isArray(c.subtext) ? c.subtext : [c.subtext]);
        if (c.content) cardTexts = cardTexts.concat(lodash.isArray(c.content) ? c.content : [c.content]);
        if (cardTexts.length > 0) lines.push('CARDS ' + cardTexts.map(c => flatString(c)).join('|'));
        if (c.buttons && c.buttons.length > 0) lines.push('BUTTONS ' + c.buttons.filter(b => b.text).map(b => flatString(b.text)).join('|'));
        if (c.image && !c.image.buffer && c.image.mediaUri) lines.push('MEDIA ' + c.image.mediaUri);
      });
    }

    step.asserters && step.asserters.forEach(asserter => {
      lines.push((asserter.optional ? '?' : '') + (asserter.not ? '!' : '') + asserter.name + (asserter.args ? ' ' + asserter.args.join('|') : ''));
    });
    step.logicHooks && step.logicHooks.forEach(logicHook => {
      lines.push(logicHook.name + (logicHook.args ? ' ' + logicHook.args.join('|') : ''));
    });
  }

  return lines.map(l => l.trim());
};

var helper = {
  normalizeText: normalizeText$1,
  splitStringInNonEmptyLines: splitStringInNonEmptyLines$1,
  quoteRegexpString: quoteRegexpString$2,
  toString: toString$3,
  flatString,
  removeBuffers: removeBuffers$1,
  linesToConvoStep: linesToConvoStep$5,
  convoStepToLines: convoStepToLines$2,
  convoStepToObject: convoStepToObject$1,
  validSenders: validSenders$3,
  validateSender: validateSender$1,
  validateConvo: validateConvo$2
};

const debug$j = debug$l('botium-core-ScriptingMemory');
const {
  v1: uuidv1
} = uuid;
const {
  NodeVM: NodeVM$1
} = vm2;
const {
  quoteRegexpString: quoteRegexpString$1,
  toString: toString$2
} = helper;
const {
  BotiumError: BotiumError$4
} = BotiumError_1; // If they got parameter, then it will be a string always.
// the receiver can decide what to do with it,
// convert to int,
// split by ',' for multiple params,
// or something else

const SCRIPTING_FUNCTIONS_RAW = {
  $now: () => {
    return new Date().toLocaleString();
  },
  $now_EN: () => {
    return new Date().toLocaleString('en-EN');
  },
  $now_DE: () => {
    return moment().format('DD.MM.YYYY, HH:mm:ss');
  },
  $now_ISO: () => {
    return new Date().toISOString();
  },
  $date: pattern => {
    if (pattern) {
      return moment().format(pattern);
    }

    return new Date().toLocaleDateString();
  },
  $date_EN: () => {
    return new Date().toLocaleDateString('en-EN');
  },
  $date_DE: () => {
    return moment().format('YYYY.MM.DD');
  },
  $date_ISO: () => {
    return moment().format('YYYY-MM-DD');
  },
  $time: () => {
    return new Date().toLocaleTimeString();
  },
  $time_EN: () => {
    return new Date().toLocaleTimeString('en-EN');
  },
  $time_DE: () => {
    return moment().format('HH:mm:ss');
  },
  $time_ISO: () => {
    return moment().format('HH:mm:ss');
  },
  $time_HH_MM: () => {
    return moment().format('HH:mm');
  },
  $time_HH: () => {
    return moment().format('HH');
  },
  $time_H_A: () => {
    return moment().format('h A');
  },
  $timestamp: () => {
    return Date.now();
  },
  $year: () => {
    return new Date().getFullYear();
  },
  $month: () => {
    return moment().format('MMMM');
  },
  $month_MM: () => {
    return moment().format('MM');
  },
  $day_of_month: () => {
    return new Date().getDate();
  },
  $day_of_week: () => {
    return moment().format('dddd');
  },
  $random: length => {
    if (length == null) {
      throw Error('random function used without args!');
    }

    return randomatic('0', length);
  },
  $random10: () => {
    return randomatic('0', 10);
  },
  $uniqid: () => {
    return uuidv1();
  },
  $projectname: {
    handler: caps => {
      return caps[Capabilities.PROJECTNAME];
    }
  },
  $testsessionname: {
    handler: caps => {
      return caps[Capabilities.TESTSESSIONNAME];
    }
  },
  $testcasename: {
    handler: caps => {
      return caps[Capabilities.TESTCASENAME];
    }
  },
  $env: {
    handler: (caps, name) => {
      if (!name) {
        throw Error('env function used without args!');
      }

      return process.env[name];
    },
    numberOfArguments: 1,
    unsafe: true
  },
  $cap: {
    handler: (caps, name) => {
      if (!name) {
        throw Error('cap function used without args!');
      }

      return caps[name];
    },
    numberOfArguments: 1
  },
  $msg: {
    handler: (caps, jsonPath, mockMsg) => {
      if (!jsonPath) {
        throw Error('msg function used without jsonpath!');
      }

      if (!mockMsg) {
        throw Error('msg function used at invalid position!');
      }

      const root = jsonpath.query(mockMsg, jsonPath);
      if (root && root.length > 0) return root[0];else return '';
    },
    numberOfArguments: 1
  },
  $func: {
    handler: (caps, code) => {
      if (code == null) {
        throw Error('func function used without args!');
      }

      try {
        const vm = new NodeVM$1({
          eval: false,
          require: false,
          env: caps[Capabilities.SECURITY_ALLOW_UNSAFE] ? process.env : {},
          sandbox: {
            caps
          }
        });
        return vm.run(`module.exports = (${code})`);
      } catch (err) {
        throw Error(`func function execution failed - ${err}`);
      }
    },
    numberOfArguments: 1
  }
};

const SCRIPTING_FUNCTIONS$1 = lodash.mapValues(SCRIPTING_FUNCTIONS_RAW, (funcOrStruct, name) => {
  const func = funcOrStruct.handler || funcOrStruct;
  const numberOfArguments = funcOrStruct.handler ? funcOrStruct.numberOfArguments || 0 : funcOrStruct.length;
  return {
    handler: (caps, ...rest) => {
      if (!caps[Capabilities.SECURITY_ALLOW_UNSAFE] && funcOrStruct.unsafe) {
        throw new BotiumError$4(`Security Error. Using unsafe scripting memory function ${name} is not allowed`, {
          type: 'security',
          subtype: 'allow unsafe',
          source: path.basename(__filename),
          cause: {
            SECURITY_ALLOW_UNSAFE: caps[Capabilities.SECURITY_ALLOW_UNSAFE],
            functionName: name
          }
        });
      }

      if (funcOrStruct.handler) {
        return func(caps, ...rest);
      } else {
        return func(...rest);
      }
    },
    numberOfArguments
  };
});

const RESERVED_WORDS = Object.keys(SCRIPTING_FUNCTIONS$1);

const apply = (container, scriptingMemory, str, mockMsg) => {
  if (container.caps[Capabilities.SCRIPTING_ENABLE_MEMORY]) {
    str = _apply(scriptingMemory, str, container.caps, mockMsg);
  }

  return str;
};

const applyToArgs = (args, scriptingMemory, caps, mockMsg) => {
  return (args || []).map(arg => {
    return _apply(scriptingMemory, arg, caps, mockMsg);
  });
}; // we have two replace longer variable first. if there is $year, and $years, $years should not be found by $year


const _longestFirst = (a, b) => b.length - a.length;

const _apply = (scriptingMemory, str, caps, mockMsg) => {
  if (str) {
    scriptingMemory = scriptingMemory || {};
    str = toString$2(str); // merge all keys: longer is stronger, type does not matter
    // Not clean: what if a variable references other variable/function?

    const allKeys = Object.keys(SCRIPTING_FUNCTIONS$1).concat(Object.keys(scriptingMemory)).sort(_longestFirst);

    for (const key of allKeys) {
      // scripting memory is stronger
      if (lodash.has(scriptingMemory, key)) {
        const keyRegexp = new RegExp(`\\${key}`, 'g');
        str = str.replace(keyRegexp, scriptingMemory[key]);
      } else {
        const regex = `\\${key}(\\(.+?(?<!\\\\)\\))?`;
        const matches = str.match(new RegExp(regex, 'g')) || [];

        for (const match of matches) {
          if (match.indexOf('(') > 0) {
            const arg = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).replace(/\\\)/g, ')');
            str = str.replace(match, SCRIPTING_FUNCTIONS$1[key].handler(caps, arg, mockMsg));
          } else {
            str = str.replace(match, SCRIPTING_FUNCTIONS$1[key].handler(caps));
          }
        }
      }
    }
  }

  return str;
};

const extractVarNames = text => {
  return (lodash.isString(text) ? text.match(/\$[A-Za-z]\w+/g) : false) || [];
};

const fill = (container, scriptingMemory, result, utterance, scriptingEvents) => {
  debug$j(`fill start: ${util.inspect(scriptingMemory)}`);
  let varRegex;

  switch (container.caps[Capabilities.SCRIPTING_MEMORY_MATCHING_MODE]) {
    case 'word':
      varRegex = '(\\w+)';
      break;

    case 'joker':
      varRegex = '([\\w\\W]+)';
      break;

    default:
      varRegex = '(\\S+)';
      break;
  }

  if (result && lodash.isString(result) && utterance && container.caps[Capabilities.SCRIPTING_ENABLE_MEMORY]) {
    const utterances = scriptingEvents.resolveUtterance({
      utterance
    });
    utterances.forEach(expected => {
      if (lodash.isUndefined(expected)) return;
      expected = toString$2(expected);
      let reExpected = expected;

      if (container.caps[Capabilities.SCRIPTING_MATCHING_MODE] !== 'regexp' && container.caps[Capabilities.SCRIPTING_MATCHING_MODE] !== 'regexpIgnoreCase') {
        reExpected = lodash.isString(expected) ? quoteRegexpString$1(expected).replace(/\\\$/g, '$') : expected;
      }

      const varMatches = extractVarNames(expected);

      for (let i = 0; i < varMatches.length; i++) {
        const varMatchesRegexp = new RegExp(`\\${varMatches[i]}`, 'g');
        reExpected = reExpected.replace(varMatchesRegexp, varRegex);
      }

      const resultMatches = result.match(reExpected) || [];

      for (let i = 1; i < resultMatches.length; i++) {
        if (i <= varMatches.length) {
          const varName = varMatches[i - 1];

          if (RESERVED_WORDS.indexOf(varName) >= 0) {
            debug$j(`fill Variable "${varName}" is not overwritten, because it is reserved word. `);
          } else {
            scriptingMemory[varName] = resultMatches[i];
          }
        }
      }
    });
    debug$j(`fill end: ${util.inspect(scriptingMemory)}`);
  }
};

var ScriptingMemory = {
  apply,
  applyToArgs,
  fill,
  extractVarNames,
  RESERVED_WORDS,
  SCRIPTING_FUNCTIONS: SCRIPTING_FUNCTIONS$1
};
ScriptingMemory.apply;
ScriptingMemory.applyToArgs;
ScriptingMemory.fill;
ScriptingMemory.extractVarNames;
ScriptingMemory.RESERVED_WORDS;
ScriptingMemory.SCRIPTING_FUNCTIONS;

const debug$i = debug$l('botium-core-Convo');
const {
  BotiumError: BotiumError$3,
  botiumErrorFromErr: botiumErrorFromErr$1,
  botiumErrorFromList: botiumErrorFromList$1
} = BotiumError_1;
const {
  normalizeText,
  toString: toString$1,
  removeBuffers,
  splitStringInNonEmptyLines
} = helper;
const {
  LOGIC_HOOK_INCLUDE
} = LogicHookConsts;

class ConvoHeader$1 {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.projectname = fromJson.projectname;
    this.testsessionname = fromJson.testsessionname;
    this.sort = fromJson.sort;
    this.order = fromJson.order;
    this.description = fromJson.description;
    Object.assign(this, fromJson);
  }

  toString() {
    return this.order + ' ' + this.name + (this.description ? ` (${this.description})` : '');
  }

}

class ConvoStepAssert {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = fromJson.args;
    this.not = fromJson.not;
    this.optional = fromJson.optional;
  }

  toString() {
    return (this.optional ? '?' : '') + (this.not ? '!' : '') + this.name + '(' + (this.args ? this.args.join(',') : 'no args') + ')';
  }

}

class ConvoStepLogicHook {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = fromJson.args;
  }

  toString() {
    return this.name + '(' + (this.args ? this.args.join(',') : 'no args') + ')';
  }

}

class ConvoStepUserInput {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.args = fromJson.args;
  }

  toString() {
    return this.name + '(' + (this.args ? this.args.join(',') : 'no args') + ')';
  }

}

class ConvoStep$1 {
  constructor(fromJson = {}) {
    this.sender = fromJson.sender;
    this.channel = fromJson.channel;
    this.messageText = fromJson.messageText;
    this.sourceData = fromJson.sourceData;
    this.stepTag = fromJson.stepTag;
    this.not = fromJson.not;
    this.optional = fromJson.optional;
    this.asserters = lodash.map(fromJson.asserters, asserter => new ConvoStepAssert(asserter));
    this.logicHooks = lodash.map(fromJson.logicHooks, logicHook => new ConvoStepLogicHook(logicHook));
    this.userInputs = lodash.map(fromJson.userInputs, userInput => new ConvoStepUserInput(userInput));
  }

  hasInteraction() {
    return this.messageText && this.messageText.length > 0 || this.sourceData || this.asserters && this.asserters.length > 0 || this.logicHooks && this.logicHooks.findIndex(l => l.name !== LOGIC_HOOK_INCLUDE) >= 0 || this.userInputs && this.userInputs.length > 0;
  }

  toString() {
    return (this.stepTag ? this.stepTag + ': ' : '') + '#' + this.sender + ' - ' + (this.optional ? '?' : '') + (this.not ? '!' : '') + (this.messageText || '') + (this.asserters && this.asserters.length > 0 ? ' ' + this.asserters.map(a => a.toString()).join(' ASS: ') : '') + (this.logicHooks && this.logicHooks.length > 0 ? ' ' + this.logicHooks.map(l => l.toString()).join(' LH: ') : '') + (this.userInputs && this.userInputs.length > 0 ? ' ' + this.userInputs.map(u => u.toString()).join(' UI: ') : '');
  }

}

class Transcript {
  constructor({
    steps,
    attachments,
    scriptingMemory,
    convoBegin,
    convoEnd,
    err
  }) {
    this.steps = steps;
    this.attachments = attachments;
    this.scriptingMemory = scriptingMemory;
    this.convoBegin = convoBegin;
    this.convoEnd = convoEnd;
    this.err = err;
  }

  prettifyActual() {
    const prettifiedSteps = this.steps.map(step => {
      if (step.actual && step.actual.prettify) {
        return step.actual.prettify();
      } else {
        return '<empty conversation step>';
      }
    });
    return prettifiedSteps.join('\n');
  }

}

class TranscriptStep {
  constructor({
    expected,
    not,
    optional,
    actual,
    stepBegin,
    stepEnd,
    botBegin,
    botEnd,
    err
  }) {
    this.expected = expected;
    this.not = not;
    this.optional = optional;
    this.actual = actual;
    this.stepBegin = stepBegin;
    this.stepEnd = stepEnd;
    this.botBegin = botBegin;
    this.botEnd = botEnd;
    this.err = err;
  }

}

class TranscriptError extends Error {
  constructor(err, transcript) {
    super(err.message);
    this.name = this.constructor.name;
    this.transcript = transcript;
    this.cause = err;
    Error.captureStackTrace(this, this.constructor);
  }

}

class Convo$6 {
  constructor(context, fromJson = {}) {
    if (fromJson instanceof Convo$6) {
      debug$i('Illegal state!!! Parameter should be a JSON, but it is a Convo');
    } else if (fromJson.beginAsserter) {
      // beginAsserter is one of the fields which are lost
      debug$i('Illegal state!!! Parameter should be a native JSON, but looks as a Convo converted to JSON');
    }

    this.scriptingEvents = context.scriptingEvents;
    this.context = context;
    this.header = new ConvoHeader$1(fromJson.header);

    if (fromJson.conversation && lodash.isArray(fromJson.conversation)) {
      this.conversation = lodash.map(fromJson.conversation, step => new ConvoStep$1(step));
    } else {
      this.conversation = [];
    }

    this.sourceTag = fromJson.sourceTag;
    const {
      beginAsserter,
      endAsserter
    } = this.setConvoBeginAndEndAsserter(fromJson);
    this.beginAsserter = beginAsserter;
    this.endAsserter = endAsserter;
    const {
      beginLogicHook,
      endLogicHook
    } = this.setConvoBeginAndEndLogicHook(fromJson);
    this.beginLogicHook = beginLogicHook;
    this.endLogicHook = endLogicHook;
    this.effectiveConversation = null;
  }

  setConvoBeginAndEndAsserter(fromJson) {
    const beginAsserter = fromJson.conversation.filter(s => s.sender === 'begin' && s.asserters && s.asserters.length > 0).map(s => s.asserters).reduce((acc, val) => acc.concat(val), []);
    const endAsserter = fromJson.conversation.filter(s => s.sender === 'end' && s.asserters && s.asserters.length > 0).map(s => s.asserters).reduce((acc, val) => acc.concat(val), []);
    return {
      beginAsserter,
      endAsserter
    };
  }

  setConvoBeginAndEndLogicHook(fromJson) {
    const beginLogicHook = fromJson.conversation.filter(s => s.sender === 'begin' && s.logicHooks && s.logicHooks.length > 0).map(s => s.logicHooks).reduce((acc, val) => acc.concat(val), []);
    const endLogicHook = fromJson.conversation.filter(s => s.sender === 'end' && s.logicHooks && s.logicHooks.length > 0).map(s => s.logicHooks).reduce((acc, val) => acc.concat(val), []);
    return {
      beginLogicHook,
      endLogicHook
    };
  }

  toString() {
    return this.header.toString() + (this.sourceTag ? ` (${util.inspect(this.sourceTag)})` : '') + ': ' + this.conversation.map(c => c.toString()).join(' | ');
  }

  async Run(container) {
    const transcript = new Transcript({
      steps: [],
      attachments: [],
      convoBegin: new Date(),
      convoEnd: null,
      err: null
    });
    const scriptingMemory = {};
    container.caps[Capabilities.TESTCASENAME] = this.header.name;

    try {
      try {
        // onConvoBegin first or assertConvoBegin? If onConvoBegin, then it is possible to assert it too
        await this.scriptingEvents.onConvoBegin({
          convo: this,
          convoStep: {
            stepTag: '#begin'
          },
          container,
          transcript,
          scriptingMemory
        });
      } catch (err) {
        throw new TranscriptError(botiumErrorFromErr$1(`${this.header.name}: ${err.message}`, err), transcript);
      }

      try {
        await this.scriptingEvents.assertConvoBegin({
          convo: this,
          convoStep: {
            stepTag: '#begin'
          },
          container,
          scriptingMemory
        });
      } catch (err) {
        throw new TranscriptError(botiumErrorFromErr$1(`${this.header.name}: ${err.message}`, err), transcript);
      }

      await this.runConversation(container, scriptingMemory, transcript);
      await this._checkBotRepliesConsumed(container);

      try {
        await this.scriptingEvents.onConvoEnd({
          convo: this,
          convoStep: {
            stepTag: '#end'
          },
          container,
          transcript,
          scriptingMemory: scriptingMemory
        });
      } catch (err) {
        throw new TranscriptError(botiumErrorFromErr$1(`${this.header.name}: ${err.message}`, err), transcript);
      }

      if (transcript.err && container.caps[Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS]) {
        let assertConvoEndErr = null;

        try {
          await this.scriptingEvents.assertConvoEnd({
            convo: this,
            convoStep: {
              stepTag: '#end'
            },
            container,
            transcript,
            scriptingMemory: scriptingMemory
          });
        } catch (err) {
          assertConvoEndErr = botiumErrorFromErr$1(`${this.header.name}: ${err.message}`, err);
        }

        if (assertConvoEndErr) {
          const err = transcript.err;
          transcript.err = botiumErrorFromList$1([transcript.err, assertConvoEndErr], {});
          transcript.err.context.input = err.context.input;
          transcript.err.context.transcript = err.context.transcript;
        }

        throw new TranscriptError(transcript.err, transcript);
      } else if (transcript.err) {
        throw new TranscriptError(transcript.err, transcript);
      }

      try {
        await this.scriptingEvents.assertConvoEnd({
          convo: this,
          convoStep: {
            stepTag: '#end'
          },
          container,
          transcript,
          scriptingMemory: scriptingMemory
        });
      } catch (err) {
        transcript.err = botiumErrorFromErr$1(`${this.header.name}: ${err.message}`, err);
        throw new TranscriptError(transcript.err, transcript);
      }

      return transcript;
    } finally {
      container.eventEmitter.emit(Events.MESSAGE_TRANSCRIPT, container, transcript);
    }
  }

  async runConversation(container, scriptingMemory, transcript) {
    const transcriptSteps = [];

    try {
      let lastMeConvoStep = null;
      let botMsg = null;
      let waitForBotSays = true;
      let skipTranscriptStep = false;

      for (let i = 0; i < this.conversation.length; i++) {
        const convoStep = this.conversation[i];
        const currentStepIndex = i;
        skipTranscriptStep = false;
        const transcriptStep = new TranscriptStep({
          expected: new BotiumMockMessage_1(convoStep),
          not: convoStep.not,
          optional: convoStep.optional,
          actual: null,
          stepBegin: new Date(),
          stepEnd: null,
          botBegin: null,
          botEnd: null,
          err: null
        });

        try {
          if (convoStep.sender === 'begin' || convoStep.sender === 'end') {
            continue;
          } else if (convoStep.sender === 'me') {
            const meMsg = new BotiumMockMessage_1(convoStep);
            meMsg.messageText = ScriptingMemory.apply(container, scriptingMemory, meMsg.messageText, meMsg); // buggy command is removed, but because sideeffects are possible, it can be reactivated.
            // If there are no sideeffects coming up, then row can be deleted permanently.

            if (process.env.WORKAROUND_OVERWRITE_JSON_MESSAGE_TEXT) {
              // if this line is active, then Random() in me section does not work in performance test
              // (first run overwrites the function with the value, and the next run has the value, not the function)
              convoStep.messageText = meMsg.messageText;
            }

            transcriptStep.actual = meMsg;

            try {
              await this.scriptingEvents.setUserInput({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                meMsg,
                transcript,
                transcriptStep
              });
              await this.scriptingEvents.onMeStart({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                meMsg,
                transcript,
                transcriptStep
              });
              await this.scriptingEvents.onMePrepare({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                meMsg,
                transcript,
                transcriptStep
              });
              await this._checkBotRepliesConsumed(container);

              const coreMsg = lodash.omit(removeBuffers(meMsg), ['sourceData']);

              debug$i(`${this.header.name}/${convoStep.stepTag}: user says (cleaned by binary and base64 data and sourceData) ${JSON.stringify(coreMsg, null, 2)}`);
              await new Promise(resolve => {
                if (container.caps.SIMULATE_WRITING_SPEED && meMsg.messageText && meMsg.messageText.length) {
                  setTimeout(() => resolve(), container.caps.SIMULATE_WRITING_SPEED * meMsg.messageText.length);
                } else {
                  resolve();
                }
              });
              lastMeConvoStep = convoStep;
              transcriptStep.botBegin = new Date();

              if (!lodash.isNull(meMsg.messageText) || meMsg.sourceData || meMsg.userInputs && meMsg.userInputs.length || meMsg.logicHooks && meMsg.logicHooks.length) {
                try {
                  Object.assign(meMsg, {
                    header: this.header,
                    conversation: this.conversation,
                    currentStepIndex,
                    scriptingMemory
                  });
                  await container.UserSays(meMsg);
                } finally {
                  delete meMsg.header;
                  delete meMsg.conversation;
                  delete meMsg.scriptingMemory;
                }

                transcriptStep.botEnd = new Date();
                await this.scriptingEvents.onMeEnd({
                  convo: this,
                  convoStep,
                  container,
                  scriptingMemory,
                  meMsg,
                  transcript,
                  transcriptStep
                });
                continue;
              } else {
                debug$i(`${this.header.name}/${convoStep.stepTag}: message not found in #me section, message not sent to container ${util.inspect(convoStep)}`);
                transcriptStep.botEnd = new Date();
                await this.scriptingEvents.onMeEnd({
                  convo: this,
                  convoStep,
                  container,
                  scriptingMemory,
                  meMsg,
                  transcript,
                  transcriptStep
                });
                continue;
              }
            } catch (err) {
              transcriptStep.botEnd = new Date();
              const failErr = botiumErrorFromErr$1(`${this.header.name}/${convoStep.stepTag}: error sending to bot - ${err.message || err}`, err);
              debug$i(failErr);

              try {
                this.scriptingEvents.fail && this.scriptingEvents.fail(failErr);
              } catch (failErr) {}

              throw failErr;
            }
          } else if (convoStep.sender === 'bot') {
            if (waitForBotSays) {
              botMsg = null;
            } else {
              waitForBotSays = true;
            }

            try {
              debug$i(`${this.header.name} wait for bot ${convoStep.channel || ''}`);
              await this.scriptingEvents.onBotStart({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                transcript,
                transcriptStep
              });
              transcriptStep.botBegin = new Date();

              if (!botMsg) {
                botMsg = await container.WaitBotSays(convoStep.channel);
              }

              transcriptStep.botEnd = new Date();
              transcriptStep.actual = new BotiumMockMessage_1(botMsg);

              const coreMsg = lodash.omit(removeBuffers(botMsg), ['sourceData']);

              debug$i(`${this.header.name}: bot says (cleaned by binary and base64 data and sourceData) ${JSON.stringify(coreMsg, null, 2)}`);
            } catch (err) {
              transcriptStep.botEnd = new Date();
              const failErr = botiumErrorFromErr$1(`${this.header.name}/${convoStep.stepTag}: error waiting for bot - ${err.message}`, err);
              debug$i(failErr);

              try {
                this.scriptingEvents.fail && this.scriptingEvents.fail(failErr, lastMeConvoStep);
              } catch (failErr) {}

              throw failErr;
            }

            try {
              const prepared = await this.scriptingEvents.onBotPrepare({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                botMsg,
                transcript,
                transcriptStep
              });

              if (prepared) {
                transcriptStep.actual = new BotiumMockMessage_1(botMsg);

                const coreMsg = lodash.omit(removeBuffers(botMsg), ['sourceData']);

                debug$i(`${this.header.name}: onBotPrepare (cleaned by binary and base64 data and sourceData) ${JSON.stringify(coreMsg, null, 2)}`);
              }
            } catch (err) {
              const failErr = botiumErrorFromErr$1(`${this.header.name}/${convoStep.stepTag}: onBotPrepare error - ${err.message || err}`, err);
              debug$i(failErr);

              try {
                this.scriptingEvents.fail && this.scriptingEvents.fail(failErr, lastMeConvoStep);
              } catch (failErr) {}

              throw failErr;
            }

            if (!botMsg || !botMsg.messageText && !botMsg.media && !botMsg.buttons && !botMsg.cards && !botMsg.sourceData && !botMsg.nlp) {
              const failErr = new BotiumError$3(`${this.header.name}/${convoStep.stepTag}: bot says nothing`);
              debug$i(failErr);

              try {
                this.scriptingEvents.fail && this.scriptingEvents.fail(failErr, lastMeConvoStep);
              } catch (failErr) {}

              throw failErr;
            }

            const isErrorHandledWithOptionConvoStep = err => {
              const nextConvoStep = this.conversation[i + 1];

              if (convoStep.optional && nextConvoStep && nextConvoStep.sender === 'bot') {
                waitForBotSays = false;
                skipTranscriptStep = true;
                return true;
              }

              if (container.caps[Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS]) {
                assertErrors.push(err);
                return false;
              } else {
                throw err;
              }
            };

            const assertErrors = [];
            const scriptingMemoryUpdate = {};

            if (convoStep.messageText) {
              const response = this._checkNormalizeText(container, botMsg.messageText);

              const messageText = this._checkNormalizeText(container, convoStep.messageText);

              ScriptingMemory.fill(container, scriptingMemoryUpdate, response, messageText, this.scriptingEvents);

              const tomatch = this._resolveUtterancesToMatch(container, Object.assign({}, scriptingMemoryUpdate, scriptingMemory), messageText, botMsg);

              if (convoStep.not) {
                try {
                  this.scriptingEvents.assertBotNotResponse(response, tomatch, `${this.header.name}/${convoStep.stepTag}`, lastMeConvoStep);
                } catch (err) {
                  if (isErrorHandledWithOptionConvoStep(err)) {
                    continue;
                  }
                }
              } else {
                try {
                  this.scriptingEvents.assertBotResponse(response, tomatch, `${this.header.name}/${convoStep.stepTag}`, lastMeConvoStep);
                } catch (err) {
                  if (isErrorHandledWithOptionConvoStep(err)) {
                    continue;
                  }
                }
              }
            } else if (convoStep.sourceData) {
              try {
                this._compareObject(container, scriptingMemory, convoStep, botMsg.sourceData, convoStep.sourceData, botMsg);
              } catch (err) {
                if (isErrorHandledWithOptionConvoStep(err)) {
                  continue;
                }
              }
            }

            Object.assign(scriptingMemory, scriptingMemoryUpdate);

            try {
              await this.scriptingEvents.assertConvoStep({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                botMsg,
                transcript,
                transcriptStep
              });
              await this.scriptingEvents.onBotEnd({
                convo: this,
                convoStep,
                container,
                scriptingMemory,
                botMsg,
                transcript,
                transcriptStep
              });
            } catch (err) {
              const nextConvoStep = this.conversation[i + 1];

              if (convoStep.optional && nextConvoStep && nextConvoStep.sender === 'bot') {
                waitForBotSays = false;
                skipTranscriptStep = true;
                continue;
              }

              const failErr = botiumErrorFromErr$1(`${this.header.name}/${convoStep.stepTag}: assertion error - ${err.message || err}`, err);
              debug$i(failErr);

              try {
                this.scriptingEvents.fail && this.scriptingEvents.fail(failErr, lastMeConvoStep);
              } catch (failErr) {}

              if (container.caps[Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS] && err instanceof BotiumError$3) {
                assertErrors.push(err);
              } else {
                throw failErr;
              }
            }

            if (container.caps[Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS]) {
              if (assertErrors.length > 0) {
                throw botiumErrorFromList$1(assertErrors, {});
              }
            } else {
              if (!transcriptStep.stepEnd) {
                continue;
              }
            }
          } else {
            const failErr = new BotiumError$3(`${this.header.name}/${convoStep.stepTag}: invalid sender - ${util.inspect(convoStep.sender)}`);
            debug$i(failErr);

            try {
              this.scriptingEvents.fail && this.scriptingEvents.fail(failErr);
            } catch (failErr) {}

            throw failErr;
          }
        } catch (err) {
          if (lastMeConvoStep) {
            if (err instanceof BotiumError$3 && err.context) {
              err.context.input = new ConvoStep$1(lastMeConvoStep);
              err.context.transcript = [...transcriptSteps, { ...transcriptStep
              }];
            } else {
              err.input = new ConvoStep$1(lastMeConvoStep);
              err.transcript = [...transcriptSteps, { ...transcriptStep
              }];
            }
          }

          transcriptStep.err = err;
          throw err;
        } finally {
          if (convoStep.sender !== 'begin' && convoStep.sender !== 'end' && !skipTranscriptStep) {
            transcriptStep.scriptingMemory = Object.assign({}, scriptingMemory);
            transcriptStep.stepEnd = new Date();
            transcriptSteps.push(transcriptStep);
          }
        }
      }
    } catch (err) {
      transcript.err = err;
    } finally {
      transcript.steps = transcriptSteps.filter(s => s);
      transcript.scriptingMemory = scriptingMemory;
      transcript.convoEnd = new Date();
    }
  }

  _compareObject(container, scriptingMemory, convoStep, result, expected, botMsg) {
    if (expected === null || expected === undefined) return;

    if (lodash.isArray(expected)) {
      if (!lodash.isArray(result)) {
        throw new BotiumError$3(`${this.header.name}/${convoStep.stepTag}: bot response expected array, got "${result}"`);
      }

      if (expected.length !== result.length) {
        throw new BotiumError$3(`${this.header.name}/${convoStep.stepTag}: bot response expected array length ${expected.length}, got ${result.length}`);
      }

      for (let i = 0; i < expected.length; i++) {
        this._compareObject(container, scriptingMemory, convoStep, result[i], expected[i]);
      }
    } else if (lodash.isObject(expected)) {
      lodash.forOwn(expected, (value, key) => {
        if (Object.prototype.hasOwnProperty.call(result, key)) {
          this._compareObject(container, scriptingMemory, convoStep, result[key], expected[key]);
        } else {
          throw new BotiumError$3(`${this.header.name}/${convoStep.stepTag}: bot response "${result}" missing expected property: ${key}`);
        }
      });
    } else {
      ScriptingMemory.fill(container, scriptingMemory, result, expected, this.scriptingEvents);

      const response = this._checkNormalizeText(container, result);

      const tomatch = this._resolveUtterancesToMatch(container, scriptingMemory, expected, botMsg);

      this.scriptingEvents.assertBotResponse(response, tomatch, `${this.header.name}/${convoStep.stepTag}`);
    }
  }

  GetScriptingMemoryAllVariables(container) {
    const resultOuter = this.conversation.reduce((acc, convoStep) => {
      let result = acc;
      result = result.concat(this.GetScriptingMemoryVariables(container, convoStep.messageText));

      const extractFromArgs = convoStepItems => {
        let resultInner = [];

        for (const item of convoStepItems || []) {
          for (const arg of item.args || []) {
            resultInner = resultInner.concat(this.GetScriptingMemoryVariables(container, arg));
          }
        }

        return resultInner;
      };

      result = result.concat(extractFromArgs(convoStep.asserters));
      result = result.concat(extractFromArgs(convoStep.logicHooks));
      result = result.concat(extractFromArgs(convoStep.userInputs));
      return result;
    }, []);
    return [...new Set(resultOuter)];
  }

  GetScriptingMemoryVariables(container, utterance) {
    if (!utterance || !container.caps[Capabilities.SCRIPTING_ENABLE_MEMORY]) {
      return [];
    }

    const utterances = this.scriptingEvents.resolveUtterance({
      utterance
    });
    return utterances.reduce((acc, expected) => {
      if (lodash.isUndefined(expected)) return acc;else return acc.concat(ScriptingMemory.extractVarNames(toString$1(expected)) || []);
    }, []);
  }

  _checkBotRepliesConsumed(container) {
    if (container.caps.SCRIPTING_FORCE_BOT_CONSUMED) {
      const queueLength = container._QueueLength();

      if (queueLength === 1) {
        throw new Error('There is an unread bot reply in queue');
      } else if (queueLength > 1) {
        throw new Error(`There are still ${queueLength} unread bot replies in queue`);
      }
    }
  }

  _resolveUtterancesToMatch(container, scriptingMemory, utterance, botMsg) {
    const utterances = this.scriptingEvents.resolveUtterance({
      utterance
    });
    const normalizedUtterances = utterances.map(str => this._checkNormalizeText(container, str));
    const tomatch = normalizedUtterances.map(str => ScriptingMemory.apply(container, scriptingMemory, str, botMsg));
    return tomatch;
  }

  _checkNormalizeText(container, str) {
    return normalizeText(str, !!container.caps[Capabilities.SCRIPTING_NORMALIZE_TEXT]);
  }

  expandPartialConvos() {
    const _getIncludeLogicHookNames = convoStep => {
      if (!convoStep.logicHooks) {
        return [];
      }

      const result = [];
      convoStep.logicHooks.forEach(logicHook => {
        if (logicHook.name === LOGIC_HOOK_INCLUDE) {
          if (logicHook.args.length !== 1) {
            throw Error('Wrong argument for include logic hook!');
          }

          result.push(logicHook);
        }
      });
      return result.map(hook => hook.args[0]);
    };

    const partialConvos = this.context.GetPartialConvos();

    const _getEffectiveConversationRecursive = (conversation, parentPConvos = [], result = [], ignoreBeginEnd = true) => {
      conversation.forEach(convoStep => {
        let includeLogicHooks = [];

        if (convoStep.sender === 'include') {
          if (convoStep.channel) {
            includeLogicHooks.push(convoStep.channel);
          }

          if (convoStep.messageText) {
            includeLogicHooks = includeLogicHooks.concat(splitStringInNonEmptyLines(convoStep.messageText));
          }
        } else {
          includeLogicHooks = _getIncludeLogicHookNames(convoStep);

          if (includeLogicHooks.length === 0 || convoStep.hasInteraction()) {
            if (!ignoreBeginEnd || convoStep.sender !== 'begin' && convoStep.sender !== 'end') {
              // dont put convo name for ConvoSteps on the root.
              const steptagPath = parentPConvos.length === 0 ? '' : parentPConvos.join('/') + '/';
              result.push(Object.assign(new ConvoStep$1(), convoStep, {
                stepTag: `${steptagPath}${convoStep.stepTag}`
              }));
            }
          }
        }

        includeLogicHooks.forEach(includeLogicHook => {
          const alreadyThereAt = parentPConvos.indexOf(includeLogicHook);

          if (alreadyThereAt >= 0) {
            throw new BotiumError$3(`Partial convos are included circular. "${includeLogicHook}" is referenced by "/${parentPConvos.slice(0, alreadyThereAt).join('/')}" and by "/${parentPConvos.join('/')}" `);
          }

          if (!partialConvos || Object.keys(partialConvos).length === 0) {
            throw new BotiumError$3(`Cant find partial convo with name ${includeLogicHook} (There are no partial convos)`);
          }

          const partialConvo = partialConvos[includeLogicHook];

          if (!partialConvo) {
            throw new BotiumError$3(`Cant find partial convo with name ${includeLogicHook} (available partial convos: ${Object.keys(partialConvos).join(',')})`);
          }

          _getEffectiveConversationRecursive(partialConvo.conversation, [...parentPConvos, includeLogicHook], result, true);

          debug$i(`Partial convo ${includeLogicHook} included`);
        });
      });
      return result;
    };

    this.conversation = _getEffectiveConversationRecursive(this.conversation, [], [], false);
  }

}

var Convo_1 = {
  ConvoHeader: ConvoHeader$1,
  Convo: Convo$6,
  ConvoStep: ConvoStep$1
};

var RetryHelper_1 = class RetryHelper {
  constructor(caps, section) {
    this.retrySettings = {
      retries: caps[`RETRY_${section.toUpperCase()}_NUMRETRIES`] || 1,
      factor: caps[`RETRY_${section.toUpperCase()}_FACTOR`] || 1,
      minTimeout: caps[`RETRY_${section.toUpperCase()}_MINTIMEOUT`] || 1000
    };
    this.retryErrorPatterns = [];
    const onErrorRegexp = caps[`RETRY_${section.toUpperCase()}_ONERROR_REGEXP`] || [];

    if (onErrorRegexp) {
      if (lodash.isArray(onErrorRegexp)) {
        onErrorRegexp.forEach(r => {
          if (lodash.isString(r)) this.retryErrorPatterns.push(new RegExp(r, 'i'));else this.retryErrorPatterns.push(r);
        });
      } else if (lodash.isString(onErrorRegexp)) {
        this.retryErrorPatterns.push(new RegExp(onErrorRegexp, 'i'));
      } else {
        this.retryErrorPatterns.push(onErrorRegexp);
      }
    }
  }

  shouldRetry(err) {
    if (!err || this.retryErrorPatterns.length === 0) return false;
    const errString = util.inspect(err);

    for (const re of this.retryErrorPatterns) {
      if (errString.match(re)) return true;
    }

    return false;
  }

};

const {
  toString,
  quoteRegexpString
} = helper;

const _normalize = botresponse => {
  if (lodash.isUndefined(botresponse)) return '';

  if (lodash.isObject(botresponse) && lodash.has(botresponse, 'messageText')) {
    return toString(botresponse.messageText) || '';
  }

  return toString(botresponse);
};

const regexp = ignoreCase => (botresponse, utterance) => {
  if (lodash.isUndefined(botresponse)) return false;
  utterance = toString(utterance);
  botresponse = _normalize(botresponse);
  const regexp = ignoreCase ? new RegExp(utterance, 'i') : new RegExp(utterance, '');
  return regexp.test(botresponse);
};

const wildcard = ignoreCase => (botresponse, utterance) => {
  if (lodash.isUndefined(botresponse)) {
    if (utterance.trim() === '*') return true;else return false;
  }

  utterance = toString(utterance);
  botresponse = _normalize(botresponse);
  const numWildcards = utterance.split('*').length - 1;

  if (numWildcards > 10) {
    throw new Error('Maximum number of 10 wildcards supported.');
  }

  const utteranceRe = quoteRegexpString(utterance).replace(/\\\*/g, '(.*)');
  const regexp = ignoreCase ? new RegExp(utteranceRe, 'i') : new RegExp(utteranceRe, '');
  return regexp.test(botresponse);
};

const wildcardExact = ignoreCase => (botresponse, utterance) => {
  if (lodash.isUndefined(botresponse)) {
    if (utterance.trim() === '*') return true;else return false;
  }

  utterance = toString(utterance);
  botresponse = _normalize(botresponse);
  const numWildcards = utterance.split('*').length - 1;

  if (numWildcards > 10) {
    throw new Error('Maximum number of 10 wildcards supported.');
  }

  const utteranceRe = '^' + quoteRegexpString(utterance).replace(/\\\*/g, '(.*)') + '$';
  const regexp = ignoreCase ? new RegExp(utteranceRe, 'i') : new RegExp(utteranceRe, '');
  return regexp.test(botresponse);
};

const include = ignoreCase => (botresponse, utterance) => {
  if (lodash.isUndefined(botresponse)) return false;
  utterance = toString(utterance);
  botresponse = _normalize(botresponse);

  if (ignoreCase) {
    utterance = utterance.toLowerCase();
    botresponse = botresponse.toLowerCase();
  }

  return botresponse.indexOf(utterance) >= 0;
};

const equals = ignoreCase => (botresponse, utterance) => {
  if (lodash.isUndefined(botresponse)) return false;
  utterance = toString(utterance);
  botresponse = _normalize(botresponse);

  if (ignoreCase) {
    utterance = utterance.toLowerCase();
    botresponse = botresponse.toLowerCase();
  }

  return botresponse === utterance;
};

const getMatchFunction$1 = matchingMode => {
  if (matchingMode === 'regexp' || matchingMode === 'regexpIgnoreCase') {
    return regexp(matchingMode === 'regexpIgnoreCase');
  } else if (matchingMode === 'wildcard' || matchingMode === 'wildcardIgnoreCase' || matchingMode === 'wildcardLowerCase') {
    return wildcard(matchingMode === 'wildcardIgnoreCase' || matchingMode === 'wildcardLowerCase');
  } else if (matchingMode === 'wildcardExact' || matchingMode === 'wildcardExactIgnoreCase') {
    return wildcardExact(matchingMode === 'wildcardExactIgnoreCase');
  } else if (matchingMode === 'include' || matchingMode === 'includeIgnoreCase' || matchingMode === 'includeLowerCase') {
    return include(matchingMode === 'includeIgnoreCase' || matchingMode === 'includeLowerCase');
  } else if (matchingMode === 'equals' || matchingMode === 'equalsIgnoreCase') {
    return equals(matchingMode === 'equalsIgnoreCase');
  } else {
    return equals(false);
  }
};

var MatchFunctions = {
  regexp,
  wildcard,
  wildcardExact,
  include,
  equals,
  getMatchFunction: getMatchFunction$1
};

const isStringJson = string => {
  try {
    JSON.parse(string);
  } catch (e) {
    return false;
  }

  return true;
};
/**
 *
 * @param json
 * @param stringIsJson It is possible to stringify a string, so we can say its a json object,
 * but usually thats not what we expect. Default is true because backward compatibility
 * @returns {boolean}
 */


const isJsonObject$1 = (json, stringIsJson = true) => {
  if (!stringIsJson && lodash.isString(json)) {
    return false;
  }

  try {
    JSON.stringify(json);
  } catch (e) {
    return false;
  }

  return true;
};

const isJson = json => {
  if (isStringJson(json)) {
    return json;
  } else if (isJsonObject$1(json)) {
    return JSON.stringify(json);
  }

  return null;
};

const toJsonWeak$1 = stringOrNot => {
  try {
    return JSON.parse(stringOrNot);
  } catch (e) {
    return stringOrNot;
  }
};

const optionalJson = json => {
  const body = isJson(json);
  return body ? {
    'content-type': 'application/json',
    body: body
  } : {
    'content-type': 'text/plain',
    body: json
  };
};

const shortenJsonString = obj => {
  let str = lodash.isString(obj) ? obj : JSON.stringify(obj, null, 2);
  const length = str.length;

  if (length > 1000) {
    str = `${str.substr(0, 1000)} ... (${length - 1000} chars more)`;
  }

  return str;
};

const escapeJSONString$1 = string => {
  if (string) {
    return ('' + string).replace(/["\\\n\r\u2028\u2029]/g, function (character) {
      // Escape all characters not included in SingleStringCharacters and
      // DoubleStringCharacters on
      // http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.4
      switch (character) {
        case '"':
        case '\\':
          return '\\' + character;
        // Four possible LineTerminator characters need to be escaped:

        case '\n':
          return '\\n';

        case '\r':
          return '\\r';

        case '\u2028':
          return '\\u2028';

        case '\u2029':
          return '\\u2029';
      }
    });
  }
};

const formatTimeout$1 = ms => {
  if (ms >= 1000) {
    if (ms % 1000 !== 0) {
      return `${Math.floor(ms / 1000)}s ${ms % 1000}ms`;
    } else {
      return `${Math.floor(ms / 1000)}s`;
    }
  } else {
    return `${ms}ms`;
  }
};

var Utils = {
  optionalJson,
  isJson,
  isJsonObject: isJsonObject$1,
  isStringJson,
  shortenJsonString,
  escapeJSONString: escapeJSONString$1,
  toJsonWeak: toJsonWeak$1,
  formatTimeout: formatTimeout$1
};

const _ensureList = queryResult => {
  if (lodash.isArray(queryResult)) {
    return queryResult;
  }

  return [queryResult];
};

var precompile$2 = (caps, scriptBuffer, options, filename) => {
  if (!filename.endsWith('.json')) {
    return;
  }

  const checkerJsonpath = options.CHECKER_JSONPATH;
  const rootJsonpath = options.ROOT_JSONPATH;
  const utteranceRefsJsonpath = options.UTTERANCE_REF_JSONPATH;
  const utterancesJsonpath = options.UTTERANCES_JSONPATH;
  let scriptData = scriptBuffer;

  if (lodash.isString(scriptData)) {
    try {
      scriptData = JSON.parse(scriptData);
    } catch (err) {
      throw new Error(`Cant convert to JSON ${filename}`);
    }
  }

  if (checkerJsonpath) {
    const scouldExist = jsonpath.query(scriptData, checkerJsonpath);

    if (!scouldExist || scouldExist.length === 0) {
      return;
    }
  }

  if (!rootJsonpath) {
    scriptData = [scriptData];
  } else {
    let rootObjects;

    try {
      rootObjects = _ensureList(jsonpath.query(scriptData, rootJsonpath));
    } catch (err) {
      throw new Error(`Root jsonpath ${rootJsonpath} invalid: ${err.message}`);
    }

    scriptData = rootObjects;
  }

  const result = {};

  for (const json of scriptData) {
    let intent;

    try {
      intent = _ensureList(jsonpath.query(json, utteranceRefsJsonpath));
    } catch (err) {
      throw new Error(`Intents jsonpath ${utteranceRefsJsonpath} invalid: ${err.message}`);
    }

    if (intent.length !== 1) {
      throw new Error(`There should be exact one intent but found "${JSON.stringify(intent)}" on path "${utteranceRefsJsonpath}" in JSON "${JSON.stringify(json)}"`);
    }

    if (!result[intent]) {
      result[intent] = [];
    }

    try {
      result[intent] = result[intent].concat(jsonpath.query(json, utterancesJsonpath));
    } catch (err) {
      throw new Error(`Utterances jsonpath ${utteranceRefsJsonpath} invalid: ${err.message}`);
    }
  }

  return {
    scriptBuffer: JSON.stringify({
      utterances: result
    })
  };
};

var JsonToJson = {
  precompile: precompile$2
};

const {
  NodeVM
} = vm2;
const debug$h = debug$l('botium-core-HookUtils');
const {
  BotiumError: BotiumError$2
} = BotiumError_1;

const executeHook$2 = async (caps, hook, args) => {
  return executeHookSync$1(caps, hook, args);
};

const executeHookSync$1 = (caps, hook, args) => {
  if (!hook) {
    return;
  }

  if (lodash.isFunction(hook)) {
    try {
      return hook(args);
    } catch (err) {
      throw new Error(`Calling Hook function failed: ${err.message}`);
    }
  }

  if (lodash.isString(hook)) {
    try {
      const vm = new NodeVM({
        eval: false,
        require: false,
        sandbox: args
      });
      const r = vm.run(hook);

      if (lodash.isFunction(r)) {
        return r(args);
      } else {
        return r;
      }
    } catch (err) {
      throw new Error(`Calling Hook Javascript code failed: ${err.message}`);
    }
  }

  throw new Error(`Unknown hook ${typeof hook}`);
};

const getHook$3 = (caps, data) => {
  if (!data) {
    return null;
  }

  const allowUnsafe = !!caps[Capabilities.SECURITY_ALLOW_UNSAFE];

  if (lodash.isFunction(data)) {
    debug$h('found hook, type: function definition');
    return data;
  }

  if (lodash.isString(data)) {
    let resultWithRequire;
    let tryLoadFile = path.resolve(process.cwd(), data);

    if (fs.existsSync(tryLoadFile)) {
      try {
        resultWithRequire = commonjsRequire(tryLoadFile);
      } catch (err) {}
    } else {
      tryLoadFile = data;

      try {
        resultWithRequire = commonjsRequire(data);
      } catch (err) {}
    }

    if (resultWithRequire) {
      if (!allowUnsafe) {
        throw new BotiumError$2('Security Error. Using unsafe custom hook with require is not allowed', {
          type: 'security',
          subtype: 'allow unsafe',
          source: path.basename(__filename),
          cause: {
            SECURITY_ALLOW_UNSAFE: caps[Capabilities.SECURITY_ALLOW_UNSAFE],
            hookData: data
          }
        });
      }

      if (lodash.isFunction(resultWithRequire)) {
        debug$h(`found hook, type: require, in ${tryLoadFile}`);
        return resultWithRequire;
      } else {
        throw new Error(`Cant load hook ${tryLoadFile} because it is not a function`);
      }
    }

    try {
      esprima.parseScript(data);
    } catch (err) {
      throw new Error(`Cant load hook, syntax is not valid - ${util.inspect(err)}`);
    }

    debug$h('Found hook, type: JavaScript as String');
    return data;
  }

  throw new Error(`Not valid hook ${util.inspect(data)}`);
};

var HookUtils = {
  getHook: getHook$3,
  executeHook: executeHook$2,
  executeHookSync: executeHookSync$1
};
HookUtils.getHook;
HookUtils.executeHook;
HookUtils.executeHookSync;

const {
  executeHookSync,
  getHook: getHook$2
} = HookUtils;

var precompile$1 = (caps, scriptBuffer, options, filename) => {
  if (!(options.script || options.SCRIPT)) {
    throw new Error('Script is not defined');
  }

  if (lodash.isString(scriptBuffer)) {
    try {
      scriptBuffer = JSON.parse(scriptBuffer);
    } catch (err) {}
  }

  const hook = getHook$2(caps, options.SCRIPT);
  const response = executeHookSync(caps, hook, {
    scriptData: scriptBuffer,
    filename
  });

  if (!response) {
    return;
  }

  return response.scriptBuffer ? response : {
    scriptBuffer: response
  };
};

var Script = {
  precompile: precompile$1
};

const debug$g = debug$l('botium-core-PrecompilerMarkdownRasa');
const htmlCommentRegexp = /(<!--.*?-->)/g;

var precompile = (caps, scriptBuffer, options, filename) => {
  if (!filename.endsWith('.md')) {
    return;
  }

  const md = new markdownIt();
  const parsed = md.parse(scriptBuffer, {});

  const _extractFromRasaIntent = content => {
    return content.replace(htmlCommentRegexp, '').substring('intent:'.length).trim();
  };

  const _extractFromRasaSentence = rasaSentence => {
    rasaSentence = rasaSentence.replace(htmlCommentRegexp, '');
    const regex = /\[([^\]]+)\]\(([a-zA-Z][_:\-a-zA-Z0-9]+)\)/;
    let matched = rasaSentence.match(regex);

    while (matched) {
      const value = matched[1];
      const splitted = matched[2].split(':'); // const [name] = splitted

      if (splitted.length > 1) {
        debug$g(`Entity synonim ${splitted[1]} ignored in sentence ${rasaSentence} `);
      }

      rasaSentence = rasaSentence.replace(matched[0], value);
      matched = rasaSentence.match(regex);
    }

    return {
      meText: rasaSentence.trim()
    };
  };

  const utterances = {};
  let meTexts = [];
  let intent = null; // state got every possible value, but just few are used. Could be simplified.

  let state = 'START';
  let processLeafs = null;

  for (const entry of parsed) {
    if (entry.type === 'heading_open') {
      state = 'heading_open';
    } else if (entry.type === 'inline' && entry.content.startsWith('intent:')) {
      intent = _extractFromRasaIntent(entry.content);
      processLeafs = true;
      state = 'inline_intent';
    } else if (entry.type === 'inline' && entry.content.startsWith('synonym:')) {
      processLeafs = false;
      debug$g(`Synonym "${entry.content}" ignored`);
      state = 'inline_synonym';
    } else if (entry.type === 'inline' && entry.content.startsWith('regex:')) {
      processLeafs = false;
      debug$g(`Regex "${entry.content}" ignored`);
      state = 'inline_regex';
    } else if (entry.type === 'inline' && entry.content.startsWith('lookup:')) {
      processLeafs = false;
      debug$g(`Lookup "${entry.content}" ignored`);
      state = 'inline_lookup';
    } else if (entry.type === 'heading_close') {
      state = 'heading_close';
    } else if (entry.type === 'bullet_list_open') {
      state = 'bullet_list_open';
    } else if (entry.type === 'list_item_open') {
      state = 'list_item_open';
    } else if (entry.type === 'paragraph_open') {
      state = 'paragraph_open';
    } else if (entry.type === 'inline' && state === 'paragraph_open') {
      if (processLeafs) {
        const {
          meText
        } = _extractFromRasaSentence(entry.content);

        meTexts.push(meText);
      }

      state = 'inline_leaf';
    } else if (entry.type === 'paragraph_close') {
      state = 'paragraph_close';
    } else if (entry.type === 'list_item_close') {
      state = 'list_item_close';
    } else if (entry.type === 'bullet_list_close') {
      state = 'bullet_list_close';

      if (meTexts.length) {
        if (!intent) {
          debug$g(`Intent not found, dropping me texts ${JSON.stringify(meTexts)}`);
        } else {
          meTexts = lodash.uniq(meTexts);
          utterances[intent] = meTexts;
        }
      }

      intent = null;
      meTexts = [];
    } else {
      debug$g(`Markdown entry ignored ${util.inspect(entry)}`);
    }
  }

  return {
    scriptBuffer: {
      utterances
    },
    filename: `${filename}.json`
  };
};

var MarkdownRasa = {
  precompile: precompile
};

const debug$f = debug$l('botium-core-CapabilitiesUtils');
const {
  toJsonWeak
} = Utils;

var getAllCapValues$1 = (capNamePrefix, caps) => {
  const allCapValues = [];

  const jsonPathCaps = lodash.pickBy(caps, (v, k) => k.startsWith(capNamePrefix));

  lodash(jsonPathCaps).keys().sort().each(key => {
    const val = lodash.isFunction(caps[key]) ? caps[key]() : caps[key];

    if (lodash.isArray(val)) {
      val.forEach(p => {
        allCapValues.push(`${p}`.trim());
      });
    } else if (lodash.isString(val)) {
      val.split(',').forEach(p => {
        allCapValues.push(p.trim());
      });
    }
  });

  return allCapValues;
};
/**
 * Extract repetitive capabilities into list.
 * Key is checked, but the value is free
 * @param caps
 * @param prefix
 * @returns {Array}
 */


var flatCababilities$1 = (caps, prefix) => {
  const result = [];
  let capNames = [];

  for (const name of Object.keys(caps)) {
    if (name.startsWith(prefix)) {
      capNames.push(name);
    }
  }

  capNames = capNames.sort();

  if (capNames.length === 1 && capNames[0] === prefix) {
    const val = toJsonWeak(caps[capNames[0]]);

    if (lodash.isArray(val)) {
      val.forEach(entry => result.push(entry));
    } else {
      result.push(val);
    }
  } else {
    const regexpPrefixAndGroup = new RegExp(`^${prefix}\\.\\d+`);
    let currentGroup;
    let currentObject = {};

    for (const capName of capNames) {
      if (capName === prefix) {
        throw new Error(`Incorrect structure. Global definition must be unique. See Capability ${capName}`);
      }

      if (capName.charAt(prefix.length) !== '.') {
        debug$f(`From flatten result skipped capability ${capName} using prefix ${prefix}`);
        continue;
      }

      let capPrefixAndGroup = capName.match(regexpPrefixAndGroup);
      capPrefixAndGroup = capPrefixAndGroup && capPrefixAndGroup.length ? capPrefixAndGroup[0] : prefix;

      if (capPrefixAndGroup === capName) {
        const val = toJsonWeak(caps[capName]);
        result.push(val);
      } else {
        if (capPrefixAndGroup && capName.charAt(capPrefixAndGroup.length) !== '.') {
          throw new Error(`Capability name invalid. No valid grouping found in capability ${capName} using prefix ${prefix}`);
        }

        const key = capName.substr(capPrefixAndGroup.length + 1);

        if (!key.length) {
          throw new Error(`Capability name invalid. No key after grouping in capability ${capName} using prefix ${prefix}`);
        }

        if (currentGroup && currentGroup !== capPrefixAndGroup) {
          result.push(currentObject);
          currentObject = {};
        }

        currentObject[key] = toJsonWeak(caps[capName]);
        currentGroup = capPrefixAndGroup;
      }
    }

    if (currentObject && currentGroup) {
      result.push(currentObject);
      currentObject = null;
      currentGroup = null;
    }
  }

  return result;
};

var CapabilitiesUtils = {
  getAllCapValues: getAllCapValues$1,
  flatCababilities: flatCababilities$1
};

const debug$e = debug$l('botium-core-Precompilers');
const {
  isJsonObject
} = Utils;
const PROVIDERS = {
  JSON_TO_JSON_JSONPATH: JsonToJson,
  SCRIPT: Script,
  MARKDOWN_RASA: MarkdownRasa
};
const CAPABILITY_PREFIX = 'PRECOMPILERS';
const {
  flatCababilities
} = CapabilitiesUtils;

var execute = (scriptBuffer, options) => {
  const {
    caps,
    filename
  } = options;
  const ownCaps = flatCababilities(caps, CAPABILITY_PREFIX);

  if (Buffer.isBuffer(scriptBuffer)) {
    scriptBuffer = scriptBuffer.toString();
  }

  for (const capSuffixAndVal of ownCaps) {
    if (!capSuffixAndVal.NAME) {
      debug$e(`Precompiler name not defined in ${util.inspect(capSuffixAndVal)}`);
      return null;
    }

    const provider = PROVIDERS[capSuffixAndVal.NAME];

    if (!provider) {
      throw new Error(`Precompiler ${util.inspect(capSuffixAndVal.NAME)} not found using caps ${util.inspect(capSuffixAndVal)}`);
    }

    const result = provider.precompile(caps, scriptBuffer, capSuffixAndVal, filename);

    if (result) {
      if (!result.scriptBuffer) {
        return null;
      }

      if (isJsonObject(result.scriptBuffer, false)) {
        result.scriptBuffer = JSON.stringify(result.scriptBuffer);
      }

      result.precompiler = capSuffixAndVal.NAME; // dont let chain the precompilers. It looks more robust

      return result;
    }
  }
};

var precompilers = {
  execute: execute
};

var CompilerBase_1 = class CompilerBase {
  constructor({
    AddConvos,
    AddPartialConvos,
    AddUtterances,
    AddScriptingMemories,
    GetPartialConvos,
    IsAsserterValid,
    IsLogicHookValid,
    IsUserInputValid,
    scriptingEvents
  }, caps = {}) {
    this.context = {
      AddConvos,
      AddPartialConvos,
      AddUtterances,
      AddScriptingMemories,
      GetPartialConvos,
      IsAsserterValid,
      IsLogicHookValid,
      IsUserInputValid,
      scriptingEvents
    };
    this.caps = caps;
  }

  Validate() {}

  GetHeaders(scriptBuffer) {
    const convos = this.Compile(scriptBuffer);

    if (convos) {
      return convos.map(convo => convo.header);
    } else {
      return [];
    }
  }

  Compile(scriptBuffer, scriptType) {
    throw new Error('not implemented');
  }

  Decompile(convos) {
    throw new Error('not implemented');
  }

  _AssertCapabilityExists(cap) {
    if (!this.caps[cap]) {
      throw new Error(`Capability property ${cap} not set`);
    }
  }

  _GetOptionalCapability(cap, def = null) {
    if (lodash.isUndefined(this.caps[cap])) {
      return def;
    }

    return this.caps[cap];
  }

  _GetCapabilitiesByPrefix(prefix) {
    const result = {};
    Object.keys(this.caps).forEach(key => {
      if (key.startsWith(prefix)) {
        result[key] = this.caps[key];
      }
    });
    return result;
  }

};

var Utterance_1 = class Utterance {
  constructor(fromJson = {}) {
    this.name = fromJson.name;
    this.sourceTag = fromJson.sourceTag;
    this.utterances = [];

    if (fromJson.utterances && lodash.isArray(fromJson.utterances)) {
      this.utterances = fromJson.utterances;
    } else if (fromJson.utterances) {
      this.utterances.push(fromJson.utterances);
    }
  }

  toString() {
    return this.name + (this.sourceTag ? ` (${util.inspect(this.sourceTag)})` : '') + ': ' + this.utterances.join('|');
  }

};

const debug$d = debug$l('botium-core-CompilerXlsx');
const {
  Convo: Convo$5
} = Convo_1;
const {
  linesToConvoStep: linesToConvoStep$4,
  convoStepToLines: convoStepToLines$1,
  validateConvo: validateConvo$1
} = helper;
var CompilerXlsx_1 = class CompilerXlsx extends CompilerBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
    this.colnames = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
  }

  _splitSheetnames(sheetnames) {
    if (sheetnames) return sheetnames.split(/\s*[;,|]\s*/);
  }

  _filterSheetnames(sheetnames, selectors) {
    const filteredSheetnames = sheetnames.filter(sheetname => !!selectors.find(selector => selector === '*' || sheetname === selector));
    debug$d(`_filterSheetnames(sheetnames: ${JSON.stringify(sheetnames)}, selectors: ${JSON.stringify(selectors)}, filteredSheetnames: ${JSON.stringify(filteredSheetnames)})`);
    return filteredSheetnames;
  }

  Validate() {
    super.Validate();

    if (this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] !== undefined) {
      if (lodash.isString(this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]) && this.colnames.findIndex(c => c === this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]) < 0) {
        throw new Error(`SCRIPTING_XLSX_STARTCOL ${this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]} invalid (A-Z)`);
      } else if (this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] < 1 || this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL] > this.colnames.length) {
        throw new Error(`SCRIPTING_XLSX_STARTCOL ${this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]} invalid (1-${this.colnames.length})`);
      }
    }
  }

  Compile(scriptBuffer, scriptType = Constants.SCRIPTING_TYPE_CONVO) {
    const workbook = xlsx.read(scriptBuffer, {
      type: 'buffer'
    });
    if (!workbook) throw new Error('Workbook not readable');
    debug$d(`Loaded XLSX with Props: ${workbook.Props ? JSON.stringify(workbook.Props) : '<none>'}`);
    const eol = this.caps[Capabilities.SCRIPTING_XLSX_EOL_WRITE];
    const maxEmptyRowCount = 10;
    let sheetnames = [];

    if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES]) {
        sheetnames = this._filterSheetnames(workbook.SheetNames, this._splitSheetnames(this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES]));
      } else {
        sheetnames = workbook.SheetNames.filter(s => (s.toLowerCase().indexOf('convo') >= 0 || s.toLowerCase().indexOf('dialog') >= 0) && s.toLowerCase().indexOf('partial') < 0) || [];
      }
    } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]) {
        sheetnames = this._filterSheetnames(workbook.SheetNames, this._splitSheetnames(this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_PCONVOS]));
      } else {
        sheetnames = workbook.SheetNames.filter(s => s.toLowerCase().indexOf('partial') >= 0) || [];
      }
    } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]) {
        sheetnames = this._filterSheetnames(workbook.SheetNames, this._splitSheetnames(this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_UTTERANCES]));
      } else {
        sheetnames = workbook.SheetNames.filter(s => s.toLowerCase().indexOf('utter') >= 0) || [];
      }
    } else if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
      if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_SCRIPTING_MEMORY]) {
        sheetnames = this._filterSheetnames(workbook.SheetNames, this._splitSheetnames(this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES_SCRIPTING_MEMORY]));
      } else {
        sheetnames = workbook.SheetNames.filter(s => s.toLowerCase().indexOf('memory') >= 0 || s.toLowerCase().indexOf('scripting') >= 0) || [];
      }
    } else {
      throw Error(`Invalid script type ${scriptType}`);
    }

    debug$d(`sheet names for ${scriptType}: ${util.inspect(sheetnames)}`);
    const scriptResults = [];
    sheetnames.forEach(sheetname => {
      const sheet = workbook.Sheets[sheetname];
      if (!sheet) return;

      let {
        rowindex,
        colindex,
        hasNameCol
      } = this._findOrigin(sheet, scriptType);

      debug$d(`evaluating sheet name for ${scriptType}: ${util.inspect(sheetname)}, rowindex ${rowindex}, colindex ${colindex}`);

      if (scriptType === Constants.SCRIPTING_TYPE_CONVO || scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        const parseCell = (sender, content) => {
          if (!content) return {
            messageText: ''
          };
          if (!lodash.isString(content)) content = '' + content;
          let eolSplit = null;
          let lines = [];

          if (content.indexOf('\n') >= 0) {
            eolSplit = '\n';
          } else if (content.indexOf('\r') >= 0) {
            eolSplit = '\r';
          }

          if (eolSplit) {
            lines = content.split(eolSplit).map(l => l.trim()).filter(l => l);
          } else {
            lines = [content.trim()];
          }

          return linesToConvoStep$4(lines, sender, this.context, eol);
        };

        const _extractRow = rowindex => {
          const cell1 = this.colnames[colindex] + rowindex;
          const cell1Value = sheet[cell1] && sheet[cell1].v || null;
          const cell2 = this.colnames[colindex + 1] + rowindex;
          const cell2Value = sheet[cell2] && sheet[cell2].v || null;
          const cell3 = this.colnames[colindex + 2] + rowindex;
          const cell3Value = sheet[cell3] && sheet[cell3].v || null;

          if (hasNameCol) {
            return {
              nameCell: cell1,
              nameCellValue: cell1Value,
              meCell: cell2,
              meCellValue: cell2Value,
              botCell: cell3,
              botCellValue: cell3Value
            };
          } else {
            return {
              nameCell: null,
              nameCellValue: null,
              meCell: cell1,
              meCellValue: cell1Value,
              botCell: cell2,
              botCellValue: cell2Value
            };
          }
        };

        let questionAnswerMode = this._GetOptionalCapability(Capabilities.SCRIPTING_XLSX_MODE);

        if (questionAnswerMode !== null) {
          questionAnswerMode = questionAnswerMode === 'QUESTION_ANSWER';
          debug$d(`questionAnswerMode to ${questionAnswerMode} (capability)`);
        } else {
          let emptyRowCount = 0;
          let index = 0;
          const foundQARows = [];
          const foundConvoRows = [];

          while (emptyRowCount <= maxEmptyRowCount) {
            const {
              meCell,
              meCellValue,
              botCell,
              botCellValue
            } = _extractRow(rowindex + index);

            if (!meCellValue && !botCellValue) {
              emptyRowCount++;
            } else if (meCellValue && botCellValue) {
              foundQARows.push(meCell);
            } else if (meCellValue && !botCellValue) {
              foundConvoRows.push(meCell);
            } else if (!meCellValue && botCellValue) {
              foundConvoRows.push(botCell);
            }

            index++;
          }

          if (foundQARows.length > 0 && foundConvoRows.length > 0) {
            throw new Error(`Excel sheet "${sheetname}" invalid. Detected intermixed Q&A sections (for instance ${foundQARows.slice(0, 3).join(',')}) and convo sections (for instance ${foundConvoRows.slice(0, 3).join(',')})`);
          } else if (foundQARows.length > 0 && foundConvoRows.length === 0) {
            questionAnswerMode = true;
            debug$d('questionAnswerMode to true (question-answer row found)');
          } else {
            questionAnswerMode = false;
            debug$d('questionAnswerMode to false (no question-answer row found)');
          }
        }

        const convoResults = [];
        let currentConvo = [];
        let currentConvoName = null;
        let emptyRowCount = 0;
        let startrowindex = -1;

        while (true) {
          const {
            nameCellValue,
            meCell,
            meCellValue,
            botCell,
            botCellValue
          } = _extractRow(rowindex);

          if (questionAnswerMode) {
            if (meCellValue || botCellValue) {
              currentConvo = [];
              currentConvo.push(Object.assign({
                sender: 'me',
                stepTag: 'Cell ' + meCell
              }, parseCell('me', meCellValue)));
              startrowindex = rowindex;
              currentConvo.push(Object.assign({
                sender: 'bot',
                stepTag: 'Cell ' + botCell
              }, parseCell('bot', botCellValue)));
              convoResults.push(new Convo$5(this.context, {
                header: {
                  name: nameCellValue || null,
                  sheetname,
                  colindex,
                  rowindex: startrowindex
                },
                conversation: currentConvo
              }));
            } else {
              emptyRowCount++;
            }
          } else {
            if (currentConvo.length === 0) {
              currentConvoName = nameCellValue || null;
            }

            if (meCellValue) {
              currentConvo.push(Object.assign({
                sender: 'me',
                stepTag: 'Cell ' + meCell
              }, parseCell('me', meCellValue)));
              if (startrowindex < 0) startrowindex = rowindex;
              emptyRowCount = 0;
            } else if (botCellValue) {
              currentConvo.push(Object.assign({
                sender: 'bot',
                stepTag: 'Cell ' + botCell
              }, parseCell('bot', botCellValue)));
              if (startrowindex < 0) startrowindex = rowindex;
              emptyRowCount = 0;
            } else {
              if (currentConvo.length > 0) {
                convoResults.push(new Convo$5(this.context, {
                  header: {
                    name: currentConvoName,
                    sheetname,
                    colindex,
                    rowindex: startrowindex
                  },
                  conversation: currentConvo
                }));
              }

              currentConvo = [];
              currentConvoName = null;
              startrowindex = -1;
              emptyRowCount++;
            }
          }

          rowindex++;
          if (emptyRowCount > maxEmptyRowCount) break;
        }

        if (convoResults.length > 0) {
          const formatLength = Math.max(3, `${convoResults[convoResults.length - 1].header.rowindex}`.length);
          const formatBase = '0'.repeat(formatLength);

          const formatRowIndex = rowindex => (formatBase + `${rowindex}`).slice(-1 * formatLength);

          convoResults.forEach(convo => {
            if (!convo.header.name) {
              convo.header.name = `${convo.header.sheetname}-${this.colnames[convo.header.colindex]}${formatRowIndex(convo.header.rowindex)}`;
            }

            convo.header.sort = convo.header.name;
            scriptResults.push(convo);
          });
        }
      }

      if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        let currentUtterance = null;
        let emptylines = 0;

        while (true) {
          const nameCell = this.colnames[colindex] + rowindex;
          const uttCell = this.colnames[colindex + 1] + rowindex;

          if (sheet[nameCell] && sheet[nameCell].v && sheet[uttCell] && sheet[uttCell].v) {
            currentUtterance = new Utterance_1({
              name: sheet[nameCell].v,
              utterances: [`${sheet[uttCell].v}`]
            });
            scriptResults.push(currentUtterance);
            emptylines = 0;
          } else if (sheet[uttCell] && sheet[uttCell].v) {
            if (currentUtterance) currentUtterance.utterances.push(`${sheet[uttCell].v}`);
            emptylines = 0;
          } else {
            currentUtterance = null;
            emptylines++;
          }

          rowindex++;
          if (emptylines > maxEmptyRowCount) break;
        }
      }

      if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
        const variableNames = [];
        let colindexTemp = colindex + 1;

        while (true) {
          const variableNameCell = this.colnames[colindexTemp] + rowindex;

          if (sheet[variableNameCell] && sheet[variableNameCell].v) {
            variableNames.push(sheet[variableNameCell].v);
          } else {
            break;
          }

          colindexTemp++;
        }

        rowindex += 1;

        while (true) {
          const caseNameCell = this.colnames[colindex] + rowindex;

          if (sheet[caseNameCell] && sheet[caseNameCell].v) {
            const caseName = sheet[caseNameCell].v;
            const values = {};

            for (let i = 0; i < variableNames.length; i++) {
              const variableValueCell = this.colnames[colindex + 1 + i] + rowindex;

              if (sheet[variableValueCell] && sheet[variableValueCell].v) {
                values[variableNames[i]] = sheet[variableValueCell].v.toString();
              } else {
                values[variableNames[i]] = null;
              }
            }

            rowindex += 1;
            scriptResults.push({
              header: {
                name: caseName
              },
              values: values
            });
          } else {
            break;
          }
        }
      }
    });

    if (scriptResults && scriptResults.length > 0) {
      if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
        this.context.AddConvos(scriptResults);
      } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        this.context.AddPartialConvos(scriptResults);
      } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        this.context.AddUtterances(scriptResults);
      } else if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
        this.context.AddScriptingMemories(scriptResults);
      }

      return scriptResults;
    }
  }

  Decompile(convos) {
    const eol = this.caps[Capabilities.SCRIPTING_XLSX_EOL_WRITE];
    let sheetname = 'Botium';

    if (this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES]) {
      sheetname = this._splitSheetnames(this.caps[Capabilities.SCRIPTING_XLSX_SHEETNAMES])[0];
    }

    const data = [];
    const errors = [];

    if (convos) {
      for (let i = 0; i < convos.length; i++) {
        const convo = convos[i];
        if (!convo.conversation) return;
        const validationResult = validateConvo$1(convo);

        if (validationResult.errors.length > 0) {
          errors.push(...validationResult.errors.map(e => new Error(`Convo ${i + 1} ${e.message}`)));
        }

        convo.conversation.forEach(step => {
          let cellContent = '';
          const stepLines = convoStepToLines$1(step);
          if (stepLines && stepLines.length > 0) cellContent = stepLines.join(eol);
          data.push({
            [step.sender]: cellContent
          });
        });
        data.push({});
      }
    }

    if (errors.length > 0) {
      throw new Error(errors.map(e => e.message).join(' - '));
    }

    const wb = xlsx.utils.book_new();
    const ws = xlsx.utils.json_to_sheet(data, {
      header: ['me', 'bot']
    });
    xlsx.utils.book_append_sheet(wb, ws, sheetname);
    const xlsxOutput = xlsx.write(wb, {
      type: 'buffer'
    });
    return xlsxOutput;
  }

  _get(sheet, rowindex, colindex) {
    const cell = this.colnames[colindex] + rowindex;
    const cellValue = sheet[cell] && sheet[cell].v;
    return cellValue;
  }

  _findOrigin(sheet, scriptType) {
    let rowindex = this.caps[Capabilities.SCRIPTING_XLSX_STARTROW];
    let colindex = this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL];
    let hasNameCol = lodash.has(this.caps, Capabilities.SCRIPTING_XLSX_HASNAMECOL) ? !!this.caps[Capabilities.SCRIPTING_XLSX_HASNAMECOL] : null;

    if (lodash.isString(this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL])) {
      colindex = this.colnames.findIndex(c => c === this.caps[Capabilities.SCRIPTING_XLSX_STARTCOL]);
    } else if (colindex !== undefined) {
      colindex = colindex - 1;
    }

    if (rowindex === undefined && colindex === undefined) {
      // eslint-disable-next-line no-labels
      NestedLoop: for (let cr = 1; cr < 1000; cr++) {
        for (let cc = 0; cc < this.colnames.length; cc++) {
          if (this._get(sheet, cr, cc)) {
            if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
              if (cc > 0 && this._get(sheet, cr + 1, cc - 1)) {
                rowindex = cr;
                colindex = cc - 1; // eslint-disable-next-line no-labels

                break NestedLoop;
              }
            } else {
              rowindex = cr;
              colindex = cc; // eslint-disable-next-line no-labels

              break NestedLoop;
            }
          }
        }
      }

      if (scriptType !== Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
        if (rowindex !== undefined && this.caps[Capabilities.SCRIPTING_XLSX_HASHEADERS]) {
          rowindex++;
        }
      }
    } else if (rowindex === undefined && colindex !== undefined) {
      for (let i = 1; i < 1000; i++) {
        if (this._get(sheet, i, colindex)) {
          rowindex = i;
          break;
        }
      }

      if (this.caps[Capabilities.SCRIPTING_XLSX_HASHEADERS]) {
        rowindex++;
      }
    } else if (rowindex !== undefined && colindex === undefined) {
      for (let i = 0; i < this.colnames.length; i++) {
        if (this._get(sheet, rowindex, i)) {
          colindex = i;
          break;
        }
      }
    }

    if (lodash.isNull(hasNameCol)) {
      if (scriptType === Constants.SCRIPTING_TYPE_CONVO || scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        if (this.caps[Capabilities.SCRIPTING_XLSX_HASHEADERS]) {
          if (this._get(sheet, rowindex - 1, colindex) && this._get(sheet, rowindex - 1, colindex + 1) && this._get(sheet, rowindex - 1, colindex + 2)) {
            hasNameCol = true;
          }
        }
      }
    }

    return {
      rowindex,
      colindex,
      hasNameCol
    };
  }

};

const {
  ConvoHeader,
  Convo: Convo$4
} = Convo_1;
const {
  linesToConvoStep: linesToConvoStep$3,
  convoStepToLines,
  validateConvo,
  validSenders: validSenders$2
} = helper;
var CompilerTxt_1 = class CompilerTxt extends CompilerBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
    this.eol = caps[Capabilities.SCRIPTING_TXT_EOL];
  }

  Validate() {
    super.Validate();

    this._AssertCapabilityExists(Capabilities.SCRIPTING_TXT_EOL);
  }

  GetHeaders(scriptBuffer) {
    let scriptData = scriptBuffer;
    if (Buffer.isBuffer(scriptBuffer)) scriptData = scriptData.toString();
    const lines = scriptData.split(this.eol);
    const header = {};

    if (lines && !lines[0].startsWith('#')) {
      header.name = lines[0];
    }

    return new ConvoHeader(header);
  }

  Compile(scriptBuffer, scriptType = Constants.SCRIPTING_TYPE_CONVO) {
    let scriptData = scriptBuffer;
    if (Buffer.isBuffer(scriptBuffer)) scriptData = scriptData.toString();

    const lines = lodash.map(scriptData.split(this.eol), line => line.trim());

    if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
      return this._compileConvo(lines, false);
    } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
      return this._compileConvo(lines, true);
    } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
      return this._compileUtterances(lines);
    } else if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
      return this._compileScriptingMemory(lines);
    } else {
      throw Error(`Invalid script type ${scriptType}`);
    }
  }

  _compileConvo(lines, isPartial = false) {
    const convo = {
      header: {},
      conversation: []
    };
    let currentLineIndex = 0;
    let currentLines = [];
    let convoStepSender = null;
    let convoStepChannel = null;
    let convoStepLineIndex = null;

    const parseMsg = lines => {
      lines = lines || [];
      return linesToConvoStep$3(lines, convoStepSender, this.context, this.eol);
    };

    const pushPrev = () => {
      if (convoStepSender && currentLines) {
        const convoStep = {
          sender: convoStepSender,
          channel: convoStepChannel,
          stepTag: 'Line ' + convoStepLineIndex
        };
        Object.assign(convoStep, parseMsg(currentLines));
        convo.conversation.push(convoStep);
      } else if (!convoStepSender && currentLines) {
        convo.header.name = currentLines[0];

        if (currentLines.length > 1) {
          convo.header.description = currentLines.slice(1).join(this.eol);
        }
      }
    };

    const isValidTagLine = line => {
      if (!line || !line.startsWith('#')) return false;
      const sender = line.substr(1).split(' ')[0];
      return validSenders$2.includes(sender);
    };

    lines.forEach(line => {
      currentLineIndex++;
      line = line.trim();

      if (isValidTagLine(line)) {
        pushPrev();
        convoStepSender = line.substr(1).trim();
        convoStepChannel = null;
        convoStepLineIndex = currentLineIndex;

        if (convoStepSender.indexOf(' ') > 0) {
          convoStepChannel = convoStepSender.substr(convoStepSender.indexOf(' ') + 1).trim();
          convoStepSender = convoStepSender.substr(0, convoStepSender.indexOf(' ')).trim();
        }

        currentLines = [];
      } else {
        currentLines.push(line);
      }
    });
    pushPrev();
    const result = [new Convo$4(this.context, convo)];

    if (isPartial) {
      this.context.AddPartialConvos(result);
    } else {
      this.context.AddConvos(result);
    }

    return result;
  }

  _compileUtterances(lines) {
    if (lines && lines.length > 0) {
      const result = [new Utterance_1({
        name: lines[0],
        utterances: lines.length > 1 ? lines.slice(1) : []
      })];
      this.context.AddUtterances(result);
      return result;
    }
  }

  _compileScriptingMemory(lines) {
    if (lines && lines.length > 1) {
      const names = lines[0].split('|').map(name => name.trim()).slice(1);
      const scriptingMemories = [];

      for (let row = 1; row < lines.length; row++) {
        if (!lines[row] || lines[row].length === 0) continue;
        const rawRow = lines[row].split('|').map(name => name.trim());
        const caseName = rawRow[0];
        const values = rawRow.slice(1);
        const json = {};

        for (let col = 0; col < names.length; col++) {
          json[names[col]] = values[col];
        }

        const scriptingMemory = {
          header: {
            name: caseName
          },
          values: json
        };
        scriptingMemories.push(scriptingMemory);
      }

      this.context.AddScriptingMemories(scriptingMemories);
      return scriptingMemories;
    }
  }

  Decompile(convos) {
    if (convos.length > 1) {
      throw new Error('only one convo per script');
    }

    const convo = convos[0];
    const validationResult = validateConvo(convo);

    if (validationResult.errors.length > 0) {
      throw new Error(validationResult.errors.map(e => e.message).join(' - '));
    }

    let script = '';

    if (convo.header.name) {
      script += convo.header.name + this.eol;
    }

    if (convo.header.description) {
      script += convo.header.description + this.eol;
    }

    convo.conversation.forEach(step => {
      script += this.eol;
      script += '#' + step.sender;

      if (step.channel && step.channel !== 'default') {
        script += ' ' + step.channel;
      }

      script += this.eol;
      const stepLines = convoStepToLines(step);
      if (stepLines && stepLines.length > 0) script += stepLines.join(this.eol) + this.eol;
    });
    return script;
  }

};

const debug$c = debug$l('botium-core-CompilerCsv');
const {
  Convo: Convo$3
} = Convo_1;
const {
  linesToConvoStep: linesToConvoStep$2
} = helper;
const DELIMITERS_CHECK = [',', ';', '|', '\t'];
const DEFAULT_DELIMITER = ',';
const DEFAULT_QA_COLUMN_QUESTION = 0;
const DEFAULT_QA_COLUMN_ANSWER = 1;
const DEFAULT_MULTIROW_COLUMN_CONVERSATION = 0;
const DEFAULT_MULTIROW_COLUMN_SENDER = 1;
const DEFAULT_MULTIROW_COLUMN_TEXT = 2;

const _findColIndex = (header, colName) => {
  if (lodash.isString(colName)) {
    const result = header.findIndex(h => h === colName);
    if (result >= 0) return result;
    throw new Error(`Column name ${colName} not found.`);
  }

  if (lodash.isNumber(colName)) {
    return colName;
  }

  throw new Error(`Column ${colName} not found.`);
};

var CompilerCsv_1 = class CompilerCsv extends CompilerBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
  }

  Validate() {
    this._AssertCapabilityExists(Capabilities.SCRIPTING_CSV_QUOTE);

    this._AssertCapabilityExists(Capabilities.SCRIPTING_CSV_ESCAPE);

    return super.Validate();
  }

  Compile(scriptBuffer, scriptType = Constants.SCRIPTING_TYPE_CONVO) {
    const scriptData = Buffer.isBuffer(scriptBuffer) ? scriptBuffer.toString() : scriptBuffer;

    if (scriptData.length === 0) {
      return [];
    }

    let delimiter = this._GetOptionalCapability(Capabilities.SCRIPTING_CSV_DELIMITER);

    if (!delimiter) {
      const firstline = scriptData.split('\n')[0].trim();

      for (const d of DELIMITERS_CHECK) {
        if (firstline.indexOf(d) >= 0) {
          delimiter = d;
          break;
        }
      }

      if (!delimiter) {
        delimiter = DEFAULT_DELIMITER;
        debug$c(`Couldn't detect column delimiter automatically, using "${delimiter}" by default. Please set the SCRIPTING_CSV_DELIMITER capability.`);
      } else {
        debug$c(`Detected column delimiter automatically, using "${delimiter}".`);
      }
    }

    let rows;

    try {
      rows = sync(scriptData, {
        delimiter,
        escape: this.caps[Capabilities.SCRIPTING_CSV_ESCAPE],
        quote: this.caps[Capabilities.SCRIPTING_CSV_QUOTE],
        columns: false
      });
    } catch (err) {
      throw new Error(`Invalid CSV: ${err.message || err}`);
    }

    if (rows.length === 0) {
      return [];
    }

    if (rows[0].length === 1) {
      debug$c('Found 1-column CSV file, treating it as utterance file');

      if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        const result = [{
          name: rows[0][0],
          utterances: rows.slice(1).map(r => r[0])
        }];
        this.context.AddUtterances(result);
        return result;
      } else {
        return [];
      }
    }

    if (scriptType !== Constants.SCRIPTING_TYPE_CONVO && scriptType !== Constants.SCRIPTING_TYPE_PCONVO) {
      return [];
    }

    let header = null;

    if (rows.length > 0 && this.caps[Capabilities.SCRIPTING_CSV_SKIP_HEADER]) {
      header = rows[0];
      rows = rows.slice(1);
    }

    if (rows.length === 0) {
      return [];
    }

    const lineNumberBase = this.caps[Capabilities.SCRIPTING_CSV_SKIP_HEADER] ? 2 : 1;

    if (rows[0].length === 2) {
      debug$c('Found 2-column CSV file, treating it as question/answer file');
      let colQuestion = DEFAULT_QA_COLUMN_QUESTION;
      let colAnswer = DEFAULT_QA_COLUMN_ANSWER;

      if (header) {
        if (this.caps[Capabilities.SCRIPTING_CSV_QA_COLUMN_QUESTION] !== undefined) {
          colQuestion = _findColIndex(header, this.caps[Capabilities.SCRIPTING_CSV_QA_COLUMN_QUESTION]);
        }

        if (this.caps[Capabilities.SCRIPTING_CSV_QA_COLUMN_ANSWER] !== undefined) {
          colAnswer = _findColIndex(header, this.caps[Capabilities.SCRIPTING_CSV_QA_COLUMN_ANSWER]);
        }
      }

      const convos = rows.map((row, i) => new Convo$3(this.context, {
        header: {
          name: `L${i + lineNumberBase}`
        },
        conversation: [Object.assign({}, linesToConvoStep$2([row[colQuestion]], 'me', this.context, undefined, true), {
          stepTag: `L${i + lineNumberBase}-Question`
        }), Object.assign({}, linesToConvoStep$2([row[colAnswer]], 'bot', this.context, undefined, true), {
          stepTag: `L${i + lineNumberBase}-Answer`
        })]
      }));

      if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
        this.context.AddConvos(convos);
      } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        this.context.AddPartialConvos(convos);
      }

      return convos;
    }

    if (rows[0].length >= 3) {
      debug$c('Found 3-column CSV file, treating it as multi-row conversation file');
      let colConversationId = DEFAULT_MULTIROW_COLUMN_CONVERSATION;
      let colSender = DEFAULT_MULTIROW_COLUMN_SENDER;
      let colText = DEFAULT_MULTIROW_COLUMN_TEXT;

      if (header) {
        if (this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_CONVERSATION_ID] !== undefined) {
          colConversationId = _findColIndex(header, this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_CONVERSATION_ID]);
        }

        if (this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_SENDER] !== undefined) {
          colSender = _findColIndex(header, this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_SENDER]);
        }

        if (this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_TEXT] !== undefined) {
          colText = _findColIndex(header, this.caps[Capabilities.SCRIPTING_CSV_MULTIROW_COLUMN_TEXT]);
        }
      }

      const conversationIds = lodash.uniq(rows.map(r => r[colConversationId]));

      const convos = conversationIds.map(conversationId => {
        const convoRows = rows.map((row, i) => {
          if (row[colConversationId] === conversationId) {
            return Object.assign({}, linesToConvoStep$2([row[colText]], row[colSender], this.context, undefined, true), {
              stepTag: `L${i + lineNumberBase}`
            });
          }

          return null;
        }).filter(c => c);
        return new Convo$3(this.context, {
          header: {
            name: conversationId
          },
          conversation: convoRows
        });
      });

      if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
        this.context.AddConvos(convos);
      } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        this.context.AddPartialConvos(convos);
      }

      return convos;
    }
  }

};

const debug$b = debug$l('botium-core-CompilerObject');
const {
  Convo: Convo$2
} = Convo_1;
const {
  linesToConvoStep: linesToConvoStep$1,
  validSenders: validSenders$1
} = helper;
var CompilerObjectBase_1 = class CompilerObjectBase extends CompilerBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
    this.eol = caps[Capabilities.SCRIPTING_TXT_EOL];
  }

  Validate() {
    super.Validate();

    this._AssertCapabilityExists(Capabilities.SCRIPTING_TXT_EOL);
  }

  GetHeaders(scriptBuffer) {
    debug$b('GetHeaders is not implemented!');
  }

  Deserialize(scriptData) {
    throw new Error('not implemented');
  }

  Compile(scriptBuffer, scriptType = Constants.SCRIPTING_TYPE_CONVO) {
    let scriptData = scriptBuffer;
    if (Buffer.isBuffer(scriptBuffer)) scriptData = scriptData.toString();
    scriptData = this.Deserialize(scriptData);
    const result = [];

    if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
      result.push(...this._compileConvo(scriptData.convos, false));
    } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
      result.push(...this._compileConvo(scriptData.partialConvos, true));
    } else if (scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
      result.push(...this._compileUtterances(scriptData.utterances));
    } else if (scriptType === Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY) {
      result.push(...this._compileScriptingMemory(scriptData.scriptingMemory));
    }

    return result;
  }

  _compileConvo(convos, isPartial = false) {
    const result = [];

    for (const convoRaw of convos || []) {
      const conversation = [];

      for (const [convoStepLineIndex, convoStepRaw] of convoRaw.steps.entries()) {
        const lineTag = `${convoStepLineIndex + 1}`.padStart(`${convoRaw.steps.length}`.length, '0');

        if (Object.keys(convoStepRaw).length > 1) {
          throw new Error(`Use just one from ${validSenders$1.join(',')} fields in step ${JSON.stringify(convoStepRaw)}`);
        }

        if (validSenders$1.findIndex(sender => convoStepRaw[sender]) < 0) {
          throw new Error(`Use ${validSenders$1.map(s => `'${s}'`).join(' or ')} field in step ${JSON.stringify(convoStepRaw)}`);
        }

        const convoStepSender = Object.keys(convoStepRaw)[0];
        const convoStepObject = convoStepRaw[convoStepSender];
        conversation.push(Object.assign({
          sender: convoStepSender,
          stepTag: 'Line ' + lineTag
        }, linesToConvoStep$1(convoStepObject, convoStepSender, this.context, this.eol)));
      }

      const convo = {
        header: {
          name: convoRaw.name,
          description: convoRaw.description
        },
        conversation
      };
      const toAdd = new Convo$2(this.context, convo);
      result.push(toAdd);

      if (isPartial) {
        this.context.AddPartialConvos([toAdd]);
      } else {
        this.context.AddConvos([toAdd]);
      }
    }

    return result;
  }

  _compileUtterances(utterancesRaw) {
    const result = [];
    const names = Object.keys(utterancesRaw || {});

    for (const name of names) {
      if (!lodash.isArray(utterancesRaw[name])) {
        throw new Error(`The '${name}' utterance has to be an array.`);
      }

      result.push(new Utterance_1({
        name,
        utterances: utterancesRaw[name].map(u => `${u}`)
      }));
    }

    this.context.AddUtterances(result);
    return result;
  }

  _compileScriptingMemory(lines) {
    if (lines && lines.length > 0) {
      if (lodash.isString(lines[0])) {
        if (lines.length > 1) {
          const names = lines[0].split('|').map(name => name.trim()).slice(1);
          const scriptingMemories = [];

          for (let row = 1; row < lines.length; row++) {
            const rawRow = lines[row].split('|').map(name => name.trim());
            const caseName = rawRow[0];
            const values = rawRow.slice(1);
            const json = {};

            for (let col = 0; col < names.length; col++) {
              json[names[col]] = values[col];
            }

            const scriptingMemory = {
              header: {
                name: caseName
              },
              values: json
            };
            scriptingMemories.push(scriptingMemory);
          }

          this.context.AddScriptingMemories(scriptingMemories);
          return scriptingMemories;
        }
      } else {
        this.context.AddScriptingMemories(lines);
        return lines;
      }
    }

    return [];
  }

  Decompile(convos) {
    throw new Error('not implemented');
  }

};

var CompilerYaml_1 = class CompilerYaml extends CompilerObjectBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
  }

  Deserialize(scriptData) {
    return yaml.parse(scriptData);
  }

};

const {
  convoStepToObject
} = helper;
var CompilerJson_1 = class CompilerJson extends CompilerObjectBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
  }

  Deserialize(scriptData) {
    return JSON.parse(scriptData);
  }

  Decompile(convos) {
    const result = convos.map(convo => ({
      name: convo.header.name,
      description: convo.header.description,
      steps: convo.conversation.map(set => ({
        [set.sender]: convoStepToObject(set)
      }))
    }));
    return JSON.stringify({
      convos: result
    }, null, 2);
  }

};

const debug$a = debug$l('botium-core-CompilerMarkdown');
const md = new markdownIt();
const {
  Convo: Convo$1
} = Convo_1;
const {
  linesToConvoStep,
  validSenders,
  validateSender
} = helper;
var CompilerMarkdown_1 = class CompilerMarkdown extends CompilerBase_1 {
  constructor(context, caps = {}) {
    super(context, caps);
    this.eol = caps[Capabilities.SCRIPTING_TXT_EOL];
  }

  Validate() {
    super.Validate();

    this._AssertCapabilityExists(Capabilities.SCRIPTING_TXT_EOL);
  }

  Compile(scriptBuffer, scriptType = Constants.SCRIPTING_TYPE_CONVO) {
    if (Buffer.isBuffer(scriptBuffer)) scriptBuffer = scriptBuffer.toString();
    const parsed = md.parse(scriptBuffer, {});

    const _toStructuredMarkdown = parsed => {
      let depth = -1;
      const struct = [{
        children: []
      }, null, null, null, null, null];

      const _add = entry => {
        if (!struct[depth] || !struct[depth].children) throw new Error(`"${entry.markup}" not expected here (Line ${entry.map[0] + 1}): format invalid`);
        struct[depth].children.push(entry);
        entry.children = [];
        struct[depth + 1] = entry;
      };

      for (const entry of parsed) {
        if (entry.type === 'heading_open') {
          if (entry.tag === 'h1') {
            depth = 0;
          } else if (entry.tag === 'h2') {
            if (depth < 0 || depth > 1) {
              throw new Error(`"${entry.markup}" not expected here (Line ${entry.map[0] + 1}): expecting parent "#" for "${entry.markup}"`);
            }

            depth = 1;
          } else {
            debug$a(`Markdown entry "${util.inspect(entry)}" ignored. Unknown heading`);
          }
        } else if (entry.type === 'bullet_list_open') {
          if (depth < 1) {
            throw new Error(`"${entry.markup}" not expected here (Line ${entry.map[0] + 1}): expecting parent "##" for "${entry.markup}"`);
          }

          if (depth > 3) {
            throw new Error(`"${entry.markup}" not expected here (Line ${entry.map[0] + 1}): Bullet list depth 3 not supported`);
          }

          depth++;
        } else if (entry.type === 'bullet_list_close') {
          depth--;
        } else if (entry.type === 'inline') {
          _add(entry);
        }
      }

      return struct[0];
    };

    const structured = _toStructuredMarkdown(parsed);

    for (const convosOrUtterances of structured.children) {
      if (convosOrUtterances.content === 'Convos' && scriptType === Constants.SCRIPTING_TYPE_CONVO || convosOrUtterances.content === 'PartialConvos' && scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
        const convosBotium = [];

        for (const convo of convosOrUtterances.children) {
          const conversation = [];

          for (const step of convo.children) {
            const sender = step.content.toLowerCase();

            if (validateSender(sender)) {
              // handle both:
              //   - BUTTONS checkbutton|checkbutton2
              // and
              // - BUTTONS
              //   - checkbutton
              //   - checkbutton2
              conversation.push(Object.assign({
                sender,
                stepTag: 'Line ' + (step.map[0] + 1)
              }, linesToConvoStep(step.children.map(child => child.content + (child.children ? ' ' + child.children.map(child => child.content).join('|') : '')), sender, this.context, this.eol)));
            } else {
              debug$a(`Expected sender ${validSenders.map(s => `'${s}'`).join(' or ')} but found ${sender}`);
            }
          }

          convosBotium.push(new Convo$1(this.context, {
            header: {
              name: convo.content
            },
            conversation
          }));
        }

        if (scriptType === Constants.SCRIPTING_TYPE_CONVO) {
          this.context.AddConvos(convosBotium);
        } else if (scriptType === Constants.SCRIPTING_TYPE_PCONVO) {
          this.context.AddPartialConvos(convosBotium);
        }
      } else if (convosOrUtterances.content === 'Utterances' && scriptType === Constants.SCRIPTING_TYPE_UTTERANCES) {
        const utterancesBotium = [];

        for (const utteranceStruct of convosOrUtterances.children) {
          utterancesBotium.push(new Utterance_1({
            name: utteranceStruct.content,
            utterances: utteranceStruct.children.map(child => `${child.content}`)
          }));
        }

        this.context.AddUtterances(utterancesBotium);
      }
    }
  }

};

promise.shim();
const debug$9 = debug$l('botium-core-ScriptingProvider');
const {
  Convo,
  ConvoStep
} = Convo_1;
const {
  BotiumError: BotiumError$1,
  botiumErrorFromList,
  botiumErrorFromErr
} = BotiumError_1;
const {
  getMatchFunction
} = MatchFunctions;
const globPattern = '**/+(*.convo.txt|*.utterances.txt|*.pconvo.txt|*.scriptingmemory.txt|*.xlsx|*.xlsm|*.convo.csv|*.pconvo.csv|*.yaml|*.yml|*.json|*.md|*.markdown)';
const skipPattern = /^skip[.\-_]/i;

const p = (retryHelper, fn) => {
  const promise = () => new Promise((resolve, reject) => {
    try {
      resolve(fn());
    } catch (err) {
      reject(err);
    }
  });

  if (retryHelper) {
    return promiseRetry((retry, number) => {
      return promise().catch(err => {
        if (retryHelper.shouldRetry(err)) {
          debug$9(`Asserter trial #${number} failed, retry activated`);
          retry(err);
        } else {
          throw err;
        }
      });
    }, retryHelper.retrySettings);
  } else {
    return promise();
  }
};

const pnot = (retryHelper, fn, errTemplate) => {
  const promise = () => new Promise(async (resolve, reject) => {
    // eslint-disable-line no-async-promise-executor
    try {
      await fn();
      reject(errTemplate);
    } catch (err) {
      resolve();
    }
  });

  if (retryHelper) {
    return promiseRetry((retry, number) => {
      return promise().catch(() => {
        if (retryHelper.shouldRetry(errTemplate)) {
          debug$9(`Asserter trial #${number} failed, !retry activated`);
          retry(errTemplate);
        } else {
          throw errTemplate;
        }
      });
    }, retryHelper.retrySettings);
  } else {
    return promise();
  }
};

var ScriptingProvider_1 = class ScriptingProvider {
  constructor(caps) {
    this.caps = caps || lodash.cloneDeep(Defaults$1.Capabilities);
    this.compilers = {};
    this.convos = [];
    this.utterances = {};
    this.matchFn = null;
    this.asserters = {};
    this.globalAsserter = {};
    this.logicHooks = {};
    this.globalLogicHook = {};
    this.userInputs = {};
    this.partialConvos = {};
    this.scriptingMemories = [];
    this.scriptingEvents = {
      onConvoBegin: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onConvoBegin',
          logicHooks: convo.beginLogicHook || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onConvoEnd: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onConvoEnd',
          logicHooks: convo.endLogicHook || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onMeStart: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onMeStart',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onMePrepare: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onMePrepare',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onMeEnd: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onMeEnd',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onBotStart: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onBotStart',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onBotPrepare: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onBotPrepare',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      onBotEnd: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createLogicHookPromises({
          hookType: 'onBotEnd',
          logicHooks: convoStep.logicHooks || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      assertConvoBegin: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createAsserterPromises({
          asserterType: 'assertConvoBegin',
          asserters: convo.beginAsserter || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      assertConvoStep: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createAsserterPromises({
          asserterType: 'assertConvoStep',
          asserters: convoStep.asserters || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      assertConvoEnd: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createAsserterPromises({
          asserterType: 'assertConvoEnd',
          asserters: convo.endAsserter || [],
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      setUserInput: ({
        convo,
        convoStep,
        scriptingMemory,
        ...rest
      }) => {
        return this._createUserInputPromises({
          convo,
          convoStep,
          scriptingMemory,
          ...rest
        });
      },
      resolveUtterance: ({
        utterance,
        resolveEmptyIfUnknown
      }) => {
        return this._resolveUtterance({
          utterance,
          resolveEmptyIfUnknown
        });
      },
      assertBotResponse: (botresponse, tomatch, stepTag, meMsg) => {
        if (!lodash.isArray(tomatch)) {
          tomatch = [tomatch];
        }

        debug$9(`assertBotResponse ${stepTag} ${meMsg ? `(${meMsg}) ` : ''}BOT: ${botresponse} = ${tomatch} ...`);

        const found = lodash.find(tomatch, utt => this.matchFn(botresponse, utt));

        if (lodash.isNil(found)) {
          let message = `${stepTag}: Bot response `;
          message += meMsg ? `(on ${meMsg}) ` : '';
          message += botresponse ? '"' + botresponse + '"' : '<no response>';
          message += ' expected to match ';
          message += tomatch && tomatch.length > 1 ? 'one of ' : '';
          message += `${tomatch.map(e => e ? '"' + e + '"' : '<any response>').join(', ')}`;
          throw new BotiumError$1(message, {
            type: 'asserter',
            source: 'TextMatchAsserter',
            context: {
              stepTag
            },
            cause: {
              expected: tomatch,
              actual: botresponse,
              matchingMode: this.caps[Capabilities.SCRIPTING_MATCHING_MODE]
            }
          });
        }
      },
      assertBotNotResponse: (botresponse, nottomatch, stepTag, meMsg) => {
        if (!lodash.isArray(nottomatch)) {
          nottomatch = [nottomatch];
        }

        debug$9(`assertBotNotResponse ${stepTag} ${meMsg ? `(${meMsg}) ` : ''}BOT: ${botresponse} != ${nottomatch} ...`);

        const found = lodash.find(nottomatch, utt => this.matchFn(botresponse, utt));

        if (!lodash.isNil(found)) {
          let message = `${stepTag}: Bot response `;
          message += meMsg ? `(on ${meMsg}) ` : '';
          message += botresponse ? '"' + botresponse + '"' : '<no response>';
          message += ' expected NOT to match ';
          message += nottomatch && nottomatch.length > 1 ? 'one of ' : '';
          message += `${nottomatch.map(e => e ? '"' + e + '"' : '<any response>').join(', ')}`;
          throw new BotiumError$1(message, {
            type: 'asserter',
            source: 'TextMatchAsserter',
            context: {
              stepTag
            },
            cause: {
              not: true,
              expected: nottomatch,
              actual: botresponse,
              matchingMode: this.caps[Capabilities.SCRIPTING_MATCHING_MODE]
            }
          });
        }
      },
      fail: null
    };
    this.retryHelperAsserter = new RetryHelper_1(this.caps, 'ASSERTER');
    this.retryHelperLogicHook = new RetryHelper_1(this.caps, 'LOGICHOOK');
    this.retryHelperUserInput = new RetryHelper_1(this.caps, 'USERINPUT');
  }

  _createAsserterPromises({
    asserterType,
    asserters,
    convo,
    convoStep,
    scriptingMemory,
    ...rest
  }) {
    if (!this._isValidAsserterType(asserterType)) {
      throw Error(`Unknown asserterType ${asserterType}`);
    }

    const mapNot = {
      assertConvoBegin: 'assertNotConvoBegin',
      assertConvoStep: 'assertNotConvoStep',
      assertConvoEnd: 'assertNotConvoEnd'
    };

    const callAsserter = (asserterSpec, asserter, params) => {
      if (asserterSpec.not) {
        const notAsserterType = mapNot[asserterType];

        if (asserter[notAsserterType]) {
          return p(this.retryHelperAsserter, () => asserter[notAsserterType](params));
        } else {
          return pnot(this.retryHelperAsserter, () => asserter[asserterType](params), new BotiumError$1(`${convoStep.stepTag}: Expected asserter ${asserter.name || asserterSpec.name} with args "${params.args}" to fail`, {
            type: 'asserter',
            source: asserter.name || asserterSpec.name,
            params: {
              args: params.args
            },
            cause: {
              not: true,
              expected: 'failed',
              actual: 'not failed'
            }
          }));
        }
      } else {
        return p(this.retryHelperAsserter, () => asserter[asserterType](params));
      }
    };

    const convoAsserter = asserters.filter(a => this.asserters[a.name][asserterType]).map(a => callAsserter(a, this.asserters[a.name], {
      convo,
      convoStep,
      scriptingMemory,
      args: ScriptingMemory.applyToArgs(a.args, scriptingMemory, this.caps, rest.botMsg),
      isGlobal: false,
      ...rest
    }));
    const globalAsserter = Object.values(this.globalAsserter).filter(a => a[asserterType]).map(a => p(this.retryHelperAsserter, () => a[asserterType]({
      convo,
      convoStep,
      scriptingMemory,
      args: [],
      isGlobal: true,
      ...rest
    })));
    const allPromises = [...convoAsserter, ...globalAsserter];

    if (this.caps[Capabilities.SCRIPTING_ENABLE_MULTIPLE_ASSERT_ERRORS]) {
      return Promise.allSettled(allPromises).then(results => {
        const rejected = results.filter(result => result.status === 'rejected').map(result => result.reason);

        if (rejected.length) {
          throw botiumErrorFromList(rejected, {});
        }

        return results.filter(result => result.status === 'fulfilled').map(result => result.value);
      });
    }

    if (allPromises.length > 0) return Promise.all(allPromises).then(() => true);
    return Promise.resolve(false);
  }

  _createLogicHookPromises({
    hookType,
    logicHooks,
    convo,
    convoStep,
    scriptingMemory,
    ...rest
  }) {
    if (hookType !== 'onMeStart' && hookType !== 'onMePrepare' && hookType !== 'onMeEnd' && hookType !== 'onBotStart' && hookType !== 'onBotPrepare' && hookType !== 'onBotEnd' && hookType !== 'onConvoBegin' && hookType !== 'onConvoEnd') {
      throw Error(`Unknown hookType ${hookType}`);
    }

    const convoStepPromises = (logicHooks || []).filter(l => this.logicHooks[l.name][hookType]).map(l => p(this.retryHelperLogicHook, () => this.logicHooks[l.name][hookType]({
      convo,
      convoStep,
      scriptingMemory,
      args: ScriptingMemory.applyToArgs(l.args, scriptingMemory, this.caps, rest.botMsg),
      isGlobal: false,
      ...rest
    })));
    const globalPromises = Object.values(this.globalLogicHook).filter(l => l[hookType]).map(l => p(this.retryHelperLogicHook, () => l[hookType]({
      convo,
      convoStep,
      scriptingMemory,
      args: [],
      isGlobal: true,
      ...rest
    })));
    const allPromises = [...convoStepPromises, ...globalPromises];
    if (allPromises.length > 0) return Promise.all(allPromises).then(() => true);
    return Promise.resolve(false);
  }

  _createUserInputPromises({
    convo,
    convoStep,
    scriptingMemory,
    ...rest
  }) {
    const convoStepPromises = (convoStep.userInputs || []).filter(ui => this.userInputs[ui.name]).map(ui => p(this.retryHelperUserInput, () => this.userInputs[ui.name].setUserInput({
      convo,
      convoStep,
      scriptingMemory,
      args: ScriptingMemory.applyToArgs(ui.args, scriptingMemory, this.caps, rest.meMsg),
      ...rest
    })));
    if (convoStepPromises.length > 0) return Promise.all(convoStepPromises).then(() => true);
    return Promise.resolve(false);
  }

  _isValidAsserterType(asserterType) {
    return ['assertConvoBegin', 'assertConvoStep', 'assertConvoEnd'].some(t => asserterType === t);
  }

  _resolveUtterance({
    utterance,
    resolveEmptyIfUnknown = false
  }) {
    if (lodash.isString(utterance)) {
      if (this.utterances[utterance]) {
        return this.utterances[utterance].utterances;
      } else {
        const parts = utterance.split(' ');

        if (this.utterances[parts[0]]) {
          const uttArgs = parts.slice(1);
          return this.utterances[parts[0]].utterances.map(utt => util.format(utt, ...uttArgs));
        }
      }
    }

    if (resolveEmptyIfUnknown) return null;else return [utterance];
  }

  _buildScriptContext() {
    return {
      AddConvos: this.AddConvos.bind(this),
      AddUtterances: this.AddUtterances.bind(this),
      AddPartialConvos: this.AddPartialConvos.bind(this),
      AddScriptingMemories: this.AddScriptingMemories.bind(this),
      Match: this.Match.bind(this),
      IsAsserterValid: this.IsAsserterValid.bind(this),
      IsLogicHookValid: this.IsLogicHookValid.bind(this),
      IsUserInputValid: this.IsUserInputValid.bind(this),
      GetPartialConvos: this.GetPartialConvos.bind(this),
      scriptingEvents: {
        assertConvoBegin: this.scriptingEvents.assertConvoBegin.bind(this),
        assertConvoStep: this.scriptingEvents.assertConvoStep.bind(this),
        assertConvoEnd: this.scriptingEvents.assertConvoEnd.bind(this),
        resolveUtterance: this.scriptingEvents.resolveUtterance.bind(this),
        assertBotResponse: this.scriptingEvents.assertBotResponse.bind(this),
        assertBotNotResponse: this.scriptingEvents.assertBotNotResponse.bind(this),
        onConvoBegin: this.scriptingEvents.onConvoBegin.bind(this),
        onConvoEnd: this.scriptingEvents.onConvoEnd.bind(this),
        onMeStart: this.scriptingEvents.onMeStart.bind(this),
        onMePrepare: this.scriptingEvents.onMePrepare.bind(this),
        onMeEnd: this.scriptingEvents.onMeEnd.bind(this),
        onBotStart: this.scriptingEvents.onBotStart.bind(this),
        onBotPrepare: this.scriptingEvents.onBotPrepare.bind(this),
        onBotEnd: this.scriptingEvents.onBotEnd.bind(this),
        setUserInput: this.scriptingEvents.setUserInput.bind(this),
        fail: this.scriptingEvents.fail && this.scriptingEvents.fail.bind(this)
      }
    };
  }

  Build() {
    const CompilerXlsx = CompilerXlsx_1;
    this.compilers[Constants.SCRIPTING_FORMAT_XSLX] = new CompilerXlsx(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_XSLX].Validate();
    const CompilerTxt = CompilerTxt_1;
    this.compilers[Constants.SCRIPTING_FORMAT_TXT] = new CompilerTxt(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_TXT].Validate();
    const CompilerCsv = CompilerCsv_1;
    this.compilers[Constants.SCRIPTING_FORMAT_CSV] = new CompilerCsv(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_CSV].Validate();
    const CompilerYaml = CompilerYaml_1;
    this.compilers[Constants.SCRIPTING_FORMAT_YAML] = new CompilerYaml(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_YAML].Validate();
    const CompilerJson = CompilerJson_1;
    this.compilers[Constants.SCRIPTING_FORMAT_JSON] = new CompilerJson(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_JSON].Validate();
    const CompilerMarkdown = CompilerMarkdown_1;
    this.compilers[Constants.SCRIPTING_FORMAT_MARKDOWN] = new CompilerMarkdown(this._buildScriptContext(), this.caps);
    this.compilers[Constants.SCRIPTING_FORMAT_MARKDOWN].Validate();
    this.matchFn = getMatchFunction(this.caps[Capabilities.SCRIPTING_MATCHING_MODE]);
    const logicHookUtils = new LogicHookUtils_1({
      buildScriptContext: this._buildScriptContext(),
      caps: this.caps
    });
    this.asserters = logicHookUtils.asserters;
    this.globalAsserter = logicHookUtils.getGlobalAsserter();
    this.logicHooks = logicHookUtils.logicHooks;
    this.globalLogicHook = logicHookUtils.getGlobalLogicHook();
    this.userInputs = logicHookUtils.userInputs;
  }

  IsAsserterValid(name) {
    return this.asserters[name] || false;
  }

  IsLogicHookValid(name) {
    return this.logicHooks[name] || false;
  }

  IsUserInputValid(name) {
    return this.userInputs[name] || false;
  }

  Match(botresponse, utterance) {
    return this.matchFn(botresponse, utterance);
  }

  Compile(scriptBuffer, scriptFormat, scriptType) {
    const compiler = this.GetCompiler(scriptFormat);
    return compiler.Compile(scriptBuffer, scriptType);
  }

  Decompile(convos, scriptFormat) {
    const compiler = this.GetCompiler(scriptFormat);
    return compiler.Decompile(convos);
  }

  GetCompiler(scriptFormat) {
    const result = this.compilers[scriptFormat];
    if (result) return result;
    throw new Error(`No compiler found for scriptFormat ${scriptFormat}`);
  }

  ReadBotiumFilesFromDirectory(convoDir, globFilter) {
    const filelist = globby.sync(globPattern, {
      cwd: convoDir,
      gitignore: true
    });

    if (globFilter) {
      const filelistGlobbed = globby.sync(globFilter, {
        cwd: convoDir,
        gitignore: true
      });

      lodash.remove(filelist, file => filelistGlobbed.indexOf(file) < 0);
    }

    lodash.remove(filelist, file => {
      const isSkip = skipPattern.test(path.basename(file));
      if (isSkip) debug$9(`ReadBotiumFilesFromDirectory - skipping file '${file}'`);
      return isSkip;
    });

    return filelist;
  }

  ReadScriptsFromDirectory(convoDir, globFilter) {
    let filelist = [];
    const convoDirStats = fs.statSync(convoDir);

    if (convoDirStats.isFile()) {
      filelist = [path.basename(convoDir)];
      convoDir = path.dirname(convoDir);
    } else {
      filelist = this.ReadBotiumFilesFromDirectory(convoDir, globFilter);
    }

    debug$9(`ReadConvosFromDirectory(${convoDir}) found filenames: ${filelist}`);
    const dirConvos = [];
    const dirUtterances = [];
    const dirPartialConvos = [];
    const dirScriptingMemories = [];
    filelist.forEach(filename => {
      const {
        convos,
        utterances,
        pconvos,
        scriptingMemories
      } = this.ReadScript(convoDir, filename);
      if (convos) dirConvos.push(...convos);
      if (utterances) dirUtterances.push(...utterances);
      if (pconvos) dirPartialConvos.push(...pconvos);
      if (scriptingMemories) dirScriptingMemories.push(...scriptingMemories);
    });
    debug$9(`ReadConvosFromDirectory(${convoDir}) found convos:\n ${dirConvos.length ? dirConvos.join('\n') : 'none'}`);
    debug$9(`ReadConvosFromDirectory(${convoDir}) found utterances:\n ${dirUtterances.length ? lodash.map(dirUtterances, u => u).join('\n') : 'none'}`);
    debug$9(`ReadConvosFromDirectory(${convoDir}) found partial convos:\n ${dirPartialConvos.length ? dirPartialConvos.join('\n') : 'none'}`);
    debug$9(`ReadConvosFromDirectory(${convoDir}) scripting memories:\n ${dirScriptingMemories.length ? dirScriptingMemories.map(dirScriptingMemory => util.inspect(dirScriptingMemory)).join('\n') : 'none'}`);
    return {
      convos: dirConvos,
      utterances: dirUtterances,
      pconvos: dirPartialConvos,
      scriptingMemories: dirScriptingMemories
    };
  }

  ReadScriptFromBuffer(scriptBuffer, scriptingFormat, scriptingTypes = null) {
    if (lodash.isString(scriptingTypes)) scriptingTypes = [scriptingTypes];
    if (lodash.isArray(scriptingTypes) && scriptingTypes.length === 0) scriptingTypes = null;
    const result = {
      convos: [],
      utterances: [],
      pconvos: [],
      scriptingMemories: []
    };

    if (!scriptingTypes || scriptingTypes.includes(Constants.SCRIPTING_TYPE_UTTERANCES)) {
      result.utterances = this.Compile(scriptBuffer, scriptingFormat, Constants.SCRIPTING_TYPE_UTTERANCES);
    }

    if (!scriptingTypes || scriptingTypes.includes(Constants.SCRIPTING_TYPE_PCONVO)) {
      result.pconvos = this.Compile(scriptBuffer, scriptingFormat, Constants.SCRIPTING_TYPE_PCONVO);
    }

    if (!scriptingTypes || scriptingTypes.includes(Constants.SCRIPTING_TYPE_CONVO)) {
      result.convos = this.Compile(scriptBuffer, scriptingFormat, Constants.SCRIPTING_TYPE_CONVO);
    }

    if (!scriptingTypes || scriptingTypes.includes(Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY)) {
      result.scriptingMemories = this.Compile(scriptBuffer, scriptingFormat, Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY);
    }

    return result;
  }

  ReadScript(convoDir, filename) {
    let result = {};

    try {
      let scriptBuffer = fs.readFileSync(path.resolve(convoDir, filename));
      const precompResponse = precompilers.execute(scriptBuffer, {
        convoDir,
        filename,
        caps: this.caps
      });

      if (precompResponse) {
        scriptBuffer = precompResponse.scriptBuffer;
        debug$9(`File ${filename} precompiled by ${precompResponse.precompiler}` + (precompResponse.filename ? ` and filename changed to ${precompResponse.filename}` : ''));
        filename = precompResponse.filename || filename;
      }

      if (filename.endsWith('.xlsx') || filename.endsWith('.xlsm')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_XSLX, [Constants.SCRIPTING_TYPE_UTTERANCES, Constants.SCRIPTING_TYPE_PCONVO, Constants.SCRIPTING_TYPE_CONVO, Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY]);
      } else if (filename.endsWith('.convo.txt')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_CONVO);
      } else if (filename.endsWith('.pconvo.txt')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_PCONVO);
      } else if (filename.endsWith('.utterances.txt')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_UTTERANCES);
      } else if (filename.endsWith('.scriptingmemory.txt')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_TXT, Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY);
      } else if (filename.endsWith('.convo.csv')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_CSV, Constants.SCRIPTING_TYPE_CONVO);
      } else if (filename.endsWith('.pconvo.csv')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_CSV, Constants.SCRIPTING_TYPE_PCONVO);
      } else if (filename.endsWith('.yaml') || filename.endsWith('.yml')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_YAML, [Constants.SCRIPTING_TYPE_UTTERANCES, Constants.SCRIPTING_TYPE_PCONVO, Constants.SCRIPTING_TYPE_CONVO, Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY]);
      } else if (filename.endsWith('.json')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_JSON, [Constants.SCRIPTING_TYPE_UTTERANCES, Constants.SCRIPTING_TYPE_PCONVO, Constants.SCRIPTING_TYPE_CONVO, Constants.SCRIPTING_TYPE_SCRIPTING_MEMORY]);
      } else if (filename.endsWith('.markdown') || filename.endsWith('.md')) {
        result = this.ReadScriptFromBuffer(scriptBuffer, Constants.SCRIPTING_FORMAT_MARKDOWN, [Constants.SCRIPTING_TYPE_UTTERANCES, Constants.SCRIPTING_TYPE_PCONVO, Constants.SCRIPTING_TYPE_CONVO]);
      } else {
        debug$9(`ReadScript - dropped file: ${filename}, filename not supported`);
      }
    } catch (err) {
      debug$9(`ReadScript - an error occurred at '${filename}' file: ${err}`);
      throw botiumErrorFromErr(`ReadScript - an error occurred at '${filename}' file: ${err.message}`, err);
    } // Compilers saved the convos, and we alter here the saved version too


    if (result.convos && result.convos.length > 0) {
      result.convos.forEach(fileConvo => {
        fileConvo.sourceTag = {
          convoDir,
          filename
        };

        if (!fileConvo.header.name) {
          fileConvo.header.name = filename;
        }
      });

      const isSkip = c => c.header.name && skipPattern.test(c.header.name.toLowerCase());

      result.convos.filter(c => isSkip(c)).forEach(c => debug$9(`ReadScript - skipping convo '${c.header.name}'`));
      result.convos = result.convos.filter(c => !isSkip(c));
    }

    if (result.pconvos && result.pconvos.length > 0) {
      result.pconvos.forEach(filePartialConvo => {
        filePartialConvo.sourceTag = {
          convoDir,
          filename
        };

        if (!filePartialConvo.header.name) {
          filePartialConvo.header.name = filename;
        }
      });
    }

    if (result.scriptingMemories && result.scriptingMemories.length > 0) {
      result.scriptingMemories.forEach(scriptingMemory => {
        scriptingMemory.sourceTag = {
          filename
        };
      });
    }

    if (result.utterances) {
      result.utterances = this._tagAndCleanupUtterances(result.utterances, convoDir, filename);
    }

    return {
      convos: result.convos || [],
      utterances: result.utterances || [],
      pconvos: result.pconvos || [],
      scriptingMemories: result.scriptingMemories || []
    };
  }

  _tagAndCleanupUtterances(utteranceFiles, convoDir, filename) {
    return utteranceFiles.map(fileUtt => {
      fileUtt.sourceTag = {
        convoDir,
        filename
      };
      fileUtt.utterances = fileUtt.utterances.filter(u => u);
      return fileUtt;
    });
  }

  ExpandScriptingMemoryToConvos() {
    if (!this.caps[Capabilities.SCRIPTING_ENABLE_MEMORY]) {
      debug$9('ExpandScriptingMemoryToConvos - Scripting memory turned off, no convos expanded');
      return;
    } // validating scripting memory without name


    const aggregatedNoNames = this.scriptingMemories.filter(entry => {
      return !entry.header.name;
    });

    if (aggregatedNoNames.length) {
      throw new BotiumError$1('Scripting Memory Definition(s) without name', {
        type: 'Scripting Memory',
        subtype: 'Scripting Memory without name',
        source: 'ScriptingProvider',
        cause: {
          aggregatedNoNames
        }
      });
    } // validating scripting memory without variable


    const aggregatedNoVariables = this.scriptingMemories.filter(entry => {
      return !entry.values || !Object.keys(entry.values).length;
    });

    if (aggregatedNoVariables.length) {
      throw new BotiumError$1(`Scripting Memory Definition(s) ${aggregatedNoVariables.map(e => e.header.name).join(', ')} without variable`, {
        type: 'Scripting Memory',
        subtype: 'Scripting Memory without variable',
        source: 'ScriptingProvider',
        cause: {
          aggregatedNoVariables
        }
      });
    } // validating scripting memory without variable name


    const aggregatedNoVariableNames = this.scriptingMemories.filter(entry => {
      return !lodash.isUndefined(entry.values['']);
    });

    if (aggregatedNoVariableNames.length) {
      throw new BotiumError$1(`Scripting Memory Definition(s) ${aggregatedNoVariableNames.map(e => e.header.name).join(', ')} without variable name`, {
        type: 'Scripting Memory',
        subtype: 'Scripting Memory without variable name',
        source: 'ScriptingProvider',
        cause: {
          aggregatedNoVariableNames
        }
      });
    } // validating scripting memory name collision


    const aggregatedDuplicates = [];

    for (let i = 0; i < (this.scriptingMemories || []).length; i++) {
      const scriptingMemory = this.scriptingMemories[i];
      const duplicate = this.scriptingMemories.filter((entry, j) => {
        if (j === i || !(entry.values && scriptingMemory.values && entry.header && scriptingMemory.header)) {
          return false;
        }

        return entry.header.name === scriptingMemory.header.name && JSON.stringify(Object.keys(entry.values)) === JSON.stringify(Object.keys(scriptingMemory.values));
      });

      if (duplicate.length) {
        aggregatedDuplicates.push({
          scriptingMemory,
          duplicate
        });
      }
    }

    if (aggregatedDuplicates.length) {
      throw new BotiumError$1(`Scripting Memory Definition name(s) "${lodash.uniq(aggregatedDuplicates.map(d => d.scriptingMemory.header.name)).join(', ')}" are not unique`, {
        type: 'Scripting Memory',
        subtype: 'Scripting Memory name collision',
        source: 'ScriptingProvider',
        cause: {
          aggregatedDuplicates
        }
      });
    } // validating scripting memory variable name collision


    const aggregatedIntersections = [];

    for (let i = 0; i < (this.scriptingMemories || []).length; i++) {
      const scriptingMemory = this.scriptingMemories[i];
      const intersection = this.scriptingMemories.filter((entry, j) => {
        if (j === i || !(entry.values && scriptingMemory.values && entry.header && scriptingMemory.header)) {
          return false;
        }

        const k1 = Object.keys(entry.values);
        const k2 = Object.keys(scriptingMemory.values);

        const kInt = lodash.intersection(k1, k2);

        return kInt.length && (kInt.length !== k1.length || kInt.length !== k2.length);
      });

      if (intersection.length) {
        aggregatedIntersections.push({
          scriptingMemory,
          intersection
        });
      }
    }

    if (aggregatedIntersections.length) {
      throw new BotiumError$1(`Scripting Memory Definitions "${aggregatedIntersections.map(i => i.scriptingMemory.header.name).join(', ')}" are invalid because variable name collision"`, {
        type: 'Scripting Memory',
        subtype: 'Scripting Memory variable name collision',
        source: 'ScriptingProvider',
        cause: {
          aggregatedIntersections
        }
      });
    }

    const variablesToScriptingMemory = new Map();
    this.scriptingMemories.forEach(scriptingMemory => {
      const key = JSON.stringify(Object.keys(scriptingMemory.values).sort());

      if (variablesToScriptingMemory.has(key)) {
        variablesToScriptingMemory.get(key).push(scriptingMemory);
      } else {
        variablesToScriptingMemory.set(key, [scriptingMemory]);
      }
    });
    let convosExpandedAll = [];
    const convosOriginalAll = [];
    this.convos.forEach(convo => {
      const convoVariables = convo.GetScriptingMemoryAllVariables(this);
      debug$9(`ExpandScriptingMemoryToConvos - Convo "${convo.header.name}" - Variables to replace, all: "${util.inspect(convoVariables)}"`);

      if (!convoVariables.length) {
        debug$9(`ExpandScriptingMemoryToConvos - Convo "${convo.header.name}" - skipped, no variable found to replace`);
      }

      let convosToExpand = [convo];
      let convosExpandedConvo = []; // just for debug output. If we got 6 expanded convo, then this array can be for example [2, 3]

      const multipliers = [];

      for (const [key, scriptingMemories] of variablesToScriptingMemory.entries()) {
        const variableNames = JSON.parse(key);

        if (lodash.intersection(variableNames, convoVariables).length) {
          const convosExpandedVariable = [];
          multipliers.push(scriptingMemories.length);
          scriptingMemories.forEach(scriptingMemory => {
            // Appending the case name to name
            for (const convoToExpand of convosToExpand) {
              const convoExpanded = lodash.cloneDeep(convoToExpand);

              convoExpanded.header.name = convoToExpand.header.name + '.' + scriptingMemory.header.name;
              variableNames.forEach(name => {
                const value = scriptingMemory.values[name];

                if (value) {
                  convoExpanded.beginLogicHook.push({
                    name: 'SET_SCRIPTING_MEMORY',
                    args: [name.substring(1), scriptingMemory.values[name]]
                  });
                } else {
                  convoExpanded.beginLogicHook.push({
                    name: 'CLEAR_SCRIPTING_MEMORY',
                    args: [name.substring(1)]
                  });
                }
              });
              convosExpandedVariable.push(convoExpanded);
            }
          }); // This is a bit tricky. If the loop is done, then convosExpandedConvo will be used,
          // otherwise convosToExpand. They could be one variable

          convosToExpand = convosExpandedVariable;
          convosExpandedConvo = convosExpandedVariable;
        } else {
          debug$9(`ExpandScriptingMemoryToConvos - Convo "${convo.header.name}" - Scripting memory ${key} ignored because there is no common variable with convo ${util.inspect(convoVariables)}`);
        }
      }

      debug$9(`ExpandScriptingMemoryToConvos - Convo "${convo.header.name}" - Expanding convo "${convo.header.name}" Expanded ${convosExpandedConvo.length} convo. (Details: ${convosExpandedConvo.length} = ${multipliers ? multipliers.join('*') : 0})`);

      if (convosExpandedConvo.length) {
        convosExpandedAll = convosExpandedAll.concat(convosExpandedConvo);
        convosOriginalAll.push(convo);
      }
    });

    if (this.caps[Capabilities.SCRIPTING_MEMORYEXPANSION_KEEP_ORIG] !== true) {
      debug$9(`ExpandScriptingMemoryToConvos - Deleting ${convosOriginalAll.length} original convo`);
      this.convos = this.convos.filter(convo => convosOriginalAll.indexOf(convo) === -1);
    }

    debug$9(`ExpandScriptingMemoryToConvos - ${convosExpandedAll.length} convo expanded, added to convos (${this.convos.length}). Result ${convosExpandedAll.length + this.convos.length} convo`);
    this.convos = this.convos.concat(convosExpandedAll);
  }

  ExpandUtterancesToConvos({
    useNameAsIntent,
    incomprehensionUtt
  } = {}) {
    const expandedConvos = [];

    if (lodash.isUndefined(useNameAsIntent)) {
      useNameAsIntent = !!this.caps[Capabilities.SCRIPTING_UTTEXPANSION_USENAMEASINTENT];
    }

    if (lodash.isUndefined(incomprehensionUtt)) {
      incomprehensionUtt = this.caps[Capabilities.SCRIPTING_UTTEXPANSION_INCOMPREHENSION];
    }

    if (useNameAsIntent && incomprehensionUtt) {
      throw new Error('ExpandUtterancesToConvos - SCRIPTING_UTTEXPANSION_USENAMEASINTENT and SCRIPTING_UTTEXPANSION_INCOMPREHENSION are incompatible');
    }

    if (incomprehensionUtt && !this.utterances[incomprehensionUtt]) {
      throw new Error(`ExpandUtterancesToConvos - incomprehension utterance '${incomprehensionUtt}' undefined`);
    }

    if (useNameAsIntent) {
      debug$9('ExpandUtterancesToConvos - Using utterance name as NLU intent');
    } else if (incomprehensionUtt) {
      debug$9(`ExpandUtterancesToConvos - Using incomprehension utterance expansion mode: ${incomprehensionUtt}`);
    }

    lodash.keys(this.utterances).filter(u => u !== incomprehensionUtt).forEach(uttName => {
      const utt = this.utterances[uttName];
      expandedConvos.push(new Convo(this._buildScriptContext(), {
        header: {
          name: utt.name,
          description: `Expanded Utterances - ${utt.name}`
        },
        conversation: [{
          sender: 'me',
          messageText: utt.name,
          stepTag: 'Step 1 - tell utterance'
        }, useNameAsIntent ? {
          sender: 'bot',
          asserters: [{
            name: 'INTENT',
            args: [utt.name]
          }],
          stepTag: 'Step 2 - check intent',
          not: false
        } : incomprehensionUtt ? {
          sender: 'bot',
          messageText: incomprehensionUtt,
          stepTag: 'Step 2 - check incomprehension',
          not: true
        } : {
          sender: 'bot',
          messageText: '',
          stepTag: 'Step 2 - check bot response',
          not: false
        }],
        sourceTag: Object.assign({}, utt.sourceTag, {
          origUttName: utt.name
        })
      }));
    });

    this.convos = this.convos.concat(expandedConvos);

    this._sortConvos();
  }

  ExpandConvos() {
    const expandedConvos = [];
    debug$9(`ExpandConvos - Using utterances expansion mode: ${this.caps[Capabilities.SCRIPTING_UTTEXPANSION_MODE]}`);
    this.convos.forEach(convo => {
      convo.expandPartialConvos();

      this._expandConvo(expandedConvos, convo);
    });
    this.convos = expandedConvos;

    this._sortConvos();
  }
  /**
   *
   * @param expandedConvos
   * @param currentConvo
   * @param convoStepIndex
   * @param convoStepsStack list of ConvoSteps
   * @private
   */


  _expandConvo(expandedConvos, currentConvo, convoStepIndex = 0, convoStepsStack = []) {
    const utterancePostfix = (lineTag, uttOrUserInput) => {
      const naming = this.caps[Capabilities.SCRIPTING_UTTEXPANSION_NAMING_MODE] || Defaults$1.capabilities[Capabilities.SCRIPTING_UTTEXPANSION_NAMING_MODE];

      if (naming === 'justLineTag') {
        return `L${lineTag}`;
      }

      const utteranceMax = this.caps[Capabilities.SCRIPTING_UTTEXPANSION_NAMING_UTTERANCE_MAX] || 0;
      let postfix;

      if (utteranceMax > 3 && uttOrUserInput.length > utteranceMax) {
        postfix = uttOrUserInput.substring(0, utteranceMax - 3) + '...';
      } else {
        postfix = uttOrUserInput;
      }

      return `L${lineTag}-${postfix}`;
    };

    if (convoStepIndex < currentConvo.conversation.length) {
      const currentStep = currentConvo.conversation[convoStepIndex];

      if (currentStep.sender === 'bot' || currentStep.sender === 'begin' || currentStep.sender === 'end') {
        const currentStepsStack = convoStepsStack.slice();
        currentStepsStack.push(lodash.cloneDeep(currentStep));

        this._expandConvo(expandedConvos, currentConvo, convoStepIndex + 1, currentStepsStack);
      } else if (currentStep.sender === 'me') {
        let useUnexpanded = true;

        if (currentStep.messageText) {
          let uttName = null;
          let uttArgs = null;

          if (this.utterances[currentStep.messageText]) {
            uttName = currentStep.messageText;
          } else {
            const parts = currentStep.messageText.split(' ');

            if (this.utterances[parts[0]]) {
              uttName = parts[0];
              uttArgs = parts.slice(1);
            }
          }

          if (this.utterances[uttName]) {
            const allutterances = this.utterances[uttName].utterances;
            let sampleutterances = allutterances;

            if (this.caps[Capabilities.SCRIPTING_UTTEXPANSION_MODE] === 'first') {
              sampleutterances = [allutterances[0]];
            } else if (this.caps[Capabilities.SCRIPTING_UTTEXPANSION_MODE] === 'random') {
              sampleutterances = allutterances.map(x => ({
                x,
                r: Math.random()
              })).sort((a, b) => a.r - b.r).map(a => a.x).slice(0, this.caps[Capabilities.SCRIPTING_UTTEXPANSION_RANDOM_COUNT]);
            }

            sampleutterances.forEach((utt, index) => {
              const lineTag = `${index + 1}`.padStart(`${sampleutterances.length}`.length, '0');
              const currentStepsStack = convoStepsStack.slice();

              if (uttArgs) {
                utt = util.format(utt, ...uttArgs);
              }

              currentStepsStack.push(Object.assign(lodash.cloneDeep(currentStep), {
                messageText: utt
              }));

              const currentConvoLabeled = lodash.cloneDeep(currentConvo);

              Object.assign(currentConvoLabeled.header, {
                name: `${currentConvo.header.name}/${uttName}-${utterancePostfix(lineTag, utt)}`
              });
              if (!currentConvoLabeled.sourceTag) currentConvoLabeled.sourceTag = {};
              if (!currentConvoLabeled.sourceTag.origConvoName) currentConvoLabeled.sourceTag.origConvoName = currentConvo.header.name;

              this._expandConvo(expandedConvos, currentConvoLabeled, convoStepIndex + 1, currentStepsStack);
            });
            useUnexpanded = false;
          }
        }

        if (currentStep.userInputs && currentStep.userInputs.length > 0) {
          currentStep.userInputs.forEach((ui, uiIndex) => {
            const userInput = this.userInputs[ui.name];

            if (userInput && userInput.expandConvo) {
              const expandedUserInputs = userInput.expandConvo({
                convo: currentConvo,
                convoStep: currentStep,
                args: ui.args
              });

              if (expandedUserInputs && expandedUserInputs.length > 0) {
                let sampleinputs = expandedUserInputs;

                if (this.caps[Capabilities.SCRIPTING_UTTEXPANSION_MODE] === 'first') {
                  sampleinputs = [expandedUserInputs[0]];
                } else if (this.caps[Capabilities.SCRIPTING_UTTEXPANSION_MODE] === 'random') {
                  sampleinputs = expandedUserInputs.map(x => ({
                    x,
                    r: Math.random()
                  })).sort((a, b) => a.r - b.r).map(a => a.x).slice(0, this.caps[Capabilities.SCRIPTING_UTTEXPANSION_RANDOM_COUNT]);
                }

                sampleinputs.forEach((sampleinput, index) => {
                  const lineTag = `${index + 1}`.padStart(`${sampleinputs.length}`.length, '0');
                  const currentStepsStack = convoStepsStack.slice();

                  const currentStepMod = lodash.cloneDeep(currentStep);

                  currentStepMod.userInputs[uiIndex] = sampleinput;
                  currentStepsStack.push(currentStepMod);

                  const currentConvoLabeled = lodash.cloneDeep(currentConvo);

                  Object.assign(currentConvoLabeled.header, {
                    name: `${currentConvo.header.name}/${ui.name}-${utterancePostfix(lineTag, sampleinput.args && sampleinput.args.length ? sampleinput.args.join(', ') : 'no-args')}`
                  });

                  this._expandConvo(expandedConvos, currentConvoLabeled, convoStepIndex + 1, currentStepsStack);
                });
                useUnexpanded = false;
              }
            }
          });
        }

        if (useUnexpanded) {
          const currentStepsStack = convoStepsStack.slice();
          currentStepsStack.push(lodash.cloneDeep(currentStep));

          this._expandConvo(expandedConvos, currentConvo, convoStepIndex + 1, currentStepsStack);
        }
      }
    } else {
      expandedConvos.push(Object.assign(lodash.cloneDeep(currentConvo), {
        conversation: lodash.cloneDeep(convoStepsStack)
      }));
    }
  }

  _sortConvos() {
    this.convos = lodash.sortBy(this.convos, [convo => convo.header.sort || convo.header.name]);
    let i = 0;
    this.convos.forEach(convo => {
      convo.header.order = ++i;

      if (!convo.header.projectname) {
        convo.header.projectname = this.caps[Capabilities.PROJECTNAME];
      }

      if (!convo.header.testsessionname) {
        convo.header.testsessionname = this.caps[Capabilities.TESTSESSIONNAME];
      }
    });
  }

  AddConvos(convos) {
    if (convos && lodash.isArray(convos)) {
      this.convos = lodash.concat(this.convos, convos);
    } else if (convos) {
      this.convos.push(convos);
    }

    this._sortConvos();
  }

  AddUtterances(utterances) {
    const findAmbiguous = utterances => {
      const ambiguous = [];
      let expected = null;
      let base = null;

      if (utterances && utterances.length > 1) {
        base = utterances[0];
        expected = ScriptingMemory.extractVarNames(utterances[0]).sort();
        const expectedString = JSON.stringify(expected);

        for (let i = 1; i < utterances.length; i++) {
          const actualString = JSON.stringify(ScriptingMemory.extractVarNames(utterances[i]).sort());

          if (actualString !== expectedString) {
            ambiguous.push(utterances[i]);
          }
        }
      }

      return {
        expected,
        ambiguous,
        base
      };
    };

    if (utterances && !lodash.isArray(utterances)) {
      utterances = [utterances];
    }

    if (utterances) {
      lodash.forEach(utterances, utt => {
        const eu = this.utterances[utt.name];

        if (eu) {
          eu.utterances = lodash.uniq(lodash.concat(eu.utterances, utt.utterances));
        } else {
          this.utterances[utt.name] = utt;
        }

        const {
          ambiguous,
          expected
        } = findAmbiguous(this.utterances[utt.name].utterances);

        if (ambiguous && ambiguous.length > 0) {
          debug$9(`Ambigous utterance "${utt.name}", expecting exact ${expected.length ? '"' + expected.join(', ') + '"' : '<none>'} scripting memory variables in following user examples: ${ambiguous.map(d => `"${d}"`).join(', ')}`);
        }
      });
    }
  }

  AddPartialConvos(convos) {
    if (convos && lodash.isArray(convos)) {
      for (let i = 0; i < convos.length; i++) {
        const convo = convos[i];
        this.AddPartialConvos(convo);
      }
    } else if (convos) {
      if (!convos.header || !convos.header.name) {
        throw Error(`Header name is mandatory: ${JSON.stringify(convos.header)}`);
      }

      if (convos.header.name.indexOf('|') >= 0) {
        throw Error(`Invalid partial convo name: ${convos.header.name}`);
      }

      const name = convos.header.name;

      if (this.partialConvos[name]) {
        throw Error(`Duplicate partial convo: ${name}`);
      }

      this.partialConvos[name] = convos;
    }
  }

  GetPartialConvos() {
    return this.partialConvos;
  }

  AddScriptingMemories(scriptingMemories) {
    if (scriptingMemories && lodash.isArray(scriptingMemories)) {
      for (let i = 0; i < scriptingMemories.length; i++) {
        const scriptingMemory = scriptingMemories[i];
        this.AddScriptingMemories(scriptingMemory);
      }
    } else if (scriptingMemories) {
      if (!scriptingMemories.header || !scriptingMemories.header.name) {
        throw new BotiumError$1('Scripting Memory Definition has no name', {
          type: 'Compiler',
          subtype: 'Scripting memory without name',
          source: 'ScriptingProvider',
          cause: {
            scriptingMemory: scriptingMemories
          }
        });
      }

      if (!scriptingMemories.values || !Object.keys(scriptingMemories.values).length) {
        throw new BotiumError$1('Scripting Memory Definition has no variables', {
          type: 'Compiler',
          subtype: 'Scripting memory without variable',
          source: 'ScriptingProvider',
          cause: {
            scriptingMemory: scriptingMemories
          }
        });
      }

      if (scriptingMemories.values && !lodash.isUndefined(scriptingMemories.values[''])) {
        throw new BotiumError$1('Scripting Memory Definition variable has no name', {
          type: 'Compiler',
          subtype: 'Scripting memory without variable name',
          source: 'ScriptingProvider',
          cause: {
            scriptingMemory: scriptingMemories
          }
        });
      }

      this.scriptingMemories.push(scriptingMemories);
    }
  }

  GetConversationFlowView({
    getConvoNodeHash = null,
    detectLoops = false,
    summarizeMultiSteps = true,
    extPickMeNodeProps = [],
    extPickBotNodeProps = [],
    extPickMeHashProps = [],
    extPickBotHashProps = []
  } = {}) {
    const root = [];
    const botNodesByHash = {};
    const pickMeNodeProps = ['index', 'sender', 'messageText', 'utteranceSamples', 'utteranceCount', 'logicHooks', 'userInputs', ...extPickMeNodeProps];
    const pickBotNodeProps = ['index', 'sender', 'messageText', 'optional', 'not', 'utteranceSamples', 'utteranceCount', 'logicHooks', 'asserters', ...extPickBotNodeProps];
    const pickMeHashProps = ['sender', 'messageText', 'logicHooks', 'userInputs', ...extPickMeHashProps];
    const pickBotHashProps = ['sender', 'messageText', 'optional', 'not', 'logicHooks', 'asserters', ...extPickBotHashProps];
    this.convos.forEach(convo => {
      const convoNodes = [];

      for (const [convoStepIndex, convoStep] of convo.conversation.entries()) {
        if (convoStep.sender === 'begin' || convoStep.sender === 'end') continue;
        convoStep.index = convoStepIndex;

        if (convoStep.messageText) {
          const utterances = this._resolveUtterance({
            utterance: convoStep.messageText,
            resolveEmptyIfUnknown: true
          });

          if (utterances) {
            convoStep.utteranceSamples = utterances.slice(0, 3);
            convoStep.utteranceCount = utterances.length;
          }
        }

        const lastConvoNode = convoNodes.length === 0 ? null : convoNodes[convoNodes.length - 1];

        if (!lastConvoNode || !summarizeMultiSteps || convoNodes[convoNodes.length - 1].sender !== convoStep.sender) {
          convoNodes.push({
            sender: convoStep.sender,
            convoSteps: [convoStep],
            convoStepIndices: [convoStepIndex],
            hash: null
          });
        } else {
          lastConvoNode.convoSteps.push(convoStep);
          lastConvoNode.convoStepIndices.push(convoStepIndex);
        }
      }

      let currentChildren = root;

      for (const convoNode of convoNodes) {
        const convoNodeValues = convoNode.sender === 'me' ? convoNode.convoSteps.map(convoStep => lodash.pick(convoStep, pickMeNodeProps)) : convoNode.convoSteps.map(convoStep => lodash.pick(convoStep, pickBotNodeProps));
        const convoNodeHeader = {
          header: lodash.pick(convo.header, ['name', 'description']),
          sourceTag: convo.sourceTag,
          convoStepIndices: convoNode.convoStepIndices
        };
        let hash = getConvoNodeHash && getConvoNodeHash({
          convo,
          convoNode
        });

        if (!hash) {
          if (convoNode.sender === 'bot') {
            hash = crypto.createHash('md5').update(JSON.stringify(convoNode.convoSteps.map(convoStep => lodash.pick(convoStep, pickBotHashProps)))).digest('hex');
          } else {
            hash = crypto.createHash('md5').update(JSON.stringify(convoNode.convoSteps.map(convoStep => lodash.pick(convoStep, pickMeHashProps)))).digest('hex');
          }
        }

        const existingChildNode = currentChildren.find(c => c.hash === hash);

        if (existingChildNode) {
          existingChildNode.convos.push(lodash.cloneDeep(convoNodeHeader));
          currentChildren = existingChildNode.childNodes;
          continue;
        }

        const existingBotNode = detectLoops && convoNode.sender === 'bot' && botNodesByHash[hash];

        if (existingBotNode) {
          if (currentChildren.findIndex(c => c.ref === existingBotNode.key) < 0) {
            currentChildren.push({
              ref: existingBotNode.key
            });
          }

          const existingConvo = existingBotNode.convos.find(c => c.header.name === convoNodeHeader.header.name);

          if (existingConvo) {
            existingConvo.convoStepIndices = [...existingConvo.convoStepIndices, ...convoNodeHeader.convoStepIndices];
          } else {
            existingBotNode.convos.push(lodash.cloneDeep(convoNodeHeader));
          }

          currentChildren = existingBotNode.childNodes;
          continue;
        }

        const node = {
          sender: convoNode.sender,
          key: randomatic('0', 20),
          hash: hash,
          convoNodes: convoNodeValues,
          convos: [lodash.cloneDeep(convoNodeHeader)],
          childNodes: []
        };

        if (node.sender === 'bot') {
          botNodesByHash[hash] = node;
        }

        currentChildren.push(node);
        currentChildren = node.childNodes;
      }
    });
    return root;
  }

  GetConversationFlowDot(args) {
    const root = this.GetConversationFlowView(args);
    const nodes = [];
    const lines = [];

    const walkTreeForNodes = node => {
      nodes.push(`N_${node.hash} [label="${node.convoNodes.map(convoNode => new ConvoStep(convoNode).toString()).join('\r\n')}"];`);

      if (node.childNodes && node.childNodes.length > 0) {
        node.childNodes.filter(c => !c.ref).forEach(c => walkTreeForNodes(c));
      }
    };

    const walkTreeForLines = (node, path = []) => {
      if (node.childNodes && node.childNodes.length > 0) {
        node.childNodes.filter(c => !c.ref).forEach(c => walkTreeForLines(c, [...path, `N_${node.hash}`]));
        node.childNodes.filter(c => c.ref).forEach(c => lines.push(`${[...path, `N_${node.hash}`, `N_${c.ref}`].join(' -> ')};`));
      } else {
        lines.push(`${[...path, `N_${node.hash}`].join(' -> ')};`);
      }
    };

    root.forEach(r => walkTreeForNodes(r));
    root.forEach(r => walkTreeForLines(r));
    return ['digraph {', ...nodes, ...lines, '}'].join('\r\n');
  }

};

var BaseRepo_1 = class BaseRepo {
  constructor(tempDirectory, sources) {
    this.tempDirectory = tempDirectory;
    this.sources = Object.assign({}, sources);
    this.workingDirectory = null;
  }

  Validate() {
    return Promise.resolve();
  }

  Prepare() {
    return Promise.resolve();
  }

  _AssertSourceExists(source) {
    if (!this.sources[source]) {
      throw new Error(`Source property ${source} not set`);
    }
  }

};

var NoRepo_1 = class NoRepo extends BaseRepo_1 {
  Validate() {
    return super.Validate();
  }

  Prepare() {
    return super.Prepare();
  }

};

var ProcessUtils = createCommonjsModule(function (module) {
  const debug = debug$l('botium-core-ProcessUtils');
  module.exports = {
    childCommandLineRun: (cmd, ignoreErrors = false, processOptions = {}) => {
      const cmdOptions = cmd.split(' ');
      const cmdPart = cmdOptions[0];
      cmdOptions.splice(0, 1);
      return module.exports.childProcessRun(cmdPart, cmdOptions, ignoreErrors, processOptions);
    },
    childProcessRun: (cmd, cmdOptions, ignoreErrors = false, processOptions = {}) => {
      return new Promise((resolve, reject) => {
        debug('Running Command: ' + cmd + ' ' + lodash.join(cmdOptions, ' '));
        const runningProcess = child_process.spawn(cmd, cmdOptions, processOptions);
        const stdout = [];
        const stderr = [];
        runningProcess.stdout.on('data', data => {
          if (data) {
            debug(`${cmd} STDOUT: ${data}`);
            stdout.push(data);
          }
        });
        runningProcess.stderr.on('data', data => {
          if (data) {
            debug(`${cmd} STDERR: ${data}`);
            stderr.push(data);
          }
        });
        runningProcess.on('close', code => {
          debug(cmd + ' exited with code ' + code);

          if (code === 0 || ignoreErrors) {
            resolve({
              stdout,
              stderr
            });
          } else {
            reject(new Error(`${cmd} returned error code ${code}`));
          }
        });
        runningProcess.on('error', err => {
          if (ignoreErrors) {
            resolve();
          } else {
            reject(new Error(`${cmd} failed: ${util.inspect(err)}`));
          }
        });
      });
    }
  };
});
ProcessUtils.childCommandLineRun;
ProcessUtils.childProcessRun;

const debug$8 = debug$l('botium-core-GitRepo');
var GitRepo_1 = class GitRepo extends BaseRepo_1 {
  Validate() {
    return super.Validate().then(() => {
      this._AssertSourceExists(Source.GITPATH);

      this._AssertSourceExists(Source.GITURL);

      this._AssertSourceExists(Source.GITBRANCH);

      this._AssertSourceExists(Source.GITDIR);
    });
  }

  Prepare() {
    return new Promise((resolve, reject) => {
      async.series([cloneDirectoryCreated => {
        this.workingDirectory = path.resolve(this.tempDirectory, 'git');
        mkdirp(this.workingDirectory, err => {
          if (err) {
            return cloneDirectoryCreated(new Error(`Unable to create clone directory ${this.workingDirectory}: ${err}`));
          }

          cloneDirectoryCreated();
        });
      }, cloneReady => {
        const gitCmdOptions = ['clone', '-b', this.sources[Source.GITBRANCH], '--single-branch', '--depth', '1', this.sources[Source.GITURL], this.workingDirectory];
        ProcessUtils.childProcessRun(this.sources[Source.GITPATH], gitCmdOptions, false, {
          cwd: this.workingDirectory
        }).then(() => cloneReady()).catch(cloneReady);
      }, workingDirectoryChanged => {
        this.workingDirectory = path.resolve(this.workingDirectory, this.sources[Source.GITDIR]);
        workingDirectoryChanged();
      }, prepareReady => {
        if (this.sources[Source.GITPREPARECMD]) {
          ProcessUtils.childCommandLineRun(this.sources[Source.GITPREPARECMD], false, {
            cwd: this.workingDirectory
          }).then(() => prepareReady()).catch(prepareReady);
        } else {
          prepareReady();
        }
      }], err => {
        if (err) {
          return reject(err);
        }

        debug$8(`git checkout out to ${this.workingDirectory}`);
        resolve();
      });
    });
  }

};

var LocalRepo_1 = class LocalRepo extends BaseRepo_1 {
  Validate() {
    return super.Validate().then(() => {
      this._AssertSourceExists(Source.LOCALPATH);

      const checkPath = this.sources[Source.LOCALPATH];
      fs.stat(checkPath, (err, stats) => {
        if (err) {
          throw new Error(`${checkPath} not available: ${err}`);
        }

        if (stats.isDirectory() && !stats.isSymbolicLink()) {
          fs.access(checkPath, fs.constants.W_OK, err1 => {
            if (err) {
              throw new Error(`${checkPath} not writeable: ${err}`);
            }
          });
        } else {
          throw new Error(`${checkPath} not a regular directory`);
        }
      });
    });
  }

  Prepare() {
    // No need to prepare anything
    this.workingDirectory = path.resolve(this.sources[Source.LOCALPATH]);
    return Promise.resolve();
  }

};

var Commands = {
  BUILD_CONTAINER: 'BUILD_CONTAINER',
  START_CONTAINER: 'START_CONTAINER',
  SENDTOBOT: 'SENDTOBOT',
  STOP_CONTAINER: 'STOP_CONTAINER',
  CLEAN_CONTAINER: 'CLEAN_CONTAINER'
};

const {
  formatTimeout
} = Utils;
var QueueTimeoutError_1 = class QueueTimeoutError extends Error {
  constructor(timeoutMillis) {
    super(`Bot did not respond within ${formatTimeout(timeoutMillis)}`);
    this.timeoutMillis = timeoutMillis;
  }

};

var Queue_1 = class Queue {
  constructor() {
    this.queue = [];
    this.listeners = [];
    this.pushListener = null;
  }

  length() {
    return this.queue.length;
  }

  empty() {
    this.queue = [];
  }

  clear() {
    this.queue = [];
    this.listeners = [];
  }

  push(msg) {
    if (this.pushListener) {
      this.pushListener(msg);
    }

    if (this.listeners.length > 0) {
      this.listeners.shift()(msg);
    } else {
      this.queue.push(msg);
    }
  }

  pop(timeoutMillis) {
    if (this.queue.length > 0) {
      return Promise.resolve(this.queue.shift());
    }

    return new Promise((resolve, reject) => {
      let listener = null;
      const timeoutRequest = async.timeout(timeoutCallback => {
        listener = msg => {
          timeoutCallback(null, msg);
        };

        this.listeners.push(listener);
      }, timeoutMillis);
      timeoutRequest((err, msg) => {
        if (err && err.code === 'ETIMEDOUT') {
          this.listeners.splice(this.listeners.indexOf(listener), 1);
          reject(new QueueTimeoutError_1(timeoutMillis));
        } else if (err) {
          this.listeners.splice(this.listeners.indexOf(listener), 1);
          reject(new Error(`Queue pop error ${util.inspect(err)}`));
        } else {
          resolve(msg);
        }
      });
    });
  }

  registerPushListener(callback) {
    this.pushListener = callback;
  }

};

const debug$7 = debug$l('botium-connector-BaseContainer');
const {
  executeHook: executeHook$1,
  getHook: getHook$1
} = HookUtils;
var BaseContainer_1 = class BaseContainer {
  constructor(eventEmitter, tempDirectory, repo, caps, envs) {
    this.eventEmitter = eventEmitter;
    this.repo = repo;
    this.caps = Object.assign({}, caps);
    this.envs = Object.assign({}, envs);
    this.tempDirectory = tempDirectory;
    this.cleanupTasks = [];
    this.queues = {};
    this.userSaysLimiter = null;
  }

  Validate() {
    this.onBuildHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONBUILD]);
    this.onStartHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONSTART]);
    this.onUserSaysHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONUSERSAYS]);
    this.onBotResponseHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONBOTRESPONSE]);
    this.onStopHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONSTOP]);
    this.onCleanHook = getHook$1(this.caps, this.caps[Capabilities.CUSTOMHOOK_ONCLEAN]);
    return Promise.resolve();
  }

  Build() {
    if (this.caps[Capabilities.RATELIMIT_USERSAYS_MAXCONCURRENT] || this.caps[Capabilities.RATELIMIT_USERSAYS_MINTIME]) {
      const opts = {};
      if (this.caps[Capabilities.RATELIMIT_USERSAYS_MAXCONCURRENT]) opts.maxConcurrent = this.caps[Capabilities.RATELIMIT_USERSAYS_MAXCONCURRENT];
      if (this.caps[Capabilities.RATELIMIT_USERSAYS_MINTIME]) opts.minTime = this.caps[Capabilities.RATELIMIT_USERSAYS_MINTIME];
      this.userSaysLimiter = new bottleneck(opts);
      debug$7(`Build: Applying userSays rate limits ${util.inspect(opts)}`);
    }

    return new Promise((resolve, reject) => {
      this._RunCustomHook('onBuild', this.onBuildHook).then(() => resolve(this)).catch(err => reject(err));
    });
  }

  Start() {
    this.queues = {};
    return new Promise((resolve, reject) => {
      this._RunCustomHook('onStart', this.onStartHook).then(() => resolve(this)).catch(err => reject(err));
    });
  }

  UserSaysText(text) {
    const meMsg = new BotiumMockMessage_1({
      sender: 'me',
      messageText: text
    });
    return this.UserSays(meMsg);
  }

  UserSays(meMsg) {
    const run = () => this._RunCustomHook('onUserSays', this.onUserSaysHook, {
      meMsg
    }).then(() => this.UserSaysImpl(meMsg));

    if (this.userSaysLimiter) {
      return this.userSaysLimiter.schedule(run);
    } else {
      return run();
    }
  }

  UserSaysImpl(meMsg) {
    return Promise.resolve(this);
  }

  WaitBotSays(channel = null, timeoutMillis = null) {
    if (!channel) channel = 'default';
    if (!timeoutMillis) timeoutMillis = this.caps[Capabilities.WAITFORBOTTIMEOUT];

    if (!this.queues[channel]) {
      this.queues[channel] = new Queue_1();
    }

    return new Promise((resolve, reject) => {
      this.queues[channel].pop(timeoutMillis).then(botMsg => {
        if (lodash.isError(botMsg)) {
          reject(botMsg);
        } else {
          resolve(botMsg);
        }
      }).catch(err => {
        debug$7(`WaitBotSays error ${err.message || err}`);
        reject(err);
      });
    });
  }

  WaitBotSaysText(channel = null, timeoutMillis = null) {
    return this.WaitBotSays(channel, timeoutMillis).then(botMsg => {
      if (botMsg) {
        return botMsg.messageText;
      }
    });
  }

  Restart() {
    return new Promise((resolve, reject) => {
      this.Stop().then(() => this.Start()).then(() => resolve()).catch(err => reject(err));
    });
  }

  Stop() {
    return new Promise((resolve, reject) => {
      this._RunCustomHook('onStop', this.onStopHook).then(() => resolve(this)).catch(err => reject(err));
    });
  }

  Clean() {
    this.userSaysLimiter = null;
    return new Promise((resolve, reject) => {
      async.series([hookExecuted => {
        this._RunCustomHook('onClean', this.onCleanHook).then(() => hookExecuted()).catch(() => hookExecuted());
      }, cleanupTasksDone => {
        if (this.cleanupTasks) {
          async.series(this.cleanupTasks.map(task => {
            return cb => {
              task(err => {
                if (err) debug$7(`Cleanup failed: ${util.inspect(err)}`);
                cb();
              });
            };
          }), () => {
            cleanupTasksDone();
          });
        } else {
          cleanupTasksDone();
        }
      }, rimraffed => {
        if (this.caps[Capabilities.CLEANUPTEMPDIR]) {
          debug$7(`Cleanup rimrafing temp dir ${this.tempDirectory}`);
          rimraf(this.tempDirectory, err => {
            if (err) debug$7(`Cleanup temp dir ${this.tempDirectory} failed: ${util.inspect(err)}`);
            rimraffed();
          });
        } else {
          rimraffed();
        }
      }], err => {
        if (err) {
          return reject(new Error(`Cleanup failed ${util.inspect(err)}`));
        }

        resolve();
      });
    });
  }

  _AssertCapabilityExists(cap) {
    if (!Object.prototype.hasOwnProperty.call(this.caps, cap)) {
      throw new Error(`Capability property ${cap} not set`);
    }
  }

  _AssertOneCapabilityExists() {
    const checkCaps = [...arguments];
    const found = checkCaps.find(cap => this.caps[cap]);

    if (!found) {
      throw new Error(`Capability property of ${checkCaps.join()} not set`);
    }
  }

  _QueueLength(channel = 'default') {
    return this.queues[channel] && this.queues[channel].length() || 0;
  }

  _EmptyQueue(channel = 'default') {
    if (this.queues[channel]) {
      this.queues[channel].empty();
    }
  }

  async _QueueBotSays(botMsg) {
    if (lodash.isError(botMsg)) {
      if (!this.queues.default) {
        this.queues.default = new Queue_1();
      }

      this.queues.default.push(botMsg);
      this.eventEmitter.emit(Events.MESSAGE_RECEIVEFROMBOT_ERROR, this, botMsg);
    } else {
      if (!botMsg.channel) botMsg.channel = 'default';
      if (!botMsg.sender) botMsg.sender = 'bot';

      if (!this.queues[botMsg.channel]) {
        this.queues[botMsg.channel] = new Queue_1();
      }

      await this._RunCustomHook('onBotResponse', this.onBotResponseHook, {
        botMsg
      });
      this.queues[botMsg.channel].push(botMsg);
      this.eventEmitter.emit(Events.MESSAGE_RECEIVEDFROMBOT, this, botMsg);
    }
  }

  async _RunCustomHook(name, hook, args) {
    try {
      await executeHook$1(this.caps, hook, Object.assign({
        container: this,
        request
      }, args));
    } catch (err) {
      debug$7(`_RunCustomHook ${name} finished with error: ${err.message || util.inspect(err)}`);
    }
  }

};

const debug$6 = debug$l('botium-connector-GridContainer');
var GridContainer_1 = class GridContainer extends BaseContainer_1 {
  Validate() {
    return super.Validate().then(() => {
      this._AssertCapabilityExists(Capabilities.BOTIUMGRIDURL);
    });
  }

  Build() {
    this.buildPromise = this._defer();
    async.series([baseComplete => {
      super.Build().then(() => baseComplete()).catch(baseComplete);
    }, socketComplete => {
      this.socket = socket(this.caps[Capabilities.BOTIUMGRIDURL]);
      this.socket.on('connect', () => {
        debug$6('connected');
        this.socket.emit('authentication', {
          apiToken: this.caps[Capabilities.BOTIUMAPITOKEN]
        });
      });
      this.socket.on('connect_error', err => {
        debug$6(`connect_error ${err.message}`);
      });
      this.socket.on('connect_timeout', timeout => {
        debug$6(`connect_timeout ${util.inspect(timeout)}`);
      });
      this.socket.on('error', err => {
        debug$6(`error ${err.message}`);
      });
      this.socket.on('authenticated', () => {
        debug$6('authenticated');
        this.socket.emit(Commands.BUILD_CONTAINER, this.caps, this.repo.sources, this.envs);
      });
      this.socket.on('unauthorized', err => {
        debug$6(`unauthorized ${err.message}`);
        socketComplete(`Grid Access not authorized: ${err.message}`);
      });
      this.socket.on(Events.TOOMUCHWORKERS_ERROR, err => {
        debug$6(`TOOMUCHWORKERS_ERROR ${err.message}`);
        socketComplete(`Grid Access not possible: ${err.message}`);
      });
      this.socket.on(Events.CONTAINER_BUILT, () => {
        debug$6(Events.CONTAINER_BUILT);
        socketComplete();
      });
      this.socket.on(Events.CONTAINER_BUILD_ERROR, err => {
        debug$6(`CONTAINER_BUILD_ERROR ${err.message}`);
        socketComplete(`Grid Build failed: ${err.message}`);
      });
      this.socket.on(Events.CONTAINER_STARTED, () => {
        debug$6(Events.CONTAINER_STARTED);
        this.eventEmitter.emit(Events.CONTAINER_STARTED, this);

        if (this.startPromise) {
          this.startPromise.resolve(this);
          this.startPromise = null;
        }
      });
      this.socket.on(Events.CONTAINER_START_ERROR, err => {
        debug$6(`CONTAINER_START_ERROR ${err.message}`);
        this.eventEmitter.emit(Events.CONTAINER_START_ERROR, this, err);

        if (this.startPromise) {
          this.startPromise.reject(`Grid Start failed: ${err.message}`);
          this.startPromise = null;
        }
      });
      this.socket.on(Events.MESSAGE_RECEIVEDFROMBOT, botMsg => {
        debug$6(`MESSAGE_RECEIVEDFROMBOT ${util.inspect(botMsg)}`);

        this._QueueBotSays(new BotiumMockMessage_1(botMsg));
      });
      this.socket.on(Events.CONTAINER_STOPPED, () => {
        debug$6(Events.CONTAINER_STOPPED);
        this.eventEmitter.emit(Events.CONTAINER_STOPPED, this);

        if (this.stopPromise) {
          this.stopPromise.resolve(this);
          this.stopPromise = null;
        }
      });
      this.socket.on(Events.CONTAINER_STOP_ERROR, err => {
        debug$6(`CONTAINER_STOP_ERROR ${err.message}`);
        this.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this, err);

        if (this.stopPromise) {
          this.stopPromise.reject(`Grid Stop failed: ${err.message}`);
          this.stopPromise = null;
        }
      });
      this.socket.on(Events.CONTAINER_CLEANED, () => {
        debug$6(Events.CONTAINER_CLEANED);
        this.eventEmitter.emit(Events.CONTAINER_CLEANED, this);

        if (this.cleanPromise) {
          this.cleanPromise.resolve(this);
          this.cleanPromise = null;
        }

        this.socket.disconnect();
        this.socket = null;
      });
      this.socket.on(Events.CONTAINER_CLEAN_ERROR, err => {
        debug$6(`CONTAINER_CLEAN_ERROR ${err.message}`);
        this.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this, err);

        if (this.cleanPromise) {
          this.cleanPromise.reject(`Grid Clean failed: ${err.message}`);
          this.cleanPromise = null;
        }

        this.socket.disconnect();
        this.socket = null;
      });
    }], err => {
      if (err) {
        this.buildPromise.reject(new Error(`Cannot build grid containers: ${err.message}`));
      } else {
        this.buildPromise.resolve(this);
      }

      this.buildPromise = null;
    });
    return this.buildPromise.promise;
  }

  Start() {
    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);
    return super.Start().then(() => {
      if (this.startPromise) return Promise.reject(new Error('already starting'));

      if (this.socket) {
        this.startPromise = this._defer();
        this.socket.emit(Commands.START_CONTAINER);
        return this.startPromise.promise;
      } else {
        this.eventEmitter.emit(Events.CONTAINER_START_ERROR, this, 'Remote Agent not online');
        return Promise.reject(new Error('Remote Agent not online'));
      }
    });
  }

  UserSaysImpl(mockMsg) {
    return new Promise((resolve, reject) => {
      if (this.socket) {
        this.socket.emit(Commands.SENDTOBOT, mockMsg);
        this.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this, mockMsg);
        resolve(this);
      } else {
        this.eventEmitter.emit(Events.MESSAGE_SENDTOBOT_ERROR, this, 'Remote Agent not online');
        reject(new Error('Remote Agent not online'));
      }
    });
  }

  Stop() {
    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);
    return super.Stop().then(() => {
      if (this.stopPromise) return Promise.reject(new Error('already stopping'));

      if (this.socket) {
        this.stopPromise = this._defer();
        this.socket.emit(Commands.STOP_CONTAINER);
        return this.stopPromise.promise;
      } else {
        return Promise.resolve(this);
      }
    });
  }

  Clean() {
    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);
    return super.Clean().then(() => {
      if (this.cleanPromise) return Promise.reject(new Error('already cleaning'));

      if (this.socket) {
        this.cleanPromise = this._defer();
        this.socket.emit(Commands.CLEAN_CONTAINER);
        return this.cleanPromise.promise;
      } else {
        return Promise.resolve(this);
      }
    });
  }

  _ValidateCustomHook(capKey) {
    if (this.caps[capKey]) {
      if (!lodash.isString(this.caps[capKey])) {
        throw new Error(`Custom Hook ${capKey} has to be a command line string`);
      }
    }
  }

  _RunCustomHook(capKey) {
    return Promise.resolve();
  }

  _defer() {
    const deferred = {
      promise: null,
      resolve: null,
      reject: null
    };
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

};

var InProcessContainer_1 = class InProcessContainer extends BaseContainer_1 {
  UserSaysImpl(mockMsg) {
    this.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this, mockMsg);
    return Promise.resolve(this);
  }

  InjectBotSays(botMsg) {
    this._QueueBotSays(new BotiumMockMessage_1(botMsg));
  }

};

const debug$5 = debug$l('botium-core-inbound-proxy');

const buildRedisHandler = (redisurl, topic) => {
  const redis = new ioredis(redisurl);
  redis.on('connect', () => {
    debug$5(`Redis connected to ${JSON.stringify(redisurl || 'default')}`);
  });
  return event => {
    try {
      debug$5('Got Message Event:');
      debug$5(JSON.stringify(event, null, 2));
      redis.publish(topic, JSON.stringify(event));
    } catch (err) {
      debug$5('Error while publishing to redis');
      debug$5(err);
    }
  };
};

const setupEndpoints = ({
  app,
  endpoint,
  middleware,
  processEvent
}) => {
  if (endpoint && !endpoint.endsWith('/')) endpoint = endpoint + '/';

  const handler = (req, res) => {
    if (req.body) {
      processEvent({
        originalUrl: req.originalUrl,
        originalMethod: req.method,
        body: req.body
      });
      res.status(200).json({}).end();
    } else {
      res.status(500).sendResponse('No body detected');
    }
  };

  if (endpoint) {
    app.all(endpoint, ...(middleware || []), handler);
    app.all(endpoint.endsWith('/') ? endpoint + '*' : endpoint + '/*', ...(middleware || []), handler);
  } else {
    app.all(...(middleware || []), handler);
  }
};

const startProxy$1 = async ({
  port,
  endpoint,
  processEvent
}) => {
  return new Promise((resolve, reject) => {
    const app = express();
    setupEndpoints({
      app,
      middleware: [bodyParser.json(), bodyParser.urlencoded({
        extended: true
      })],
      endpoint: endpoint || '/',
      processEvent
    });
    const proxy = app.listen(port, () => {
      console.log(`Botium Inbound Messages proxy is listening on port ${port}`);
      console.log(`Botium Inbound Messages endpoint available at http://127.0.0.1:${port}${endpoint}`);
      resolve(proxy);
    });
  });
};

var proxy = {
  buildRedisHandler,
  setupEndpoints,
  startProxy: startProxy$1
};
proxy.buildRedisHandler;
proxy.setupEndpoints;
proxy.startProxy;

const {
  v4: uuidv4
} = uuid;
const debug$4 = debug$l('botium-connector-simplerest');
const {
  startProxy
} = proxy;
const {
  getAllCapValues
} = CapabilitiesUtils;
const Defaults = Defaults$1.Capabilities;
const {
  SCRIPTING_FUNCTIONS
} = ScriptingMemory;
const {
  getHook,
  executeHook
} = HookUtils;
const {
  escapeJSONString
} = Utils;

mustache.escape = s => s;

var SimpleRestContainer_1 = class SimpleRestContainer {
  constructor({
    queueBotSays,
    caps
  }) {
    this.queueBotSays = queueBotSays;
    this.caps = Object.assign({}, Defaults, caps);
    this.processInbound = false;
    this.redisTopic = this.caps[Capabilities.SIMPLEREST_REDIS_TOPIC] || 'SIMPLEREST_INBOUND_SUBSCRIPTION';

    if (this.caps[Capabilities.SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH]) {
      const debounceTimeout = this.caps[Capabilities.SIMPLEREST_INBOUND_DEBOUNCE_TIMEOUT] || 500;
      this.inboundEvents = [];
      this._processOrderedInboundEventsArrayAsync = lodash.debounce(() => {
        const events = [...this.inboundEvents];
        this.inboundEvents = [];

        const jsonPath = this._getMustachedVal(this.caps[Capabilities.SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH], false);

        const sortedEvents = lodash.sortBy(events, event => {
          const qr = jsonpath.query(event, jsonPath);
          return qr[0];
        });

        for (const event of sortedEvents) {
          setTimeout(() => this._processBodyAsync(event.body, true, !!this.caps[Capabilities.SIMPLEREST_INBOUND_UPDATE_CONTEXT]), 0);
        }
      }, debounceTimeout);
    }
  }

  Validate() {
    if (!this.caps[Capabilities.SIMPLEREST_URL]) throw new Error('SIMPLEREST_URL capability required');
    if (!this.caps[Capabilities.SIMPLEREST_METHOD] && !this.caps[Capabilities.SIMPLEREST_VERB]) throw new Error('SIMPLEREST_METHOD/SIMPLEREST_VERB capability required');
    if (lodash.keys(this.caps).findIndex(k => k.startsWith(Capabilities.SIMPLEREST_RESPONSE_JSONPATH)) < 0 && !this.caps[Capabilities.SIMPLEREST_RESPONSE_HOOK]) throw new Error('SIMPLEREST_RESPONSE_JSONPATH or SIMPLEREST_RESPONSE_HOOK capability required');

    if (this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) {
      lodash.isObject(this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) || JSON.parse(this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]);
    }

    if (this.caps[Capabilities.SIMPLEREST_CONTEXT_MERGE_OR_REPLACE] !== 'MERGE' && this.caps[Capabilities.SIMPLEREST_CONTEXT_MERGE_OR_REPLACE] !== 'REPLACE') throw new Error('SIMPLEREST_CONTEXT_MERGE_OR_REPLACE capability only MERGE or REPLACE allowed');
    this.startHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_START_HOOK]);
    this.stopHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_STOP_HOOK]);
    this.requestHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_REQUEST_HOOK]);
    this.parserHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_PARSER_HOOK]);
    this.responseHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_RESPONSE_HOOK]);
    this.pollRequestHook = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_POLL_REQUEST_HOOK]);
    this.requestHooks = {};

    if (this.caps[Capabilities.SIMPLEREST_PING_REQUEST_HOOK]) {
      this.requestHooks.SIMPLEREST_PING = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_PING_REQUEST_HOOK]);
    }

    if (this.caps[Capabilities.SIMPLEREST_START_REQUEST_HOOK]) {
      this.requestHooks.SIMPLEREST_START = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_START_REQUEST_HOOK]);
    }

    if (this.caps[Capabilities.SIMPLEREST_STOP_REQUEST_HOOK]) {
      this.requestHooks.SIMPLEREST_STOP = getHook(this.caps, this.caps[Capabilities.SIMPLEREST_STOP_REQUEST_HOOK]);
    }
  }

  Build() {
    return this._buildInbound();
  }

  Start() {
    return new Promise((resolve, reject) => {
      async.series([contextInitComplete => {
        this.view = {
          container: this,
          context: {},
          msg: {},
          botium: {
            conversationId: null,
            stepId: null
          },
          // Mustache deals with fuctions with, or without parameters differently.
          // -> we have to add our functions differently, if they have param or not.
          // -> optional parameters are not working here!
          // (render(text) is required for forcing mustache to replace valiables in the text first,
          // then send it to the function.)
          // (mapKeys: remove starting $)
          fnc: lodash.mapValues(lodash.mapKeys(SCRIPTING_FUNCTIONS, (value, key) => key.substring(1)), descriptor => {
            const safeCaps = Object.assign({}, this.caps, {
              [Capabilities.SECURITY_ALLOW_UNSAFE]: true
            });
            return descriptor.numberOfArguments ? () => {
              return (text, render) => descriptor.handler(safeCaps, render(text));
            } : () => descriptor.handler(safeCaps);
          })
        };

        this.view.fnc.jsonify = () => (val, render) => {
          return escapeJSONString(render(val));
        };

        if (this.caps[Capabilities.SIMPLEREST_CONVERSATION_ID_TEMPLATE]) {
          this.view.botium.conversationId = this._getMustachedCap(Capabilities.SIMPLEREST_CONVERSATION_ID_TEMPLATE, false);
        } else {
          this.view.botium.conversationId = uuidv4();
        }

        if (this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) {
          try {
            this.view.context = lodash.isObject(this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) ? lodash.cloneDeep(this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]) : JSON.parse(this.caps[Capabilities.SIMPLEREST_INIT_CONTEXT]);
          } catch (err) {
            contextInitComplete(`parsing SIMPLEREST_INIT_CONTEXT failed, no JSON detected (${err.message})`);
          }
        }

        contextInitComplete();
      }, startHookComplete => {
        executeHook(this.caps, this.startHook, this.view).then(() => startHookComplete()).catch(startHookComplete);
      }, inboundListenerComplete => {
        this._subscribeInbound().then(() => inboundListenerComplete()).catch(inboundListenerComplete);
      }, startPollingComplete => {
        this._startPolling().then(() => startPollingComplete()).catch(startPollingComplete);
      }, pingComplete => {
        if (this.caps[Capabilities.SIMPLEREST_PING_URL]) {
          this._makeCall('SIMPLEREST_PING').then(body => {
            if (this.caps[Capabilities.SIMPLEREST_PING_UPDATE_CONTEXT] || this.caps[Capabilities.SIMPLEREST_PING_PROCESS_RESPONSE]) {
              return this._parseResponseBody(body).then(body => {
                if (body) {
                  debug$4(`Ping Uri ${this.caps[Capabilities.SIMPLEREST_PING_URL]} returned JSON response: ${Utils.shortenJsonString(body)}`);
                  return this._processBodyAsync(body, !!this.caps[Capabilities.SIMPLEREST_PING_PROCESS_RESPONSE], !!this.caps[Capabilities.SIMPLEREST_PING_UPDATE_CONTEXT]);
                } else {
                  debug$4(`Ping Uri ${this.caps[Capabilities.SIMPLEREST_PING_URL]} didn't return JSON response, ignoring it.`);
                }
              }).catch(err => {
                debug$4(`Ping Uri ${this.caps[Capabilities.SIMPLEREST_PING_URL]} didn't return JSON response, ignoring it (${err.message})`);
              });
            }
          }).then(() => {
            pingComplete();
          }).catch(err => {
            pingComplete(err.message);
          });
        } else {
          pingComplete();
        }
      }, initComplete => {
        if (lodash.isString(this.caps[Capabilities.SIMPLEREST_INIT_TEXT])) {
          this._doRequest({
            messageText: this.caps[Capabilities.SIMPLEREST_INIT_TEXT]
          }, !!this.caps[Capabilities.SIMPLEREST_INIT_PROCESS_RESPONSE], true).then(() => initComplete()).catch(initComplete);
        } else {
          initComplete();
        }
      }, startCallComplete => {
        this.processInbound = true;

        if (this.caps[Capabilities.SIMPLEREST_START_URL]) {
          this._makeCall('SIMPLEREST_START').then(body => {
            if (this.caps[Capabilities.SIMPLEREST_START_UPDATE_CONTEXT] || this.caps[Capabilities.SIMPLEREST_START_PROCESS_RESPONSE]) {
              return this._parseResponseBody(body).then(body => {
                if (body) {
                  debug$4(`Start Uri ${this.caps[Capabilities.SIMPLEREST_START_URL]} returned JSON response: ${Utils.shortenJsonString(body)}`);
                  return this._processBodyAsync(body, !!this.caps[Capabilities.SIMPLEREST_START_PROCESS_RESPONSE], !!this.caps[Capabilities.SIMPLEREST_START_UPDATE_CONTEXT]);
                } else {
                  debug$4(`Start Uri ${this.caps[Capabilities.SIMPLEREST_START_URL]} didn't return JSON response, ignoring it.`);
                }
              }).catch(err => {
                debug$4(`Start Uri ${this.caps[Capabilities.SIMPLEREST_START_URL]} didn't return JSON response, ignoring it (${err.message})`);
              });
            }
          }).then(() => {
            startCallComplete();
          }).catch(err => {
            startCallComplete(new Error(`Failed to call url ${this.caps[Capabilities.SIMPLEREST_START_URL]} to start session: ${err.message}`));
          });
        } else {
          startCallComplete();
        }
      }], err => {
        if (err) {
          return reject(new Error(`Start failed: ${err.message}`));
        }

        resolve();
      });
    });
  }

  UserSays(mockMsg) {
    return this._doRequest(mockMsg, true, true);
  }

  async Stop() {
    this.processInbound = false;

    if (this.caps[Capabilities.SIMPLEREST_STOP_URL]) {
      try {
        await this._makeCall('SIMPLEREST_STOP');
      } catch (err) {
        throw new Error(`Failed to call url ${this.caps[Capabilities.SIMPLEREST_STOP_URL]} to stop session: ${err.message}`);
      }
    }

    await executeHook(this.caps, this.stopHook, this.view);
    await this._unsubscribeInbound();
    await this._stopPolling();
    this.view = {};
  }

  Clean() {
    return this._cleanInbound();
  } // Separated just for better module testing


  async _processBodyAsync(body, isFromUser, updateContext) {
    const p = async () => {
      try {
        const results = await this._processBodyAsyncImpl(body, isFromUser, updateContext);

        if (results) {
          for (const result of results) {
            setTimeout(() => this.queueBotSays(result), 0);
          }
        }
      } catch (err) {
        setTimeout(() => this.queueBotSays(err), 0);
      }
    };

    if (this.waitProcessQueue) {
      this.waitProcessQueue.push(p);
      debug$4('Async body is queued for processing.');
    } else {
      await p();
    }
  }

  async _emptyWaitProcessQueue() {
    if (this.waitProcessQueue && this.waitProcessQueue.length > 0) {
      for (const p of this.waitProcessQueue) {
        await p();
      }
    }

    this.waitProcessQueue = null;
  } // Separated just for better module testing


  async _processBodyAsyncImpl(body, isFromUser, updateContext) {
    if (updateContext) {
      const mergeMode = this.caps[Capabilities.SIMPLEREST_CONTEXT_MERGE_OR_REPLACE];
      const jsonPathsContext = getAllCapValues(Capabilities.SIMPLEREST_CONTEXT_JSONPATH, this.caps);

      if (jsonPathsContext.length > 0) {
        for (const jsonPathContext of jsonPathsContext) {
          const contextNodes = jsonpath.query(body, jsonPathContext);

          if (lodash.isArray(contextNodes) && contextNodes.length > 0) {
            if (mergeMode === 'MERGE') {
              Object.assign(this.view.context, contextNodes[0]);
            } else if (mergeMode === 'REPLACE') {
              this.view.context = contextNodes[0];
            }
          }
        }
      } else {
        if (mergeMode === 'MERGE') {
          Object.assign(this.view.context, body);
        } else if (mergeMode === 'REPLACE') {
          this.view.context = body;
        }
      }

      debug$4(`current session context: ${util.inspect(this.view.context)}`);
    }

    const result = [];

    if (isFromUser) {
      const jsonPathRoots = [];
      const jsonPathsBody = getAllCapValues(Capabilities.SIMPLEREST_BODY_JSONPATH, this.caps);

      if (jsonPathsBody.length > 0) {
        for (const jsonPathBody of jsonPathsBody) {
          const rb = jsonpath.query(body, jsonPathBody);

          if (lodash.isArray(rb)) {
            rb.forEach(r => jsonPathRoots.push(r));
          } else if (rb) {
            jsonPathRoots.push(rb);
          }
        }
      } else {
        jsonPathRoots.push(body);
      }

      for (const jsonPathRoot of jsonPathRoots) {
        const media = [];
        const buttons = [];
        const jsonPathsMedia = getAllCapValues(Capabilities.SIMPLEREST_MEDIA_JSONPATH, this.caps);
        jsonPathsMedia.forEach(jsonPath => {
          const responseMedia = jsonpath.query(jsonPathRoot, jsonPath);

          if (responseMedia) {
            (lodash.isArray(responseMedia) ? lodash.flattenDeep(responseMedia) : [responseMedia]).forEach(m => media.push({
              mediaUri: m,
              mimeType: mimeTypes.lookup(m) || 'application/unknown'
            }));
            debug$4(`found response media: ${util.inspect(media)}`);
          }
        });
        const jsonPathsButtons = getAllCapValues(Capabilities.SIMPLEREST_BUTTONS_JSONPATH, this.caps);
        jsonPathsButtons.forEach(jsonPath => {
          const responseButtons = jsonpath.query(jsonPathRoot, jsonPath);

          if (responseButtons) {
            (lodash.isArray(responseButtons) ? lodash.flattenDeep(responseButtons) : [responseButtons]).forEach(b => buttons.push({
              text: b
            }));
            debug$4(`found response buttons: ${util.inspect(buttons)}`);
          }
        });
        let hasMessageText = false;
        const jsonPathsTexts = getAllCapValues(Capabilities.SIMPLEREST_RESPONSE_JSONPATH, this.caps);

        for (const jsonPath of jsonPathsTexts) {
          debug$4(`eval json path ${jsonPath}`);
          const responseTexts = jsonpath.query(jsonPathRoot, jsonPath);
          debug$4(`found response texts: ${util.inspect(responseTexts)}`);
          const messageTexts = lodash.isArray(responseTexts) ? lodash.flattenDeep(responseTexts) : [responseTexts];

          for (const [messageTextIndex, messageText] of messageTexts.entries()) {
            if (!messageText) continue;
            hasMessageText = true;
            const botMsg = {
              sourceData: body,
              messageText,
              media,
              buttons
            };
            await executeHook(this.caps, this.responseHook, Object.assign({
              botMsg,
              botMsgRoot: jsonPathRoot,
              messageTextIndex
            }, this.view));
            result.push(botMsg);
          }
        }

        if (!hasMessageText) {
          const botMsg = {
            messageText: '',
            sourceData: body,
            media,
            buttons
          };
          const beforeHookKeys = Object.keys(botMsg);
          await executeHook(this.caps, this.responseHook, Object.assign({
            botMsg,
            botMsgRoot: jsonPathRoot
          }, this.view));
          const afterHookKeys = Object.keys(botMsg);

          if (beforeHookKeys.length !== afterHookKeys.length || !!(botMsg.messageText && botMsg.messageText.length > 0) || botMsg.media.length > 0 || botMsg.buttons.length > 0 || !this.caps[Capabilities.SIMPLEREST_IGNORE_EMPTY]) {
            result.push(botMsg);
          }
        }
      }
    }

    return result;
  }

  _doRequest(msg, isFromUser, updateContext) {
    return this._buildRequest(msg).then(requestOptions => new Promise((resolve, reject) => {
      debug$4(`constructed requestOptions ${JSON.stringify(requestOptions, null, 2)}`);
      msg.sourceData = msg.sourceData || {};
      msg.sourceData.requestOptions = requestOptions;
      this.waitProcessQueue = [];
      request(requestOptions, async (err, response, body) => {
        if (err) {
          return reject(new Error(`rest request failed: ${err.message}`));
        } else {
          if (response.statusCode >= 400) {
            debug$4(`got error response: ${response.statusCode}/${response.statusMessage}`);
            return reject(new Error(`got error response: ${response.statusCode}/${response.statusMessage}`));
          }

          if (body) {
            debug$4(`got response code: ${response.statusCode}, body: ${Utils.shortenJsonString(body)}`);

            try {
              body = await this._parseResponseBody(body);
            } catch (err) {
              debug$4(`ignoring not JSON formatted response body: ${err.message}`);
              resolve(this);

              this._emptyWaitProcessQueue();

              return;
            }

            if (body) {
              this._processBodyAsync(body, isFromUser, updateContext).then(() => resolve(this)).then(() => this._emptyWaitProcessQueue());
            } else {
              debug$4('ignoring response body (no string and no JSON object)');
              resolve(this);

              this._emptyWaitProcessQueue();
            }
          } else {
            debug$4(`got response code: ${response.statusCode}, empty body`);
            resolve(this);

            this._emptyWaitProcessQueue();
          }
        }
      });
    }));
  }

  async _buildRequest(msg) {
    this.view.msg = Object.assign({}, msg);
    const nonEncodedMessage = this.view.msg.messageText;
    this.view.msg.messageText = nonEncodedMessage && encodeURIComponent(nonEncodedMessage);

    if (this.caps[Capabilities.SIMPLEREST_STEP_ID_TEMPLATE]) {
      this.view.botium.stepId = this._getMustachedCap(Capabilities.SIMPLEREST_STEP_ID_TEMPLATE, false);
    } else {
      this.view.botium.stepId = uuidv4();
    }

    const uri = this._getMustachedCap(Capabilities.SIMPLEREST_URL, false);

    const timeout = this._getCapValue(Capabilities.SIMPLEREST_TIMEOUT);

    const requestOptions = {
      uri,
      method: this._getCapValue(Capabilities.SIMPLEREST_VERB) || this._getCapValue(Capabilities.SIMPLEREST_METHOD),
      followAllRedirects: true,
      timeout
    };

    if (this.caps[Capabilities.SIMPLEREST_HEADERS_TEMPLATE]) {
      this.view.msg.messageText = nonEncodedMessage;

      try {
        requestOptions.headers = this._getMustachedCap(Capabilities.SIMPLEREST_HEADERS_TEMPLATE, true);
      } catch (err) {
        throw new Error(`composing headers from SIMPLEREST_HEADERS_TEMPLATE failed (${err.message})`);
      }
    }

    if (this.caps[Capabilities.SIMPLEREST_BODY_TEMPLATE]) {
      const bodyRaw = this._getCapValue(Capabilities.SIMPLEREST_BODY_RAW);

      if (bodyRaw) {
        this.view.msg.messageText = nonEncodedMessage;
      } else {
        this.view.msg.messageText = nonEncodedMessage && escapeJSONString(nonEncodedMessage);
      }

      try {
        requestOptions.body = this._getMustachedCap(Capabilities.SIMPLEREST_BODY_TEMPLATE, !bodyRaw);
        requestOptions.json = !bodyRaw;
      } catch (err) {
        throw new Error(`composing body from SIMPLEREST_BODY_TEMPLATE failed (${err.message})`);
      }
    }

    this.view.msg.messageText = nonEncodedMessage;

    if (msg.ADD_QUERY_PARAM && Object.keys(msg.ADD_QUERY_PARAM).length > 0) {
      const appendToUri = Object.keys(msg.ADD_QUERY_PARAM).map(key => `${encodeURIComponent(key)}=${encodeURIComponent(this._getMustachedVal(lodash.isString(msg.ADD_QUERY_PARAM[key]) ? msg.ADD_QUERY_PARAM[key] : JSON.stringify(msg.ADD_QUERY_PARAM[key]), false))}`).join('&');

      if (requestOptions.uri.indexOf('?') > 0) {
        requestOptions.uri = `${requestOptions.uri}&${appendToUri}`;
      } else {
        requestOptions.uri = `${requestOptions.uri}?${appendToUri}`;
      }
    }

    if (msg.ADD_HEADER && Object.keys(msg.ADD_HEADER).length > 0) {
      requestOptions.headers = requestOptions.headers || {};

      for (const headerKey of Object.keys(msg.ADD_HEADER)) {
        let headerValue;

        if (lodash.isString(msg.ADD_HEADER[headerKey])) {
          headerValue = this._getMustachedVal(msg.ADD_HEADER[headerKey], false);
        } else {
          headerValue = this._getMustachedVal(JSON.stringify(msg.ADD_HEADER[headerKey]), true);
        }

        requestOptions.headers[headerKey] = headerValue;
      }
    }

    this._addRequestOptions(requestOptions);

    await executeHook(this.caps, this.requestHook, Object.assign({
      requestOptions
    }, this.view));
    return requestOptions;
  }

  async _waitForUrlResponse(pingConfig, retries) {
    const timeout = ms => new Promise(resolve => setTimeout(resolve, ms));

    let tries = 0;

    while (true) {
      debug$4(`_waitForUrlResponse checking url ${pingConfig.uri} before proceed`);

      if (tries > retries) {
        throw new Error(`Failed to ping bot after ${retries} retries`);
      }

      tries++;
      const {
        err,
        response,
        body
      } = await new Promise(resolve => {
        request(pingConfig, (err, response, body) => {
          resolve({
            err,
            response,
            body
          });
        });
      });

      if (err) {
        debug$4(`_waitForUrlResponse error on url check ${pingConfig.uri}: ${err}`);
        await timeout(pingConfig.timeout);
      } else if (response.statusCode >= 400) {
        debug$4(`_waitForUrlResponse on url check ${pingConfig.uri} got error response: ${response.statusCode}/${response.statusMessage}`);
        await timeout(pingConfig.timeout);
      } else {
        debug$4(`_waitForUrlResponse success on url check ${pingConfig.uri}`);
        return body;
      }
    }
  }

  async _parseResponseBody(body) {
    if (!lodash.isObject(body) && lodash.isString(body)) {
      try {
        body = JSON.parse(body);
      } catch (err) {
        if (!this.parserHook) throw err;
      }
    }

    if (this.parserHook) {
      await executeHook(this.caps, this.parserHook, Object.assign({
        body,
        changeBody: b => {
          body = b;
        }
      }, this.view));
    }

    if (lodash.isObject(body)) return body;else if (lodash.isString(body)) return JSON.parse(body);else return null;
  }

  _getCapValue(capName) {
    return lodash.isFunction(this.caps[capName]) ? this.caps[capName]() : this.caps[capName];
  }

  _getMustachedCap(capName, json) {
    const capValue = this._getCapValue(capName);

    const template = lodash.isString(capValue) ? capValue : JSON.stringify(capValue);
    return this._getMustachedVal(template, json);
  }

  _getMustachedVal(template, json) {
    const raw = mustache.render(template, this.view);

    if (json) {
      try {
        return JSON.parse(raw);
      } catch (err) {
        return new Error(`JSON parsing failed - try to use {{#fnc.jsonify}}{{xxx}}{{/fnc.jsonify}} to escape JSON special characters (ERR: ${err.message})`);
      }
    } else {
      return raw;
    }
  }

  _processInboundEvent(event) {
    if (!this.processInbound) return;
    const jsonPathValue = this.caps[Capabilities.SIMPLEREST_INBOUND_SELECTOR_VALUE];
    const jsonPathsSelector = getAllCapValues(Capabilities.SIMPLEREST_INBOUND_SELECTOR_JSONPATH, this.caps);

    if (jsonPathsSelector && jsonPathsSelector.length > 0) {
      let isSelected = false;

      for (const jsonPathTemplate of jsonPathsSelector) {
        const jsonPath = this._getMustachedVal(jsonPathTemplate, false);

        const hasResult = jsonpath.query(event, jsonPath);

        if (hasResult && hasResult.length > 0) {
          const check = jsonPathValue && this._getMustachedVal(jsonPathValue, false);

          if (check) {
            if (`${hasResult[0]}` === `${check}`) {
              isSelected = true;
              break;
            }
          } else {
            isSelected = true;
            break;
          }
        }
      }

      if (!isSelected) return;
    }

    debug$4(`Received an inbound message: ${JSON.stringify(event)}`);

    if (this.caps[Capabilities.SIMPLEREST_INBOUND_ORDER_UNSETTLED_EVENTS_JSONPATH]) {
      this.inboundEvents.push(event);

      this._processOrderedInboundEventsArrayAsync();
    } else {
      setTimeout(() => this._processBodyAsync(event.body, true, !!this.caps[Capabilities.SIMPLEREST_INBOUND_UPDATE_CONTEXT]), 0);
    }
  }

  async _buildInbound() {
    if (this.caps[Capabilities.SIMPLEREST_INBOUND_REDISURL] && this.caps[Capabilities.SIMPLEREST_INBOUND_SELECTOR_JSONPATH] && this.caps[Capabilities.SIMPLEREST_INBOUND_SELECTOR_VALUE]) {
      this.redis = new ioredis(this.caps[Capabilities.SIMPLEREST_INBOUND_REDISURL]);
      this.redis.on('connect', () => {
        debug$4(`Redis connected to ${JSON.stringify(this.caps[Capabilities.SIMPLEREST_INBOUND_REDISURL] || 'default')}`);
      });
      this.redis.on('message', (channel, event) => {
        if (!lodash.isString(event)) {
          return debug$4(`WARNING: received non-string message from ${channel}, ignoring: ${event}`);
        }

        try {
          event = JSON.parse(event);
        } catch (err) {
          return debug$4(`WARNING: received non-json message from ${channel}, ignoring: ${event}`);
        }

        this._processInboundEvent(event);
      });
    } else if (this.caps[Capabilities.SIMPLEREST_INBOUND_PORT]) {
      this.proxy = await startProxy({
        port: this.caps[Capabilities.SIMPLEREST_INBOUND_PORT],
        endpoint: this.caps[Capabilities.SIMPLEREST_INBOUND_ENDPOINT],
        processEvent: event => {
          if (this.processingEvents) {
            debug$4('Got Inbound Event:');
            debug$4(JSON.stringify(event, null, 2));

            this._processInboundEvent(event);
          }
        }
      });
    }
  }

  async _subscribeInbound() {
    this.processingEvents = true;

    if (this.redis) {
      try {
        const count = await this.redis.subscribe(this.redisTopic);
        debug$4(`Redis subscribed to ${count} channels. Listening for inbound messages on the ${this.redisTopic} channel.`);
      } catch (err) {
        debug$4(err);
        throw new Error(`Redis failed to subscribe channel ${this.redisTopic}: ${err.message || err}`);
      }
    }
  }

  async _unsubscribeInbound() {
    this.processingEvents = false;

    if (this.redis) {
      try {
        await this.redis.unsubscribe(this.redisTopic);
        debug$4(`Redis unsubscribed from ${this.redisTopic} channel.`);
      } catch (err) {
        debug$4(err);
        throw new Error(`Redis failed to unsubscribe channel ${this.redisTopic}: ${err.message || err}`);
      }
    }
  }

  async _cleanInbound() {
    if (this.redis) {
      this.redis.disconnect();
      this.redis = null;
    }

    if (this.proxy) {
      this.proxy.close();
      this.proxy = null;
    }
  }

  async _runPolling() {
    if (!this.processInbound) return;

    if (this.caps[Capabilities.SIMPLEREST_POLL_URL]) {
      const uri = this._getMustachedCap(Capabilities.SIMPLEREST_POLL_URL, false);

      const verb = this._getCapValue(Capabilities.SIMPLEREST_POLL_VERB);

      const timeout = this._getCapValue(Capabilities.SIMPLEREST_POLL_TIMEOUT);

      const pollConfig = {
        method: verb,
        uri: uri,
        followAllRedirects: true,
        timeout: timeout
      };

      if (this.caps[Capabilities.SIMPLEREST_POLL_HEADERS]) {
        try {
          pollConfig.headers = this._getMustachedCap(Capabilities.SIMPLEREST_POLL_HEADERS, true);
        } catch (err) {
          debug$4(`_runPolling: composing headers from SIMPLEREST_POLL_HEADERS failed (${err.message})`);
          return;
        }
      }

      if (this.caps[Capabilities.SIMPLEREST_POLL_BODY]) {
        const bodyRaw = this._getCapValue(Capabilities.SIMPLEREST_POLL_BODY_RAW);

        try {
          pollConfig.body = this._getMustachedCap(Capabilities.SIMPLEREST_POLL_BODY, !bodyRaw);
          pollConfig.json = !bodyRaw;
        } catch (err) {
          debug$4(`_runPolling: composing body from SIMPLEREST_POLL_BODY failed (${err.message})`);
          return;
        }
      }

      this._addRequestOptions(pollConfig);

      try {
        await executeHook(this.caps, this.pollRequestHook, Object.assign({
          requestOptions: pollConfig
        }, this.view));
      } catch (err) {
        debug$4(`_runPolling: exeucting request hook failed - (${err.message})`);
        return;
      }

      request(pollConfig, async (err, response, body) => {
        if (err) {
          debug$4(`_runPolling: rest request failed: ${err.message}, request: ${JSON.stringify(pollConfig)}`);
        } else {
          if (response.statusCode >= 400) {
            debug$4(`_runPolling: got error response: ${response.statusCode}/${response.statusMessage}, request: ${JSON.stringify(pollConfig)}`);
          } else if (body) {
            debug$4(`_runPolling: got response code: ${response.statusCode}, body: ${Utils.shortenJsonString(body)}`);

            try {
              body = await this._parseResponseBody(body);
            } catch (err) {
              debug$4(`_runPolling: ignoring not JSON formatted response body: ${err.message}`);
              return;
            }

            if (body) {
              setTimeout(() => this._processBodyAsync(body, true, !!this.caps[Capabilities.SIMPLEREST_POLL_UPDATE_CONTEXT]), 0);
            } else {
              debug$4('_runPolling: ignoring response body (no string and no JSON object)');
            }
          } else {
            debug$4(`_runPolling: got response code: ${response.statusCode}, empty body`);
          }
        }
      });
    }
  }

  async _startPolling() {
    if (this.caps[Capabilities.SIMPLEREST_POLL_URL]) {
      this.pollInterval = setInterval(this._runPolling.bind(this), this.caps[Capabilities.SIMPLEREST_POLL_INTERVAL]);
      debug$4(`Started HTTP polling for inbound messages on ${this.caps[Capabilities.SIMPLEREST_POLL_URL]}, interval: ${this.caps[Capabilities.SIMPLEREST_POLL_INTERVAL]}.`);
    }
  }

  async _stopPolling() {
    if (this.pollInterval) {
      clearInterval(this.pollInterval);
      this.pollInterval = null;
      debug$4(`Stopped HTTP polling for inbound messages on ${this.caps[Capabilities.SIMPLEREST_POLL_URL]}.`);
    }
  }

  async _makeCall(capPrefix) {
    const uri = this._getMustachedCap(`${capPrefix}_URL`, false);

    const verb = this._getCapValue(`${capPrefix}_VERB`);

    const timeout = this._getCapValue(`${capPrefix}_TIMEOUT`) || this._getCapValue(Capabilities.SIMPLEREST_TIMEOUT);

    const httpConfig = {
      method: verb,
      uri: uri,
      followAllRedirects: true,
      timeout: timeout
    };

    if (this.caps[`${capPrefix}_HEADERS`]) {
      try {
        httpConfig.headers = this._getMustachedCap(`${capPrefix}_HEADERS`, true);
      } catch (err) {
        throw new Error(`composing headers from ${capPrefix}_HEADERS failed (${err.message})`);
      }
    }

    if (this.caps[`${capPrefix}_BODY`]) {
      const bodyRaw = this._getCapValue(`${capPrefix}_BODY_RAW`);

      try {
        httpConfig.body = this._getMustachedCap(`${capPrefix}_BODY`, !bodyRaw);
        httpConfig.json = !bodyRaw;
      } catch (err) {
        throw new Error(`composing body from ${capPrefix}_BODY failed (${err.message})`);
      }
    }

    this._addRequestOptions(httpConfig);

    await executeHook(this.caps, this.requestHooks[capPrefix], Object.assign({
      requestOptions: httpConfig
    }, this.view));

    const retries = this._getCapValue(`${capPrefix}_RETRIES`);

    debug$4(`_makeCall(${capPrefix}): rest request: ${JSON.stringify(httpConfig)}`);
    const response = await this._waitForUrlResponse(httpConfig, retries);
    return response;
  }

  _addRequestOptions(httpConfig) {
    httpConfig.strictSSL = !!this.caps[Capabilities.SIMPLEREST_STRICT_SSL];

    if (this.caps[Capabilities.SIMPLEREST_PROXY_URL]) {
      httpConfig.proxy = this.caps[Capabilities.SIMPLEREST_PROXY_URL];
    }

    if (this.caps[Capabilities.SIMPLEREST_EXTRA_OPTIONS]) {
      lodash.merge(httpConfig, this.caps[Capabilities.SIMPLEREST_EXTRA_OPTIONS]);
    }
  }

};

const debug$3 = debug$l('botium-connector-PluginConnectorContainer-helper');
const {
  BotiumError
} = BotiumError_1;

const pluginResolver = containermode => {
  if (containermode === 'simplerest') {
    return SimpleRestContainer_1;
  }
};

const getModuleVersionSafe = required => {
  try {
    const pckg = commonjsRequire(required + '/package.json');

    if (pckg.version === undefined) {
      return 'Not set';
    } else {
      return pckg.version;
    }
  } catch (e) {
    if (e.code !== 'MODULE_NOT_FOUND') {
      return 'Unknown error while determining version';
    }

    return 'Unknown version';
  }
};

const loadConnectorModule = (PluginClass, args) => {
  try {
    return new PluginClass(args);
  } catch (err) {}

  if (lodash.isFunction(PluginClass)) {
    const result = PluginClass(args);

    if (result && result.UserSays) {
      return result;
    } else {
      return {
        UserSays: msg => {
          const response = PluginClass(msg, args);

          if (response && args.queueBotSays) {
            if (lodash.isString(response)) {
              setTimeout(() => args.queueBotSays({
                messageText: response
              }), 0);
            } else {
              setTimeout(() => args.queueBotSays(response), 0);
            }
          }
        }
      };
    }
  } else {
    throw new Error('Botium Plugin is neither a class nor a function');
  }
};

const tryLoadPlugin$1 = (containermode, modulepath, args) => {
  const pluginLoaderSpec = modulepath || containermode;

  const _checkUnsafe = (caps, mode, cause) => {
    if (!caps[Capabilities.SECURITY_ALLOW_UNSAFE]) {
      throw new BotiumError(`Security Error. Using unsafe connector mode "${mode}" is not allowed`, {
        type: 'security',
        subtype: 'allow unsafe',
        source: 'src/containers/plugins/index.js',
        cause: {
          SECURITY_ALLOW_UNSAFE: caps[Capabilities.SECURITY_ALLOW_UNSAFE],
          mode: mode,
          ...cause
        }
      });
    }
  };

  if (pluginResolver(pluginLoaderSpec)) {
    const pluginInstance = new (pluginResolver(pluginLoaderSpec))(args);
    debug$3('Botium plugin loaded from internal plugin resolver');
    return pluginInstance;
  }

  if (lodash.isFunction(pluginLoaderSpec)) {
    const pluginInstance = pluginLoaderSpec(args);
    debug$3('Botium plugin loaded from function call');
    return pluginInstance;
  }

  const loadErr = [];

  if (lodash.isString(pluginLoaderSpec)) {
    const tryLoadFile = path.resolve(process.cwd(), pluginLoaderSpec);

    if (fs.existsSync(tryLoadFile)) {
      _checkUnsafe(args.caps, 'Using work dir', {
        modulepath,
        containermode
      });

      try {
        let plugin = commonjsRequire(tryLoadFile);

        if (plugin.default) {
          plugin = plugin.default;
        }

        if (!plugin.PluginVersion || !plugin.PluginClass) {
          loadErr.push(`Invalid Botium plugin loaded from ${tryLoadFile}, expected PluginVersion, PluginClass fields`);
        } else {
          const pluginInstance = loadConnectorModule(plugin.PluginClass, args);
          debug$3(`Botium plugin loaded from ${tryLoadFile}`);
          return pluginInstance;
        }
      } catch (err) {
        loadErr.push(`Loading Botium plugin from ${tryLoadFile} failed - ${err.message}`);
      }
    }

    try {
      let plugin = commonjsRequire(pluginLoaderSpec);

      if (plugin.default) {
        plugin = plugin.default;
      }

      if (!plugin.PluginVersion || !plugin.PluginClass) {
        loadErr.push(`Invalid Botium plugin loaded from ${pluginLoaderSpec}, expected PluginVersion, PluginClass fields`);
      } else {
        const pluginInstance = loadConnectorModule(plugin.PluginClass, args);
        debug$3(`Botium plugin loaded from ${pluginLoaderSpec}. Plugin version is ${getModuleVersionSafe(pluginLoaderSpec)}`);
        return pluginInstance;
      }
    } catch (err) {
      loadErr.push(`Loading Botium plugin from ${pluginLoaderSpec} failed - ${err.message}`);
    }

    const tryLoadPackage = `botium-connector-${pluginLoaderSpec}`;

    try {
      let plugin = commonjsRequire(tryLoadPackage);

      if (plugin.default) {
        plugin = plugin.default;
      }

      if (!plugin.PluginVersion || !plugin.PluginClass) {
        loadErr.push(`Invalid Botium plugin ${tryLoadPackage}, expected PluginVersion, PluginClass fields`);
      } else {
        const pluginInstance = loadConnectorModule(plugin.PluginClass, args);
        debug$3(`Botium plugin ${tryLoadPackage} loaded. Plugin version is ${getModuleVersionSafe(tryLoadPackage)}`);
        return pluginInstance;
      }
    } catch (err) {
      loadErr.push(`Loading Botium plugin ${tryLoadPackage} failed, try "npm install ${tryLoadPackage}" - ${err.message}`);
    }
  }

  throw new Error(`Loading Botium Plugin failed.\r\n${loadErr.join('\r\n')}`);
};

var plugins = {
  pluginResolver,
  getModuleVersionSafe,
  tryLoadPlugin: tryLoadPlugin$1
};

const debug$2 = debug$l('botium-connector-PluginConnectorContainer');
const {
  tryLoadPlugin
} = plugins;
var PluginConnectorContainer_1 = class PluginConnectorContainer extends BaseContainer_1 {
  async Validate() {
    await super.Validate();
    this.pluginInstance = tryLoadPlugin(this.caps[Capabilities.CONTAINERMODE], this.caps[Capabilities.PLUGINMODULEPATH], {
      container: this,
      queueBotSays: msg => this._QueueBotSays(msg),
      eventEmitter: this.eventEmitter,
      caps: this.caps,
      sources: this.sources,
      envs: this.envs
    });

    if (!this.pluginInstance) {
      throw new Error('Loading Botium plugin failed');
    }

    if (!this.pluginInstance.UserSays) {
      throw new Error('Invalid Botium plugin, expected UserSays function');
    }

    if (this.pluginInstance.Validate) {
      await this.pluginInstance.Validate();
    }

    this.retryHelperBuild = new RetryHelper_1(this.caps, 'BUILD');
    this.retryHelperStart = new RetryHelper_1(this.caps, 'START');
    this.retryHelperUserSays = new RetryHelper_1(this.caps, 'USERSAYS');
    this.retryHelperStop = new RetryHelper_1(this.caps, 'STOP');
    this.retryHelperClean = new RetryHelper_1(this.caps, 'CLEAN');
  }

  Build() {
    try {
      return super.Build().then(() => promiseRetry((retry, number) => {
        return (this.pluginInstance.Build ? this.pluginInstance.Build() || Promise.resolve() : Promise.resolve()).catch(err => {
          if (this.retryHelperBuild.shouldRetry(err)) {
            debug$2(`Build trial #${number} failed, retry activated`);
            retry(err);
          } else {
            throw err;
          }
        });
      }, this.retryHelperBuild.retrySettings)).then(() => this);
    } catch (err) {
      return Promise.reject(new Error(`Build - Botium plugin failed: ${util.inspect(err)}`));
    }
  }

  Start() {
    this.eventEmitter.emit(Events.CONTAINER_STARTING, this);

    try {
      return super.Start().then(() => promiseRetry((retry, number) => {
        return (this.pluginInstance.Start ? this.pluginInstance.Start() || Promise.resolve() : Promise.resolve()).catch(err => {
          if (this.retryHelperStart.shouldRetry(err)) {
            debug$2(`Start trial #${number} failed, retry activated`);
            retry(err);
          } else {
            throw err;
          }
        });
      }, this.retryHelperStart.retrySettings)).then(context => {
        this.eventEmitter.emit(Events.CONTAINER_STARTED, this, context);
        return this;
      }).catch(err => {
        this.eventEmitter.emit(Events.CONTAINER_START_ERROR, this, err);
        throw err;
      });
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_START_ERROR, this, err);
      return Promise.reject(new Error(`Start - Botium plugin failed: ${util.inspect(err)}`));
    }
  }

  UserSaysImpl(mockMsg) {
    try {
      return promiseRetry((retry, number) => {
        return (this.pluginInstance.UserSays(mockMsg) || Promise.resolve()).catch(err => {
          if (this.retryHelperUserSays.shouldRetry(err)) {
            debug$2(`UserSays trial #${number} failed, retry activated`);
            retry(err);
          } else {
            throw err;
          }
        });
      }, this.retryHelperUserSays.retrySettings).then(() => {
        this.eventEmitter.emit(Events.MESSAGE_SENTTOBOT, this, mockMsg);
        return this;
      });
    } catch (err) {
      return Promise.reject(new Error(`UserSays - Botium plugin failed: ${util.inspect(err)}`));
    }
  }

  Stop() {
    this.eventEmitter.emit(Events.CONTAINER_STOPPING, this);

    try {
      return super.Stop().then(() => promiseRetry((retry, number) => {
        return (this.pluginInstance.Stop ? this.pluginInstance.Stop() || Promise.resolve() : Promise.resolve()).catch(err => {
          if (this.retryHelperStop.shouldRetry(err)) {
            debug$2(`Stop trial #${number} failed, retry activated`);
            retry(err);
          } else {
            throw err;
          }
        });
      }, this.retryHelperStop.retrySettings)).then(context => {
        this.eventEmitter.emit(Events.CONTAINER_STOPPED, this, context);
        return this;
      }).catch(err => {
        this.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this, err);
        throw err;
      });
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_STOP_ERROR, this, err);
      return Promise.reject(new Error(`Stop - Botium plugin failed: ${util.inspect(err)}`));
    }
  }

  Clean() {
    this.eventEmitter.emit(Events.CONTAINER_CLEANING, this);

    try {
      return promiseRetry((retry, number) => {
        return (this.pluginInstance.Clean ? this.pluginInstance.Clean() || Promise.resolve() : Promise.resolve()).catch(err => {
          if (this.retryHelperClean.shouldRetry(err)) {
            debug$2(`Clean trial #${number} failed, retry activated`);
            retry(err);
          } else {
            throw err;
          }
        });
      }, this.retryHelperClean.retrySettings).then(() => super.Clean()).then(() => {
        this.eventEmitter.emit(Events.CONTAINER_CLEANED, this);
        return this;
      }).catch(err => {
        this.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this, err);
        throw err;
      });
    } catch (err) {
      this.eventEmitter.emit(Events.CONTAINER_CLEAN_ERROR, this, err);
      return Promise.reject(new Error(`Clean - Botium plugin failed: ${util.inspect(err)}`));
    }
  }

};

var require$$2 = getCjsExportFromNamespace(_package$1);

const {
  boolean
} = boolean$1;
const debug$1 = debug$l('botium-core-BotDriver');
const {
  version
} = require$$2;
var BotDriver_1 = class BotDriver {
  constructor(caps = {}, sources = {}, envs = {}) {
    this.eventEmitter = new events();
    this.caps = lodash.cloneDeep(Defaults$1.Capabilities);
    this.sources = lodash.cloneDeep(Defaults$1.Sources);
    this.envs = lodash.cloneDeep(Defaults$1.Envs);
    this._fetchedConfigFiles = [];

    this._fetchConfigFromFiles(['./botium.json', process.env.NODE_ENV && `./botium.${process.env.NODE_ENV}.json`, './botium.local.json', process.env.NODE_ENV && `./botium.${process.env.NODE_ENV}.local.json`]);

    const botiumConfigEnv = process.env.BOTIUM_CONFIG;

    if (botiumConfigEnv) {
      const checkDir = path.dirname(botiumConfigEnv);
      const checkFileBase = path.basename(botiumConfigEnv, '.json');

      if (!this._fetchConfigFromFiles([botiumConfigEnv, process.env.NODE_ENV && path.join(checkDir, `${checkFileBase}.${process.env.NODE_ENV}.json`), path.join(checkDir, `${checkFileBase}.local.json`), process.env.NODE_ENV && path.join(checkDir, `${checkFileBase}.${process.env.NODE_ENV}.local.json`)])) {
        throw new Error(`FAILED: Botium configuration file ${botiumConfigEnv} not available`);
      }
    }

    debug$1(`Loaded Botium configuration files ${this._fetchedConfigFiles.join(',')}`);
    const sourcesToTest = Object.keys(Source);
    Object.keys(process.env).filter(e => e.startsWith('BOTIUM_')).forEach(element => {
      const elementToTest = element.replace(/^BOTIUM_/, '');

      if (sourcesToTest.includes(elementToTest)) {
        this._mergeCaps(this.sources, {
          [elementToTest]: process.env[element]
        });
      } else {
        this._mergeCaps(this.caps, {
          [elementToTest]: process.env[element]
        });
      }

      if (element.startsWith('BOTIUM_ENV_')) {
        const envName = element.replace(/^BOTIUM_ENV_/, '');
        this.envs[envName] = process.env[element];
      }
    });
    if (caps) this._mergeCaps(this.caps, caps);
    if (sources) this._mergeCaps(this.sources, sources);
    if (envs) this.envs = lodash.merge(this.envs, envs);
  }

  on(event, listener) {
    this.eventEmitter.on(event, listener);
    return this;
  }

  setCapabilities(caps) {
    this._mergeCaps(this.caps, caps);

    return this;
  }

  setCapability(cap, value) {
    this._mergeCaps(this.caps, {
      [cap]: value
    });

    return this;
  }

  setSources(sources) {
    this._mergeCaps(this.sources, sources);

    return this;
  }

  setSource(source, value) {
    this._mergeCaps(this.sources, {
      [source]: value
    });

    return this;
  }

  setEnvs(envs) {
    this.envs = lodash.merge(this.envs, envs);
    return this;
  }

  setEnv(name, value) {
    this.envs[name] = value;
    return this;
  }

  BuildFluent() {
    this.Fluent = new Fluent_1(this);
    return this.Fluent;
  }

  Build() {
    debug$1(`Build - Botium Core Version: ${version}`);
    debug$1(`Build - Capabilites: ${util.inspect(this.caps)}`);
    debug$1(`Build - Sources : ${util.inspect(this.sources)}`);
    debug$1(`Build - Envs : ${util.inspect(this.envs)}`);
    this.eventEmitter.emit(Events.CONTAINER_BUILDING);
    return new Promise((resolve, reject) => {
      let repo = null;
      let container = null;
      async.series([driverValidated => {
        this._validate().then(() => driverValidated()).catch(driverValidated);
      }, repoValidated => {
        try {
          repo = this._getRepo();
        } catch (err) {
          return repoValidated(err);
        }

        repo.Validate().then(() => repoValidated()).catch(repoValidated);
      }, repoPrepared => {
        repo.Prepare().then(() => repoPrepared()).catch(repoPrepared);
      }, containerValidated => {
        try {
          container = this._getContainer(repo);
        } catch (err) {
          return containerValidated(err);
        }

        container.Validate().then(() => containerValidated()).catch(containerValidated);
      }, containerBuilt => {
        container.Build().then(() => containerBuilt()).catch(containerBuilt);
      }], err => {
        if (err) {
          debug$1(`BotDriver Build error: ${err}`);
          this.eventEmitter.emit(Events.CONTAINER_BUILD_ERROR, err);

          if (this.tempDirectory) {
            rimraf(this.tempDirectory, err => {
              if (err) debug$1(`Cleanup temp dir ${this.tempDirectory} failed: ${util.inspect(err)}`);
            });
          }

          return reject(err);
        }

        this.eventEmitter.emit(Events.CONTAINER_BUILT, container);
        resolve(container);
      });
    });
  }

  BuildCompiler() {
    try {
      const compiler = new ScriptingProvider_1(this.caps);
      compiler.Build();
      return compiler;
    } catch (err) {
      debug$1(`BotDriver BuildCompiler error: ${err}`);
      throw err;
    }
  }
  /* Private Functions */
  // loadConfig from files


  _loadConfigFile(filename) {
    try {
      const configJson = JSON.parse(fs.readFileSync(filename));

      if (configJson.botium) {
        if (configJson.botium.Capabilities) this._mergeCaps(this.caps, configJson.botium.Capabilities);
        if (configJson.botium.Sources) this._mergeCaps(this.sources, configJson.botium.Sources);
        if (configJson.botium.Envs) this._mergeCaps(this.envs, configJson.botium.Envs);
        return true;
      } else {
        debug$1(`Botium configuration file ${filename} contains no botium configuration. Ignored.`);
        return false;
      }
    } catch (err) {
      throw new Error(`FAILED: loading Botium configuration file ${filename}: ${util.inspect(err)}`);
    }
  } // fetches config from files ordered by priority later files overwrite previous


  _fetchConfigFromFiles(files) {
    const fetchedFiles = [];

    for (const file of files) {
      if (file && fs.existsSync(file)) {
        const absFilePath = path.resolve(file);

        if (this._fetchedConfigFiles.indexOf(absFilePath) < 0) {
          this._loadConfigFile(file);

          fetchedFiles.push(file);

          this._fetchedConfigFiles.push(absFilePath);
        } else {
          fetchedFiles.push(file);
        }
      }
    }

    return fetchedFiles;
  }

  _findKeyProperty(obj) {
    const lookup = ['id', 'ID', 'Id', 'ref', 'REF', 'Ref', 'name', 'NAME', 'Name'];

    for (const checkPropIdx in lookup) {
      if (Object.prototype.hasOwnProperty.call(obj, lookup[checkPropIdx])) return lookup[checkPropIdx];
    }
  }

  _mergeCaps(caps, newCaps) {
    if (!caps) return;
    Object.keys(newCaps).forEach(capKey => {
      if (!Object.prototype.hasOwnProperty.call(caps, capKey)) {
        if (lodash.isString(newCaps[capKey])) {
          try {
            caps[capKey] = JSON.parse(newCaps[capKey]);

            if (lodash.isFinite(caps[capKey])) {
              caps[capKey] = caps[capKey].toString();
            }
          } catch (err) {
            caps[capKey] = newCaps[capKey];
          }
        } else {
          caps[capKey] = newCaps[capKey];
        }

        return;
      }

      if (lodash.isArray(caps[capKey])) {
        let newCapArray = newCaps[capKey];

        if (!lodash.isArray(newCapArray)) {
          try {
            newCapArray = JSON.parse(newCapArray);
          } catch (err) {
            debug$1(`Expected JSON Array in capability ${capKey}, JSON parse failed (${err}). Capability will be overwritten with maybe unexpected side effects.`);
          }
        }

        if (lodash.isArray(newCapArray)) {
          newCapArray.forEach(capElement => {
            const mergeKey = this._findKeyProperty(capElement);

            if (mergeKey) {
              const oldElement = caps[capKey].find(oldElement => oldElement[mergeKey] && oldElement[mergeKey] === capElement[mergeKey]);

              if (oldElement) {
                lodash.merge(oldElement, capElement);

                return;
              }

              caps[capKey].push(capElement);
            } else {
              if (caps[capKey].indexOf(capElement) < 0) {
                caps[capKey].push(capElement);
              }
            }
          });
          return;
        }
      }

      if (!lodash.isArray(caps[capKey]) && lodash.isObject(caps[capKey])) {
        let newCapObject = newCaps[capKey];

        if (!lodash.isObject(newCapObject)) {
          try {
            newCapObject = JSON.parse(newCapObject);
          } catch (err) {
            debug$1(`Expected JSON Object in capability ${capKey}, JSON parse failed (${err}). Capability will be overwritten with maybe unexpected side effects.`);
          }
        }

        if (lodash.isObject(newCapObject)) {
          lodash.merge(caps[capKey], newCapObject);

          return;
        }
      }

      if (lodash.isBoolean(caps[capKey])) {
        if (!lodash.isBoolean(newCaps[capKey])) {
          caps[capKey] = boolean(newCaps[capKey]);
          return;
        }
      }

      caps[capKey] = newCaps[capKey];
    });
  }

  _validate() {
    return new Promise((resolve, reject) => {
      try {
        if (!this.caps[Capabilities.PROJECTNAME]) {
          throw new Error(`Capability property ${Capabilities.PROJECTNAME} not set`);
        }

        if (!this.caps[Capabilities.TEMPDIR]) {
          throw new Error(`Capability property ${Capabilities.TEMPDIR} not set`);
        }

        if (!this.caps[Capabilities.CONTAINERMODE] && !this.caps[Capabilities.BOTIUMGRIDURL]) {
          throw new Error(`Capability '${Capabilities.CONTAINERMODE}' or '${Capabilities.BOTIUMGRIDURL}' missing`);
        }

        this.tempDirectory = path.resolve(process.cwd(), this.caps[Capabilities.TEMPDIR], sanitizeFilename(`${this.caps[Capabilities.PROJECTNAME]} ${moment().format('YYYYMMDD HHmmss')} ${randomatic('Aa0', 5)}`));

        try {
          mkdirp.sync(this.tempDirectory);
        } catch (err) {
          throw new Error(`Unable to create temp directory ${this.tempDirectory}: ${err}`);
        }

        resolve(this);
      } catch (err) {
        reject(err);
      }
    });
  }

  _getRepo() {
    if (this.caps[Capabilities.BOTIUMGRIDURL]) {
      const NoRepo = NoRepo_1;
      return new NoRepo(this.tempDirectory, this.sources);
    }

    if (this.sources[Source.GITURL]) {
      const GitRepo = GitRepo_1;
      return new GitRepo(this.tempDirectory, this.sources);
    }

    if (this.sources[Source.LOCALPATH]) {
      const LocalRepo = LocalRepo_1;
      return new LocalRepo(this.tempDirectory, this.sources);
    }

    throw new Error(`No Repo provider found for Sources ${util.inspect(this.sources)}`);
  }

  _getContainer(repo) {
    if (this.caps[Capabilities.BOTIUMGRIDURL]) {
      const GridContainer = GridContainer_1;
      return new GridContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs);
    }

    if (!this.caps[Capabilities.CONTAINERMODE]) {
      throw new Error(`Capability '${Capabilities.CONTAINERMODE}' missing`);
    }

    if (this.caps[Capabilities.CONTAINERMODE] === 'inprocess') {
      const InProcessContainer = InProcessContainer_1;
      return new InProcessContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs);
    }

    const PluginConnectorContainer = PluginConnectorContainer_1;
    return new PluginConnectorContainer(this.eventEmitter, this.tempDirectory, repo, this.caps, this.envs);
  }

};

const debug = debug$l('botium-core-Plugins');
const PLUGIN_TYPE_CONNECTOR = 'PLUGIN_TYPE_CONNECTOR';
const PLUGIN_TYPE_ASSERTER = 'PLUGIN_TYPE_ASSERTER';
const PLUGIN_TYPE_LOGICHOOK = 'PLUGIN_TYPE_LOGICHOOK';
const PLUGIN_TYPE_USERINPUT = 'PLUGIN_TYPE_USERINPUT';
const TYPE_TO_PREFIX = {
  PLUGIN_TYPE_CONNECTOR: 'botium-connector-',
  PLUGIN_TYPE_ASSERTER: 'botium-asserter-',
  PLUGIN_TYPE_LOGICHOOK: 'botium-logichook-',
  PLUGIN_TYPE_USERINPUT: 'botium-userinput-'
};
const TYPE_TO_COMPONENT_TYPE = {
  PLUGIN_TYPE_ASSERTER: 'ASSERTER',
  PLUGIN_TYPE_LOGICHOOK: 'LOGICHOOK',
  PLUGIN_TYPE_USERINPUT: 'USERINPUT'
};

const getConnectorPlugin = (filename, pathToRes) => {
  let PluginType = null;

  if (filename.toLowerCase().startsWith(TYPE_TO_PREFIX[PLUGIN_TYPE_CONNECTOR])) {
    PluginType = PLUGIN_TYPE_CONNECTOR;

    try {
      const plugin = commonjsRequire(filename);
      const pluginPath = commonjsRequire.resolve(filename);

      if (!pluginPath.startsWith(pathToRes)) {
        debug(`Plugin mismatch error. Plugin ${path.resolve(pathToRes, filename)} loaded from ${pluginPath}! `);
        return null;
      }

      if (!plugin.PluginVersion || !plugin.PluginClass) {
        debug(`Invalid Botium plugin loaded from ${filename}, expected PluginVersion, PluginClass fields`);
        return null;
      }

      if (plugin.PluginType && plugin.PluginType !== PluginType) {
        debug(`Botium plugin loaded from ${filename}, but its type ${plugin.PluginType} is invalid, will be overwritten with ${PluginType}`);
      }

      let pluginNameFromFile = filename.substring(TYPE_TO_PREFIX[PLUGIN_TYPE_CONNECTOR].length);

      if (pluginNameFromFile.toLowerCase().endsWith('.js')) {
        pluginNameFromFile = pluginNameFromFile.substring(0, pluginNameFromFile.length - '.js'.length);
      }

      const PluginDesc = plugin.PluginDesc || {};
      return {
        PluginVersion: plugin.PluginVersion || '1',
        PluginType,
        PluginDesc: { ...PluginDesc,
          src: pluginNameFromFile
        }
      };
    } catch (err) {
      debug(`Loading Botium plugin from ${filename} failed - ${err.message}`);
      return null;
    }
  }

  return null;
};

const getOtherPlugin = (filename, pathToRes, type) => {
  let PluginType = null;

  if (type !== PLUGIN_TYPE_CONNECTOR && filename.toLowerCase().startsWith(TYPE_TO_PREFIX[type])) {
    PluginType = type;
  }

  if (!PluginType) {
    return null;
  }

  try {
    const plugin = commonjsRequire(filename);
    const pluginPath = commonjsRequire.resolve(filename);

    if (!pluginPath.startsWith(pathToRes)) {
      debug(`Plugin mismatch error. Plugin ${path.resolve(pathToRes, filename)} loaded from ${pluginPath}! `);
      return null;
    }

    if (plugin.PluginType && plugin.PluginType !== PluginType) {
      debug(`Botium plugin loaded from ${filename}, but its type ${plugin.PluginType} is invalid, will be overwritten with ${PluginType}`);
    }

    let pluginName = filename.substring(TYPE_TO_PREFIX[type].length);

    if (pluginName.toLowerCase().endsWith('.js')) {
      pluginName = pluginName.substring(0, pluginName.length - '.js'.length);
    }

    const PluginDesc = plugin.PluginDesc || {};
    return {
      PluginVersion: plugin.PluginVersion || '1',
      PluginType,
      PluginDesc: {
        name: pluginName,
        description: PluginDesc.description,
        type: TYPE_TO_COMPONENT_TYPE[type],
        src: filename,
        ref: PluginDesc.ref || pluginName.toUpperCase(),
        global: PluginDesc.global || false,
        args: PluginDesc.args || '{}'
      }
    };
  } catch (err) {
    debug(`Loading Botium plugin from ${filename} failed - ${err.message}`);
    return null;
  }
};

const TYPE_TO_FN = {
  PLUGIN_TYPE_CONNECTOR: getConnectorPlugin,
  PLUGIN_TYPE_ASSERTER: getOtherPlugin,
  PLUGIN_TYPE_LOGICHOOK: getOtherPlugin,
  PLUGIN_TYPE_USERINPUT: getOtherPlugin
};

const getPlugins = async (type, resourcesDir) => {
  if (!TYPE_TO_FN[type]) {
    debug(`Invalid plugin type "${type}"`);
    return Promise.resolve([]);
  }

  const pathToRes = path.resolve(resourcesDir);

  if (!fs.existsSync(pathToRes)) {
    debug(`Cant load plugins, directory ${pathToRes} does not exists`);
    return [];
  }

  let items;

  try {
    items = fs.readdirSync(pathToRes).filter(item => path.extname(item) === '.js' || item.indexOf('.') === -1);
  } catch (err) {
    debug(`Cant load plugins, failed to read directory ${pathToRes} - ${err.message}`);
    return [];
  }

  const result = [];
  const pluginNameToPlugin = {};

  for (let i = 0; i < items.length; i++) {
    const plugin = TYPE_TO_FN[type](items[i], pathToRes, type);

    if (plugin) {
      if (pluginNameToPlugin[plugin.PluginDesc.name]) {
        debug(`Dropping plugin ${JSON.stringify(plugin)} because name is reserved by ${JSON.stringify(pluginNameToPlugin[plugin.PluginDesc.name])}`);
      } else {
        result.push(plugin);
        pluginNameToPlugin[plugin.PluginDesc.name] = plugin;
      }
    }
  }

  return result;
};

var Plugins = {
  getPlugins,
  PLUGIN_TYPE_CONNECTOR,
  PLUGIN_TYPE_ASSERTER,
  PLUGIN_TYPE_LOGICHOOK,
  PLUGIN_TYPE_USERINPUT,
  TYPE_TO_PREFIX
};
Plugins.getPlugins;
Plugins.PLUGIN_TYPE_CONNECTOR;
Plugins.PLUGIN_TYPE_ASSERTER;
Plugins.PLUGIN_TYPE_LOGICHOOK;
Plugins.PLUGIN_TYPE_USERINPUT;
Plugins.TYPE_TO_PREFIX;

var botiumCore = {
  BotDriver: BotDriver_1,
  ScriptingProvider: ScriptingProvider_1,
  ScriptingConstants: Constants,
  Capabilities: Capabilities,
  Defaults: Defaults$1,
  Source: Source,
  Events: Events,
  Plugins: Plugins,
  BotiumError: BotiumError_1.BotiumError,
  ScriptingMemory: ScriptingMemory,
  HookUtils: HookUtils,
  LogicHookConstants: LogicHookConsts,
  Lib: {
    tryLoadPlugin: plugins.tryLoadPlugin,
    SimpleRestContainer: SimpleRestContainer_1
  },
  InboundProxy: proxy,
  BotiumMockRichMessageTypes: BotiumMockRichMessageTypes
};
var botiumCore_1 = botiumCore.BotDriver;
var botiumCore_2 = botiumCore.ScriptingProvider;
var botiumCore_3 = botiumCore.ScriptingConstants;
var botiumCore_4 = botiumCore.Capabilities;
var botiumCore_5 = botiumCore.Defaults;
var botiumCore_6 = botiumCore.Source;
var botiumCore_7 = botiumCore.Events;
var botiumCore_8 = botiumCore.Plugins;
var botiumCore_9 = botiumCore.BotiumError;
var botiumCore_10 = botiumCore.ScriptingMemory;
var botiumCore_11 = botiumCore.HookUtils;
var botiumCore_12 = botiumCore.LogicHookConstants;
var botiumCore_13 = botiumCore.Lib;
var botiumCore_14 = botiumCore.InboundProxy;
var botiumCore_15 = botiumCore.BotiumMockRichMessageTypes;

export { botiumCore_1 as BotDriver, botiumCore_9 as BotiumError, botiumCore_15 as BotiumMockRichMessageTypes, botiumCore_4 as Capabilities, botiumCore_5 as Defaults, botiumCore_7 as Events, botiumCore_11 as HookUtils, botiumCore_14 as InboundProxy, botiumCore_13 as Lib, botiumCore_12 as LogicHookConstants, botiumCore_8 as Plugins, botiumCore_3 as ScriptingConstants, botiumCore_10 as ScriptingMemory, botiumCore_2 as ScriptingProvider, botiumCore_6 as Source, botiumCore as default };
//# sourceMappingURL=botium-es.js.map
